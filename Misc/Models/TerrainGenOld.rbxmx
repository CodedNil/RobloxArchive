<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="LocalScript" referent="RBXDC9F54E8586A45BEAC8A406D274BE390">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">LocalScript</string>
			<ProtectedString name="Source">local module = require(script.GenerationModule)
module.On(game.Players.LocalPlayer:GetMouse())</ProtectedString>
		</Properties>
		<Item class="ModuleScript" referent="RBXE8F42B92932F43FE9F2FF32BCB3981CC">
			<Properties>
				<string name="Name">GenerationModule</string>
				<ProtectedString name="Source">-- Local copy of terrain to call on throughout the script for speed
local terrain = game:WaitForChild(&quot;Workspace&quot;):WaitForChild(&quot;Terrain&quot;)


-----------------------------------
--DEFAULT SETTINGS FOR GENERATION--
-----------------------------------
local TerrainOptions = {}
do
--============== General Settings ============--
&#9;-- Offset to create terrain at.
&#9;-- note, offset can&apos;t be set in the GUI, but it&apos;s useful
&#9;-- to at least have it available.
&#9;TerrainOptions.xpos = 0
&#9;TerrainOptions.zpos = 0
&#9;-- Size of area to generate
&#9;TerrainOptions.width = 400 -- width ~ x size
&#9;TerrainOptions.length = 300 -- length ~ z size
&#9;-- How how the base of the world should be.
&#9;TerrainOptions.baseHeight = 1


--=============== Hill Settings ===============--
&#9;-- How sharp or smooth to make the hills
&#9;TerrainOptions.hillSizeModifier = 1
&#9;-- Should cliffs be generated?
&#9;TerrainOptions.enableCliffs = true
&#9;-- How dense is the cliff generation?
&#9;TerrainOptions.cliffDensityModifier = 1


--============= Mountain Settings =============--
&#9;-- What region to apply mountains to?
&#9;TerrainOptions.mountainMode = &quot;Ridge&quot;
&#9;-- Mountain Frequency, how often mountains occur in the region?
&#9;-- This is a global mask value to apply to mountains, with the formula:
&#9;-- Terrain = mountainlayerAndMask * mountainFrequency + 
&#9;-- otherlayers * 1-mountainFrequency
&#9;TerrainOptions.mountainFrequency = 1
&#9;-- the max height of mountains
&#9;TerrainOptions.mountainHeight = 60
&#9;-- The average size of mountains to make, in terms of a fraction of the map size
&#9;TerrainOptions.mountainSize = 0.15


--============== Water Settings ===============--
&#9;-- Water mode: [None, Lakes, Ocean, Both]
&#9;TerrainOptions.waterMode = &quot;Both&quot;
&#9;-- Lake frequency, how many lakes to place per square in the generated terrain.
&#9;TerrainOptions.lakesPerSquare = 1/10000
&#9;-- How large can the lakes be?
&#9;TerrainOptions.lakeMaxSize = 3000
&#9;-- What should the sea level be?
&#9;TerrainOptions.sealevel = 8


--============= Vegetation Settings ===========--
-- Note: Vegetation generation is not included,
-- in the GUI, but still present in the
-- code if someone wants to play with it.
&#9;-- vegetation mode
&#9;TerrainOptions.vegetationMode = true
&#9;-- vegetation density
&#9;TerrainOptions.vegetationDensity = 1/100


--============== Material Settings ============--
&#9;-- How to color the level
&#9;TerrainOptions.baseColor = 1 -- What material to use for solid color,
&#9; -- and for the main parts of the generation.
&#9;TerrainOptions.colorMode = &quot;Auto Color&quot; -- Values: [Solid Color, Auto Color]
&#9;TerrainOptions.snowtoppedMountains = true
&#9;TerrainOptions.colorMountains = true -- color steep slopes in a grey color
&#9;TerrainOptions.colorCliffs = true -- color clif faces with a marbled texture
&#9;TerrainOptions.soilDepth = 4 -- where soil is, how deep should it be? (with rock below)
end


-- This will store a copy of TerrainOptions when the generate button is pressed.
-- This will then be used for the generation instead of TerrainOptions. This way 
-- TerrainOptions can be changed while generating without messing up what is being 
-- generated.
local GenerateOptions = nil


---------------------
--UTILITY FUNCTIONS--
---------------------
-- Create a deep copy of a table.
-- Copies the elements.
function CopyTable(object)
    local holdTable = {}
    local function Copy(object)
        if type(object) ~= &quot;table&quot; then
            return object
        elseif holdTable[object] then
            return holdTable[object]
        end
        local clone = {}
        holdTable[object] = clone
        for index, value in pairs(object) do
            clone[Copy(index)] = Copy(value)
        end
        return setmetatable(clone, getmetatable(object))
    end
    return Copy(object)
end


------------------
--DEFAULT VALUES--
------------------
-- has the plugin been loaded?
local loaded = false

-- is the plugin currently active?
local on = false

-- Stores the conformation popup when confirming a choice. If not nil then some actions should be blocked.
local ConfirmationPopupObject = nil

-- If true, the clear terrain conformation won&apos;t be shown.
local hideClearConformation = false

-- If true, the genearte terrain conformation won&apos;t be shown.
local hideGenerateConformation = false


----------------
--PLUGIN SETUP--
----------------
-- an event that is fired before the plugin deactivates
local deactivatingEvent = Instance.new(&quot;BindableEvent&quot;)

--==========================================================================================================--
-- GUI Utility functions ==--
--==========================================================================================================--

-- UI gui load. Required for all the GUI code
local RbxGui = LoadLibrary(&quot;RbxGui&quot;)

-- Create a standard text label. Use this for all lables in the popup so it is easy to standardize.
-- labelName - What to set the text label name as.
-- pos &#9; - Where to position the label. Should be of type UDim2.
-- size &#9; - How large to make the label.&#9; Should be of type UDim2.
-- text &#9; - Text to display.
-- parent &#9; - What to set the text parent as.
-- Return:
-- Value is the created label.
function CreateStandardLabel(labelName,
 pos,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; size,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; text,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; parent)
&#9;local label = Instance.new(&quot;TextLabel&quot;, parent)
&#9;label.Name = labelName
&#9;label.Position = pos
&#9;label.Size = size
&#9;label.Text = text
&#9;label.TextColor3 = Color3.new(0.95, 0.95, 0.95)
&#9;label.Font = Enum.Font.ArialBold
&#9;label.FontSize = Enum.FontSize.Size14
&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;label.BackgroundTransparency = 1&#9;
&#9;label.Parent = parent&#9;
&#9;
&#9;return label
end

-- Create a standardized slider.
-- name - Name to use for the slider.
-- pos - Position to display the slider at.
-- steps - How many steps there are in the slider.
-- funcOnChange - Function to call when the slider changes.
-- initValue - Initial value to set the slider to. If nil the slider stays at the default. 
-- parent - What to set as the parent.
-- Return:
-- sliderGui - Slider gui object.
-- sliderPosition - Object that can set the slider value.
function CreateStandardSlider(name,
 pos,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; lengthBarPos,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; steps,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; funcOnChange,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; initValue,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; parent)
&#9;local sliderGui, sliderPosition = RbxGui.CreateSlider(steps, 0, UDim2.new(0,0,0,0))
&#9;
&#9;sliderGui.Name = name
&#9;sliderGui.Parent = parent
&#9;sliderGui.Position = pos
&#9;sliderGui.Size = UDim2.new(1,0,0,20)
&#9;local lengthBar = sliderGui:FindFirstChild(&quot;Bar&quot;)
&#9;lengthBar.Size = UDim2.new(1, -21, 0, 5)
&#9;lengthBar.Position = lengthBarPos
&#9;
&#9;if nil ~= funcOnChange then
&#9;&#9;sliderPosition.Changed:connect(function() funcOnChange(sliderPosition) end)
&#9;end
&#9;
&#9;if nil ~= initValue then 
&#9;&#9;sliderPosition.Value = initValue
&#9;end
&#9;
&#9;return sliderGui, sliderPosition 
end

-- Create a standard dropdown. Use this for all dropdowns in the popup so it is easy to standardize.
-- name - What to set the text label name as.
-- pos &#9; &#9; - Where to position the label. Should be of type UDim2.
-- values &#9; - A table of the values that will be in the dropbox, in the order they are to be shown.
-- initValue&#9; - Initial value the dropdown should be set to.
-- funcOnChange - Function to run when a dropdown selection is made.
-- parent &#9; &#9; - What to set the parent as.
-- Return:
-- dropdown &#9; - The dropdown gui.
-- updateSelection - Object to use to change the current dropdown.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
function CreateStandardDropdown(name,
&#9;&#9;&#9;&#9;&#9;&#9; pos,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;values,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;initValue,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;funcOnChange,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;parent)&#9;&#9;&#9;&#9;&#9;
&#9;-- Create a dropdown selection for the modes to fill in a river
&#9;local dropdown, updateSelection=RbxGui.CreateDropDownMenu(values, funcOnChange);
&#9;dropdown.Name = name
&#9;dropdown.Position = pos
&#9;dropdown.Active = true
&#9;dropdown.Size = UDim2.new(0,150,0,32)
&#9;dropdown.Parent = parent

&#9;updateSelection(initValue)&#9;&#9;

&#9;return dropdown, updateSelection
end&#9;&#9;

-- Keep common button properties here to make it easer to change them all at once.
-- These are the default properties to use for a button.
buttonTextColor = Color3.new(1, 1, 1);
buttonFont = Enum.Font.ArialBold;
buttonFontSize = Enum.FontSize.Size18;

-- Create a standard dropdown. Use this for all dropdowns in the popup so it is easy to standardize.
-- name - What to use.
-- pos &#9; &#9;- Where to position the button. Should be of type UDim2.
-- text - Text to show in the button.
-- funcOnPress - Function to run when the button is pressed.
-- parent &#9; &#9;- What to set the parent as.
-- Return:
-- button &#9; - The button gui.&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
function CreateStandardButton(name,
 &#9;&#9;&#9;&#9;&#9;&#9;&#9; pos,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; text,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; funcOnPress,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; parent,
&#9;&#9;&#9;&#9;&#9;&#9;&#9; size)&#9;&#9;&#9;&#9;&#9;
&#9;local button = Instance.new(&quot;TextButton&quot;, parent)
&#9;button.Name = name
&#9;button.Position = pos

&#9;button.Size = UDim2.new(0,120,0,40)
&#9;button.Text = text

&#9;if size then
&#9;&#9;button.Size = size
&#9;end
&#9;
&#9;button.Style = Enum.ButtonStyle.RobloxButton

&#9;button.TextColor3 = buttonTextColor
&#9;button.Font = buttonFont
&#9;button.FontSize = buttonFontSize

&#9;button.MouseButton1Click:connect(funcOnPress)
&#9;
&#9;return button
end&#9;


-- Create a standard accordion, which contains many child areas that can be
-- swiched between
-- name
-- pos - Where to put it
-- childList - List of children to add, format: [{Name = ..., Gui = ..., Height = ...}]
-- 
function CreateStandardAccordion(name, 
&#9; pos, 
&#9; size, 
&#9; childList, 
&#9; parent)
&#9;local frame = Instance.new(&apos;Frame&apos;, parent)
&#9;frame.Position = pos
&#9;frame.Size = size
&#9;frame.Name = name
&#9;frame.ClipsDescendants = true
&#9;frame.BackgroundTransparency = 1
&#9;--
&#9;local childContainerList = {}
&#9;--
&#9;local function doLayout(pressedItem)
&#9;&#9;local atY = 0
&#9;&#9;for _, child in pairs(childContainerList) do
&#9;&#9;&#9;child.Gui.Position = UDim2.new(0, 0, 0, atY)
&#9;&#9;&#9;if child == pressedItem then
&#9;&#9;&#9;&#9;child.Gui.Size = UDim2.new(1, 0, 0, child.DesiredHeight)
&#9;&#9;&#9;&#9;child.Gui.HeadingButton.TextColor3 = Color3.new(1, 0.7, 0.7)
&#9;&#9;&#9;&#9;child.ChildGui.Visible = true
&#9;&#9;&#9;&#9;atY = atY + child.DesiredHeight
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Gui.Size = UDim2.new(1, 0, 0, 40)
&#9;&#9;&#9;&#9;child.Gui.HeadingButton.TextColor3 = buttonTextColor
&#9;&#9;&#9;&#9;child.ChildGui.Visible = false
&#9;&#9;&#9;&#9;atY = atY + 25
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--
&#9;for _, childData in pairs(childList) do
&#9;&#9;local childContainer = Instance.new(&apos;Frame&apos;, frame)
&#9;&#9;childContainer.BackgroundTransparency = 1
&#9;&#9;childContainer.ClipsDescendants = true
&#9;&#9;--
&#9;&#9;local childHeader = Instance.new(&apos;TextButton&apos;, childContainer)
&#9;&#9;childHeader.Name = &apos;HeadingButton&apos;
&#9;&#9;childHeader.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;childHeader.Size = UDim2.new(1, 0, 0, 30)
&#9;&#9;childHeader.TextColor3 = buttonTextColor
&#9;&#9;childHeader.Font = buttonFont
&#9;&#9;childHeader.FontSize = buttonFontSize
&#9;&#9;childHeader.Text = &quot; v &quot;..childData.Name..&quot; v &quot;
&#9;&#9;--
&#9;&#9;childData.Gui.BackgroundTransparency = 1
&#9;&#9;childData.Gui.Position = UDim2.new(0, 0, 0, 30)
&#9;&#9;childData.Gui.Size = UDim2.new(1, 0, 1, -30)
&#9;&#9;childData.Gui.Parent = childContainer
&#9;&#9;--
&#9;&#9;local data = {
&#9;&#9;&#9;Gui = childContainer;
&#9;&#9;&#9;ChildGui = childData.Gui;
&#9;&#9;&#9;DesiredHeight = childData.Height + 30;
&#9;&#9;}
&#9;&#9;childContainerList[#childContainerList+1] = data
&#9;&#9;--
&#9;&#9;childHeader.MouseButton1Click:connect(function() doLayout(data) end)
&#9;end
&#9;--do an initial layout
&#9;doLayout(childContainerList[1])
&#9;--
&#9;return frame
end

-- Confirmation Popup GUI
ConfirmationPopup = {}
ConfirmationPopup.__index = ConfirmationPopup&#9;&#9;&#9;&#9;&#9; 
do 
&#9;-- Create a confirmation popup.
&#9;--
&#9;-- confirmText - What to display in the popup.
&#9;-- confirmButtonText - What to display in the popup.
&#9;-- declineButtonText - What to display in the popup.
&#9;-- confirmFunction - Function to run on confirmation.
&#9;-- declineFunction - Function to run when declining.
&#9;--
&#9;-- Return:
&#9;-- Value a table with confirmation gui and options.&#9;
&#9;function ConfirmationPopup.Create(confirmText,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; confirmButtonText,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; declineButtonText,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; confirmFunction,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; declineFunction)&#9;&#9;&#9; 
&#9;&#9;local popup = {}
&#9;&#9;popup.confirmButton = nil&#9;&#9;&#9;-- Hold the button to confirm a choice.
&#9;&#9;popup.declineButton = nil&#9;&#9;&#9;-- Hold the button to decline a choice.&#9;&#9; &#9;&#9;&#9; 
&#9;&#9;popup.confirmationFrame = nil -- Hold the conformation frame.
&#9;&#9;popup.confirmationText = nil -- Hold the text label to display the conformation message.
&#9;&#9;popup.confirmationHelpText = nil -- Hold the text label to display the conformation message help.


&#9;&#9;popup.confirmationFrame = Instance.new(&quot;Frame&quot;, MainScreenGui)
&#9;&#9;popup.confirmationFrame.Name = &quot;ConfirmationFrame&quot;
&#9;&#9;popup.confirmationFrame.Size = UDim2.new(0, 280, 0, 140)
&#9;&#9;popup.confirmationFrame.Position = UDim2.new(.5, -popup.confirmationFrame.Size.X.Offset/2, 0.5, -popup.confirmationFrame.Size.Y.Offset/2)
&#9;&#9;popup.confirmationFrame.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;popup.confirmLabel = CreateStandardLabel(&quot;ConfirmLabel&quot;, UDim2.new(0,0,0,15), UDim2.new(1, 0, 0, 24), confirmText, popup.confirmationFrame)
&#9;&#9;popup.confirmLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;popup.confirmLabel.TextXAlignment = Enum.TextXAlignment.Center

&#9;&#9;-- Confirm
&#9;&#9;popup.confirmButton = CreateStandardButton(&quot;ConfirmButton&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;UDim2.new(0.5, -120, 1, -50),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; confirmButtonText,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; confirmFunction,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; popup.confirmationFrame)&#9;

&#9;&#9;-- Decline
&#9;&#9;popup.declineButton = CreateStandardButton(&quot;DeclineButton&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;UDim2.new(0.5, 0, 1, -50),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; declineButtonText,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; declineFunction,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; popup.confirmationFrame)&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;

&#9;&#9;setmetatable(popup, ConfirmationPopup)

&#9;&#9;return popup
&#9;end&#9;

&#9;-- Clear the popup, free up assets.
&#9;function ConfirmationPopup:Clear()

&#9;&#9;if nil ~= self.confirmButton then
&#9;&#9;&#9;self.confirmButton.Parent = nil
&#9;&#9;end

&#9;&#9;if nil ~= self.declineButton then
&#9;&#9;&#9;self.declineButton.Parent = nil&#9;
&#9;&#9;end

&#9;&#9;if nil ~= self.confirmationFrame then
&#9;&#9;&#9;self.confirmationFrame.Parent = nil
&#9;&#9;end

&#9;&#9;if nil ~= self.confirmLabel then
&#9;&#9;&#9;self.confirmLabel.Parent = nil 
&#9;&#9;end

&#9;&#9;self.confirmButton = nil
&#9;&#9;self.declineButton = nil&#9;&#9;&#9; 
&#9;&#9;self.conformationFrame = nil
&#9;&#9;self.conformText = nil 
&#9;end
end

--==========================================================================================================--
-- Progres Bar Handling ==--
--==========================================================================================================--

-- Container used to store the data about the progress bar. The style of the stupid 
-- RbxGui library gives us a whole bunch of return values when creating one, and
-- sticking them all in a table is the best way to deal with them.
CancelValues = {cancelAction = false, -- Used to cancel currently occuring actions. If set to true then terrain generation will stop.
&#9;&#9;&#9;&#9;progressBar = nil, &#9; -- Will store the progress bar when needed.
&#9;&#9;&#9;&#9;setAmountFunc = nil, -- Stores a function tied to the progres bar that sets the progress bar precentage done.
&#9;&#9;&#9;&#9;bindForCancel = nil} -- Stores a function bind that will be set with the function to run when the cancel button is pressed in the progress bar.

-- Load the progress bar to display when drawing a river.
-- text - Text to display.
function LoadProgressBar(text)
&#9;if CancelValues.progressBar == nil then
&#9;&#9;CancelValues.isDrawing = true
&#9;&#9;
&#9;&#9;-- Start the progress bar.
&#9;&#9;CancelValues.progressBar, CancelValues.setAmountFunc, CancelValues.bindForCancel = RbxGui.CreateLoadingFrame(text)
&#9;&#9;CancelValues.progressBar.Position = UDim2.new(.5, -CancelValues.progressBar.Size.X.Offset/2, 0, 15)
&#9;&#9;CancelValues.progressBar.Parent = MainScreenGui
&#9;&#9;CancelValues.bindForCancel.Event:connect(function(arguments)
&#9;&#9;&#9;CancelValues.cancelActions = true&#9;&#9;-- Set the flag that everything should stop.
&#9;&#9;&#9;coroutine.yield() -- No idea why this is here?????? Breaks without it, don&apos;t remove.
&#9;&#9;end)
&#9;else
&#9;&#9;print(&apos;Tried to start the progress bar when it was already running.&apos;)
&#9;end
end

-- Unload the progress bar.
function UnloadProgressBar()
&#9;CancelValues.isDrawing = false
&#9;CancelValues.cancelActions = false
&#9;
&#9;if nil ~= CancelValues.progressBar then
&#9;&#9;CancelValues.progressBar.Parent = nil
&#9;&#9;CancelValues.progressBar = nil
&#9;&#9;CancelValues.setAmountFunc = nil
&#9;&#9;CancelValues.bindForCancel = nil
&#9;end
end&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;


--==========================================================================================================--
-- Main Terrain generation and clearing code ==--
--==========================================================================================================--

-- Set the camera to look at the terrain from a distance so that all terrain will be in view.
-- centerX, centerZ - Center coordinate of land. This doesn&apos;t take into account clipping.
-- length, width - Land dimensions.
function SetCamera(centerX, centerZ, length, width)
&#9;local currCamera = game.Workspace.CurrentCamera
&#9;local cameraPos = Vector3.new(0, 400, 1600)
&#9;local cameraFocus = Vector3.new(0, 255, 0)
&#9;
&#9;-- Nothing set so use the default.
&#9;if nil ~= centerX then
&#9;&#9;local scale = 0
&#9;&#9;local lengthScale = 0
&#9;&#9;local widthScale = 0
&#9;&#9;
&#9;&#9;if length &lt;= 64 then
&#9;&#9;&#9;lengthScale = .35
&#9;&#9;elseif length &lt;= 128 then
&#9;&#9;&#9;lengthScale = .5
&#9;&#9;elseif length &lt;= 256 then
&#9;&#9;&#9;lengthScale = .7
&#9;&#9;else
&#9;&#9;&#9;lengthScale = 1.3
&#9;&#9;end
&#9;&#9;
&#9;&#9;if width &lt;= 64 then
&#9;&#9;&#9;widthScale = .35
&#9;&#9;elseif width &lt;= 128 then
&#9;&#9;&#9;widthScale = .4
&#9;&#9;elseif width &lt;= 256 then
&#9;&#9;&#9;widthScale = .4
&#9;&#9;else
&#9;&#9;&#9;widthScale = .7
&#9;&#9;end&#9;&#9;
&#9;&#9;
&#9;&#9;if widthScale &gt; lengthScale then
&#9;&#9;&#9;scale = widthScale
&#9;&#9;else
&#9;&#9;&#9;scale = lengthScale
&#9;&#9;end

&#9;&#9;local distance = Vector3.new(0, (200*scale) + 200, (1100*scale))
&#9;&#9;cameraPos = Vector3.new(centerX + distance.X, distance.Y, centerZ + distance.Z)
&#9;&#9;cameraFocus = Vector3.new(centerX, 0, centerZ)
&#9;end&#9;
&#9;
&#9;currCamera.CoordinateFrame = CFrame.new(cameraPos.X, cameraPos.Y, cameraPos.Z)
&#9;currCamera.Focus = CFrame.new(cameraFocus.X, cameraFocus.Y, cameraFocus.Z)&#9;
end

-- Function used by the clear button. Prompts the user first.
-- Will not show if disabled or terrain is being processed.
function ConfirmClearTerrain()
&#9;-- Only do if something isn&apos;t already being processed.
&#9;if nil == CancelValues.progressBar then
&#9;&#9;if nil == ConfirmationPopupObject then
&#9;&#9;&#9;if not hideClearConformation then
&#9;&#9;&#9;&#9;ConfirmationPopupObject = ConfirmationPopup.Create(&quot;Clear Terrain?&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Clear&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Cancel&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ClearConformation()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ClearTerrain()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; end, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ClearConformation,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;hideClearConformation = not hideClearConformation 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return not hideClearConformation
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;ClearTerrain()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- Function used by the generate button. Prompts the user first.
-- Will not show if disabled or terrain is being processed.
function ConfirmGenerateTerrain()
&#9;-- Only do if something isn&apos;t already being processed.
&#9;if nil == CancelValues.progressBar then&#9;
&#9;&#9;if nil == ConfirmationPopupObject then
&#9;&#9;&#9;if not hideGenerateConformation then
&#9;&#9;&#9;&#9;ConfirmationPopupObject = ConfirmationPopup.Create(&quot;Generate Terrain?&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Generate&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &quot;Cancel&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ClearConformation()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; GenerateTerrain()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; end, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ClearConformation,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;hideGenerateConformation = not hideGenerateConformation 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return not hideGenerateConformation
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; end)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;GenerateTerrain()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

-- Unload the conformation popup if it exists.&#9;&#9;&#9; 
-- Does nothing if the popup isn&apos;t set.
function ClearConformation()
&#9;if nil ~= ConfirmationPopupObject then
&#9;&#9;ConfirmationPopupObject:Clear()
&#9;&#9;ConfirmationPopupObject = nil
&#9;end
end&#9;

local floor, ceil, sqrt, sin, cos, max, min, abs, random, log, noise, huge, rad, pi = math.floor, math.ceil, math.sqrt, math.sin, math.cos, math.max, math.min, math.abs, math.random, math.log, math.noise, math.huge, math.rad, math.pi

-- Create terrain based on the current properties.
function GenerateTerrain()
&#9;-- don&apos;t let the user fiddle with things while we&apos;re running the generator
&#9;--toolbarbutton:SetActive(false)
&#9;
&#9;-- Make the cache of the TerrainOptions to use for our generation settings, that can&apos;t get messed with
&#9;-- while we&apos;re generating.
&#9;GenerateOptions = CopyTable(TerrainOptions)

&#9;-- Turn off the plugin to give the user a better view, and disuade them from trying something silly
&#9;-- like generating twice at the same time.
&#9;Off()
&#9;
&#9;-- Create the progress bar that will track terrain creation completion.
&#9;LoadProgressBar(&quot;Generating Terrain&quot;)

&#9;-- Reposition to get a good view.
&#9;SetCamera(GenerateOptions.xpos, GenerateOptions.zpos, GenerateOptions.length, GenerateOptions.width)


&#9;------------------------------------------------------------------------------------------------------
&#9;-- Update the message displayed to the user durring generation
&#9;------------------------------------------------------------------------------------------------------
&#9;local function UpdateGenerationProgressMessage(text)
&#9;&#9;if not CancelValues.progressBar then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;CancelValues.progressBar.loadingName.Text = text
&#9;end


&#9;------------------------------------------------------------------------------------------------------
&#9;-- Easy pausing code, which will only wait at most once every 1/9 second
&#9;-- Lets us generate faster without completely freezing the game from the user&apos;s perspective.
&#9;------------------------------------------------------------------------------------------------------
&#9;local LastPause = tick()
&#9;local function pause()
&#9;&#9;if tick()-LastPause &gt; 1/6 then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;LastPause = tick()
&#9;&#9;end
&#9;end

&#9;------------------------------------------------------------------------------------------------------
&#9;-- Some fixed settings that haven&apos;t migrated to the TerrainOptions yet because they&apos;re carefully
&#9;-- hard coded values.
&#9;------------------------------------------------------------------------------------------------------
&#9;local CLIFFS_PER_SQ = 1/2000
&#9;--
&#9;local MIDDLE_RIDGE_RADIUS = 40 --the base radius of the middle ridge
&#9;local MIDDLE_RIDGE_VARIANCE = 50 --how much to vary the boundary by
&#9;local MIDDLE_RIDGE_FADE = 35 --how large a distance to fade the mountains on around the boundary


&#9;------------------------------------------------------------------------------------------------------
&#9;-- Utility functions
&#9;------------------------------------------------------------------------------------------------------
&#9;--is a coord in the bounds? ( x elemof [1,GenerateOptions.width], z elemof [1,GenerateOptions.length] )
&#9;
&#9;function PerlinNoiseMap(lambda)
&#9;&#9;local key = math.random() * 1000
&#9;&#9;local map = {}
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;map[x] = {}
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;map[x][z] = (noise(x/lambda, z/lambda + key) + 1)/2
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return map
&#9;end

&#9;local function InBound(x, z)
&#9;&#9;return x &gt;= 1 and x &lt;= GenerateOptions.width and
&#9;&#9; z &gt;= 1 and z &lt;= GenerateOptions.length
&#9;end
&#9;local function at(heightMap, x, z)
&#9;&#9;if x &gt; GenerateOptions.width then x = GenerateOptions.width end
&#9;&#9;if x &lt; 1 then x = 1 end
&#9;&#9;if z &gt; GenerateOptions.length then z = GenerateOptions.length end
&#9;&#9;if z &lt; 1 then z = 1 end
&#9;&#9;return heightMap[x][z]
&#9;end

&#9;--curving functions. They are smooth curves that may values in [0,1] -&gt; [0,1] in usefull ways. In 
&#9;--particular they are used to change the distribution of perlin noise to generate more natural hills
&#9;local function quad_curve(n) --slightly S shaped curve, with tangent -&gt; 2 as x -&gt; 0.5
&#9;&#9;if n &lt; 0.5 then
&#9;&#9;&#9;return n*n + 0.5*n
&#9;&#9;else
&#9;&#9;&#9;return -n*n +2.5*n -0.5
&#9;&#9;end
&#9;end
&#9;local function root2_curve(n) --S shaped with a vertical tangent as x -&gt; .5
&#9;&#9;if n &lt; 0.5 then
&#9;&#9;&#9;return 0.5-sqrt(0.5^2 - n^2)
&#9;&#9;else
&#9;&#9;&#9;return sqrt(0.5^2 - (1-n)^2)+0.5
&#9;&#9;end
&#9;end
&#9;local function sin4_smallbias_curve(n) --Like quad_curve but biased to smaller outputs
&#9;&#9;return sin((0.5*3.141592653)*n)^4
&#9;end
&#9;local function sin4_largebias_curve(n) --like quad_curve but biased to larger outputs
&#9;&#9;return 1-sin((0.5*3.141592653)*(1-n))^4
&#9;end

&#9;-- main generation functions begin:

&#9;local BaseLayer, IsPlainsMap, MedFreqHills, HighFreqHills, SmallNoiseMap, Quantity, IsCrags, CragsMap
&#9;local CliffMap
&#9;local SteepMountains, ShallowMountains, SwitchMap, MountainDetailA, MountainDetailB, MountainDetailC, MountainHighDetailShow
&#9;local RidgeLengthMap, RidgeWidthMap
&#9;local mountainMask
&#9;local TreeMapA, TreeMapB
&#9;local FlecksMapA, FlecksMapB, FlecksMapC
&#9;
&#9;local function GeneratePerlinMaps()
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Generating Perlin Maps&quot;)
&#9;&#9;
&#9;&#9;local minDimension = min(GenerateOptions.width, GenerateOptions.length)
&#9;&#9;
&#9;&#9;local CurrentMap = 0
&#9;&#9;local TotalMaps = 25
&#9;&#9;local function QueMap(lambda)
&#9;&#9;&#9;CurrentMap = CurrentMap + 1
&#9;&#9;&#9;pause()
&#9;&#9;&#9;CancelValues.setAmountFunc(CurrentMap/TotalMaps)
&#9;&#9;&#9;return PerlinNoiseMap(lambda)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local mod = 1/GenerateOptions.hillSizeModifier
&#9;&#9;BaseLayer = QueMap(70*mod)
&#9;&#9;IsPlainsMap = QueMap(80*mod) --where should the area be flatter?
&#9;&#9;MedFreqHills = QueMap(28*mod)
&#9;&#9;HighFreqHills = QueMap(14*mod)
&#9;&#9;SmallNoiseMap = QueMap( 4*mod)
&#9;&#9;Quantity = QueMap(60*mod) --how sparse or dense areas of hills should be
&#9;&#9;IsCrags = QueMap(100*mod)
&#9;&#9;CragsMap = QueMap(30*mod)
&#9;&#9;
&#9;&#9;CliffMap = QueMap(70)
&#9;&#9;
&#9;&#9;SteepMountains = QueMap( minDimension*GenerateOptions.mountainSize*0.9 ) --40)
&#9;&#9;ShallowMountains = QueMap( minDimension*GenerateOptions.mountainSize*1.1 ) --50)
&#9;&#9;SwitchMap = QueMap( minDimension*GenerateOptions.mountainSize*1.7 ) --90) --which of steep or shallow to use
&#9;&#9;MountainDetailA = QueMap( 2.5 )
&#9;&#9;MountainDetailB = QueMap( 5 )
&#9;&#9;MountainDetailC = QueMap( 12 )
&#9;&#9;MountainHighDetailShow = QueMap( 20 )
&#9;&#9;
&#9;&#9;RidgeLengthMap = QueMap(GenerateOptions.length/4) -- was 60
&#9;&#9;RidgeWidthMap = QueMap(GenerateOptions.width/4)
&#9;&#9;
&#9;&#9;RingWidthMap = QueMap(minDimension/4)
&#9;&#9;
&#9;&#9;mountainMask = QueMap(minDimension*GenerateOptions.mountainSize)
&#9;&#9;
&#9;&#9;TreeMapA = QueMap(200)
&#9;&#9;TreeMapB = QueMap(100)
&#9;&#9;
&#9;&#9;FlecksMapA = QueMap(40)
&#9;&#9;FlecksMapB = QueMap(25)
&#9;&#9;FlecksMapC = QueMap(15)
&#9;end
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Clear the terrain, readying the game for a new generation.
&#9;------------------------------------------------------------------------------------------------------
&#9;local function ClearTerrain()
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Clearing Old Terrain&quot;)
&#9;&#9;terrain:Clear()
&#9;&#9;CancelValues.setAmountFunc(1)
&#9;end&#9;
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Make the base layer, a hieghtmap that is relatively flat hills and valleys covering the
&#9;-- whole map.
&#9;-- Returns: A GenerateOptions.widthxGenerateOptions.length table heightmop representing the base of the map.
&#9;------------------------------------------------------------------------------------------------------
&#9;local function MakeBaseLayer()
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Generating Base Layer&quot;)
&#9;&#9;--
&#9;&#9;local baseLayer = {}
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;CancelValues.setAmountFunc(x/GenerateOptions.width)
&#9;&#9;&#9;pause()
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;baseLayer[x] = {}
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;--------
&#9;&#9;&#9;&#9;-- I hope this is readable enough.... that&apos;s the best that I can do. Rest assured, it&apos;s
&#9;&#9;&#9;&#9;-- doing a whole pile of fiddling with perlin noise. The general strategy uses 3 parts:
&#9;&#9;&#9;&#9;-- 1) A Base Layer - Just typical perlin noise scaled by some amount.
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;-- 2) A Mask Layer - Determines where the base layer should show up, through 
&#9;&#9;&#9;&#9;-- multiplication with the base layer.
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;-- 3) A Freqency Layer - The mask layer is also raised to a power. The higher the power,
&#9;&#9;&#9;&#9;-- The more sparsely distributed the feature will be.
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local quant = Quantity[x][z]
&#9;&#9;&#9;&#9;local hf = quad_curve( HighFreqHills[x][z] )
&#9;&#9;&#9;&#9;local mf = quad_curve( MedFreqHills[x][z] )
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;baseLayer[x][z] = quad_curve(BaseLayer[x][z])*8
&#9;&#9;&#9;&#9; + max( 
&#9;&#9;&#9;&#9; 85* CragsMap[x][z]^(2.5+ 0 ) * max(0, IsCrags[x][z]-0.3 ),
&#9;&#9;&#9;&#9; 12* mf^(1.5+quant) * min(1, IsPlainsMap[x][z]+0.5)
&#9;&#9;&#9;&#9; )
&#9;&#9;&#9;&#9; + 6* hf^(2.0+quant) *IsPlainsMap[x][z]
&#9;&#9;&#9;&#9; + GenerateOptions.baseHeight 
&#9;&#9;&#9;&#9; + SmallNoiseMap[x][z]*0.9
&#9;&#9;&#9;&#9;--------
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return baseLayer
&#9;end
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- A function which carves small cliff faces into the map.
&#9;-- These small cliff faces give the map the appearance that water has been flowing through it, in
&#9;-- contrast to just having the hilly terrain that raw noise will give you.
&#9;-- The cliffs are made by choosing &quot;cleaving planes&quot;, and shearing the nearby terrain above and below 
&#9;-- it away from it.
&#9;------------------------------------------------------------------------------------------------------
&#9;local function ApplyCliffs(baseLayer)
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Eroding Cliffs&quot;)
&#9;
&#9;&#9;-- are cliffs enabled?
&#9;&#9;if not GenerateOptions.enableCliffs then return end
&#9;
&#9;&#9;--First get a noise map of how cliffey different areas of the map are. This gives some variation
&#9;&#9;--rather than just having all parts of the map have cliffs on them.
&#9;
&#9;&#9;-- generate an inermediary hight map to store changes to the map as a result of applying cliffs.
&#9;&#9;-- this is important because we want to clamp the maximum effect that cliffs can have on the map 
&#9;&#9;-- to something around +/-5. Which is most efficiently done with another hight map.
&#9;&#9;local cliffs = {}
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;cliffs[x] = {}
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;cliffs[x][z] = 0 --for summing, initialize to 0 
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;--Now, we need to apply the cliffs in two phases. For every cliff we first see exactly what kind
&#9;&#9;--of feature it would create, and then if it creates a &quot;good&quot; one go through again and actually
&#9;&#9;--apply it to the heightmap. For example, if a cliff ends up being a &quot;pothole&quot;, that is, a really
&#9;&#9;--small circular dent, then discard it.
&#9;&#9;--It turns out that the fastest way to do things is just guessing cliffs and seeing which ones
&#9;&#9;--end up good, rather than using a more complex approach.
&#9;
&#9;&#9;--generate a good number of cliffs. 1 cliff / 2000 studs^2 turns out to be best
&#9;&#9;local cliffsToGenerate = floor(GenerateOptions.width*GenerateOptions.length*CLIFFS_PER_SQ*GenerateOptions.cliffDensityModifier)
&#9;&#9;for CliffNum = 1, cliffsToGenerate do
&#9;&#9;&#9;CancelValues.setAmountFunc(CliffNum/cliffsToGenerate)
&#9;&#9;&#9;pause()
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;--
&#9;&#9;&#9;--first, generate the stats of this cliff
&#9;&#9;&#9;local x, z = random(2,GenerateOptions.width-1), random(2,GenerateOptions.length-1) --random position
&#9;&#9;&#9;local radius = random(20,50) --random radius of effect
&#9;&#9;&#9;local amplitude = random(4,9) --random amplitude the +/- of heigh generated
&#9;
&#9;&#9;&#9;--TODO: We can improve this function by finding the &quot;normal&quot; of the terrain surface and 
&#9;&#9;&#9;-- putting the cleaving plane deliberately more perpendicular to it, but this is
&#9;&#9;&#9;-- quite hard to do well in the general case.
&#9;&#9;&#9;-- --get the average &quot;normal&quot; of the surface in question
&#9;&#9;&#9;-- for dx = -radius,radius do
&#9;&#9;&#9;-- &#9;for dz = -radius,radius do
&#9;&#9;&#9;-- &#9;&#9;local xp,zp = x+dx,z+dz
&#9;&#9;&#9;-- &#9;&#9;local r_2 = dx*dx + dz*dz
&#9;&#9;&#9;-- &#9;&#9;--
&#9;&#9;&#9;-- &#9;&#9;if (r_2 &lt; radius*radius) then
&#9;&#9;&#9;-- &#9;&#9;&#9;-- 
&#9;&#9;&#9;-- &#9;&#9;end
&#9;&#9;&#9;-- &#9;end
&#9;&#9;&#9;-- end&#9;&#9;&#9;
&#9;
&#9;&#9;&#9;--the plane to make the &quot;cut&quot; at. We generate a normal and then solve for the plane at the
&#9;&#9;&#9;--position chosen and with that normal. That plane is then used to find the height of the cut
&#9;&#9;&#9;--at each affected cell.
&#9;&#9;&#9;local cliffAtElevation = baseLayer[x][z]
&#9;&#9;&#9;local norm = Vector3.new(random()*0.5-0.25,1,random()*0.5-0.25).unit
&#9;&#9;&#9;local planeA, planeB, planeC = norm.x,norm.y,norm.z
&#9;&#9;&#9;local planeD = -(planeA*x + planeB*cliffAtElevation + planeC*z) 
&#9;&#9;&#9;local function elevationAt(x,z)
&#9;&#9;&#9;&#9;return -(planeA*x + planeC*z + planeD)/planeB
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;--first, check for potholes (and other bad features that you may want to).
&#9;&#9;&#9;--we do this by counting the number of squares pushed up and number pushed down. This may
&#9;&#9;&#9;--seem odd but it is a good fast hueristic. Generally petholes occurr when less than 20%
&#9;&#9;&#9;--of the squares are pushed down.
&#9;&#9;&#9;--if we hit exactly on a straight line we would expect 50%-50%, and most good features are in
&#9;&#9;&#9;--the 25%-75% range. 
&#9;&#9;&#9;local upCount, downCount = 0,0
&#9;&#9;&#9;for dx = -radius,radius do
&#9;&#9;&#9;&#9;for dz = -radius,radius do
&#9;&#9;&#9;&#9;&#9;local xp,zp = x+dx,z+dz
&#9;&#9;&#9;&#9;&#9;local r_2 = dx*dx + dz*dz
&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;if (r_2 &lt; radius*radius) and InBound(xp,zp) then
&#9;&#9;&#9;&#9;&#9;&#9;local avrHeight = (at(baseLayer,xp+1,zp ) + at(baseLayer,xp-1,zp ) + 
&#9;&#9;&#9;&#9;&#9;&#9; at(baseLayer,xp ,zp ) +
&#9;&#9;&#9;&#9;&#9;&#9; at(baseLayer,xp ,zp+1) + at(baseLayer,xp, zp-1))/5
&#9;&#9;&#9;&#9;&#9;&#9;if avrHeight &gt; cliffAtElevation then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;upCount = upCount+1
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;downCount = downCount+1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;--now, if we aren&apos;t in that bad 20% on either end, apply the changes to the heightmap
&#9;&#9;&#9;if downCount/(upCount+downCount) &gt; 0.2 and upCount/(upCount+downCount) &gt; 0.2 then
&#9;&#9;&#9;&#9;for dx = -radius,radius do
&#9;&#9;&#9;&#9;&#9;for dz = -radius,radius do
&#9;&#9;&#9;&#9;&#9;&#9;local xp,zp = x+dx,z+dz
&#9;&#9;&#9;&#9;&#9;&#9;local r = sqrt(dx*dx + dz*dz)
&#9;&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;&#9;--for every square which in-bounds square in the range of the effect
&#9;&#9;&#9;&#9;&#9;&#9;if (r &lt; radius) and InBound(xp,zp) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--find the average hieght at this square, and compare it to the 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local avrHeight = (at(baseLayer,xp+1,zp ) + at(baseLayer,xp-1,zp ) + 
&#9;&#9;&#9;&#9;&#9;&#9;&#9; at(baseLayer,xp ,zp ) +
&#9;&#9;&#9;&#9;&#9;&#9;&#9; at(baseLayer,xp ,zp+1) + at(baseLayer,xp, zp-1))/5
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local nearnessToCenter = sin4_smallbias_curve((radius-r)/radius)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cliffiness = quad_curve(CliffMap[xp][zp])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if avrHeight &gt; elevationAt(xp,zp) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cliffs[xp][zp] = cliffs[xp][zp] + nearnessToCenter*amplitude*cliffiness
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cliffs[xp][zp] = cliffs[xp][zp] - nearnessToCenter*amplitude*cliffiness
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;--now, apply all of the changes stored in the cliffs map to the baseLayer, clamping the
&#9;&#9;--cliffs value to +/- 4 in the process.
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;local v = cliffs[x][z]
&#9;&#9;&#9;&#9;if v &gt; 4 then v = 4 end
&#9;&#9;&#9;&#9;if v &lt; -4 then v = -4 end
&#9;&#9;&#9;&#9;baseLayer[x][z] = baseLayer[x][z] + v
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end&#9;
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Next we have to generate a high mountain layer to separate the two sides of the combat.
&#9;-- Rather than using some heavily built up recursive noise, only a couple layers of noise are used,
&#9;-- this gives the effect of valleys between the peaks, that let players find a nice strategic path
&#9;-- to get to the other side of the map or prevent the opponents from as a part of the gameplay.
&#9;--
&#9;-- Returns: MountainMask, MountainHeight
&#9;------------------------------------------------------------------------------------------------------
&#9;local function ApplyMountains(baseLayer)
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Building Mountain Layer&quot;)
&#9;
&#9;&#9;-- first off, a sanity check: check that the mountain height is higher than the base layer.
&#9;&#9;-- If not it doesn&apos;t make sense to place any mountains.
&#9;&#9;-- Also do this if there are no mountains requested
&#9;&#9;if GenerateOptions.mountainHeight &lt;= GenerateOptions.baseHeight or GenerateOptions.mountainMode == &quot;None&quot; then
&#9;&#9;&#9;-- just return no mountains
&#9;&#9;&#9;local mountains = {}
&#9;&#9;&#9;local mask = {}
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;mountains[x] = {}
&#9;&#9;&#9;&#9;mask[x] = {}
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;mountains[x][z] = 0
&#9;&#9;&#9;&#9;&#9;mask[x][z] = 0
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return mask, mountains
&#9;&#9;end
&#9;
&#9;&#9;--
&#9;&#9;-- now we need to generate the mountain &quot;mask&quot;, which is where the mountains will be shown
&#9;&#9;-- down the center of the map.
&#9;&#9;local mountainMask = {}
&#9;&#9;if GenerateOptions.mountainMode == &quot;Ridge&quot; then
&#9;&#9;&#9;-- Ridge mode, generates a ridge of mountains down the middle of the map
&#9;&#9;&#9;-- We sort of need two copies of this code, as depending which dimension of the terrain
&#9;&#9;&#9;-- is larger, we need to change the orientation of the ridge, but this is not easy.
&#9;&#9;&#9;if GenerateOptions.width &lt; GenerateOptions.length then
&#9;&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(x / GenerateOptions.width)
&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;&#9;&#9;mountainMask[x] = {}
&#9;&#9;&#9;&#9;&#9;local radius = ceil(MIDDLE_RIDGE_RADIUS + MIDDLE_RIDGE_VARIANCE*RidgeLengthMap[x][1])
&#9;&#9;&#9;&#9;&#9;local center = floor(GenerateOptions.length/2)
&#9;&#9;&#9;&#9;&#9;--lead up to 
&#9;&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;&#9;local distToCenter = abs(center-z)
&#9;&#9;&#9;&#9;&#9;&#9;if distToCenter &lt; radius - MIDDLE_RIDGE_FADE then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 1
&#9;&#9;&#9;&#9;&#9;&#9;elseif distToCenter &lt; radius + MIDDLE_RIDGE_FADE then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;((radius+MIDDLE_RIDGE_FADE)-distToCenter) / (MIDDLE_RIDGE_FADE*2)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 0
&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;&#9;mountainMask[x] = {}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(z / GenerateOptions.length)
&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;&#9;&#9;local radius = ceil(MIDDLE_RIDGE_RADIUS + MIDDLE_RIDGE_VARIANCE*RidgeWidthMap[z][1])
&#9;&#9;&#9;&#9;&#9;local center = floor(GenerateOptions.width/2)
&#9;&#9;&#9;&#9;&#9;--lead up to 
&#9;&#9;&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;&#9;&#9;local distToCenter = abs(center-x)
&#9;&#9;&#9;&#9;&#9;&#9;if distToCenter &lt; radius - MIDDLE_RIDGE_FADE then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 1
&#9;&#9;&#9;&#9;&#9;&#9;elseif distToCenter &lt; radius + MIDDLE_RIDGE_FADE then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;((radius+MIDDLE_RIDGE_FADE)-distToCenter) / (MIDDLE_RIDGE_FADE*2)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 0
&#9;&#9;&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;elseif GenerateOptions.mountainMode == &quot;Ring&quot; then
&#9;&#9;&#9;-- quite similar to the ridge mode, however, the ridge is around the edge of the terrain
&#9;&#9;&#9;-- rather than running down the middle.
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;mountainMask[x] = {}
&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(x / GenerateOptions.width)
&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;-- we need to find the distance to the nearest edge
&#9;&#9;&#9;&#9;&#9;local distToEdge = min(GenerateOptions.width - MIDDLE_RIDGE_RADIUS - RingWidthMap[GenerateOptions.width][z]*MIDDLE_RIDGE_VARIANCE - x,
&#9;&#9;&#9;&#9;&#9;&#9; x - MIDDLE_RIDGE_RADIUS - RingWidthMap[1][z]*MIDDLE_RIDGE_VARIANCE,
&#9;&#9;&#9;&#9;&#9;&#9; GenerateOptions.length - MIDDLE_RIDGE_RADIUS - RingWidthMap[x][GenerateOptions.length]*MIDDLE_RIDGE_VARIANCE - z,
&#9;&#9;&#9;&#9;&#9;&#9; z - MIDDLE_RIDGE_RADIUS - RingWidthMap[x][1]*MIDDLE_RIDGE_VARIANCE)
&#9;&#9;&#9;&#9;&#9;if distToEdge &gt; MIDDLE_RIDGE_FADE then
&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 0
&#9;&#9;&#9;&#9;&#9;elseif distToEdge &gt; 0 then
&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 1 - (distToEdge / MIDDLE_RIDGE_FADE)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;elseif GenerateOptions.mountainMode == &quot;Whole Map&quot; then
&#9;&#9;&#9;-- whole map mode, mountains make up the whole map
&#9;&#9;&#9;-- just fill the mask with 1s
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;mountainMask[x] = {}
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;
&#9;
&#9;&#9;elseif GenerateOptions.mountainMode == &quot;Random&quot; then
&#9;&#9;&#9;-- random mode, place mountains randomly around the map
&#9;&#9;&#9;-- the mask is just a perlin noise map
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = (mountainMask[x][z]*2 - 1)^3 / 2 + 0.5
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;elseif GenerateOptions.mountainMode == &quot;Interactive&quot; then
&#9;&#9;&#9;-- interactive mode: TODO user fills in exactly where they want mountains.
&#9;&#9;&#9;--local xc = x-floor(GenerateOptions.width/2) + GenerateOptions.xpos
&#9;&#9;&#9;--local zc = z-floor(GenerateOptions.length/2) + GenerateOptions.zpos
&#9;&#9;&#9;local minx, minz = -floor(GenerateOptions.width/2) + GenerateOptions.xpos, -floor(GenerateOptions.length/2) + GenerateOptions.zpos
&#9;&#9;&#9;local maxx, maxz = floor(GenerateOptions.width/2) + GenerateOptions.xpos, floor(GenerateOptions.length/2) + GenerateOptions.zpos
&#9;
&#9;&#9;&#9;-- draw the canvas for the user to draw on
&#9;&#9;&#9;--local region = Region3int16.new(Vector3int16.new(minx, 0, minz), Vector3int16.new(maxx, 0, maxz))
&#9;&#9;&#9;local region = Region3.new(Vector3.new(minx, -4, minz)*4, Vector3.new(maxx, 0, maxz)*4)
&#9;&#9;&#9;terrain:FillRegion(region, 4, Enum.Material.Sand)
&#9;
&#9;&#9;&#9;-- events to handle the tool being otherwise used or progress being cancelled
&#9;&#9;&#9;local orEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;&#9;&#9;local deactivatingC = deactivatingEvent.Event:connect(function() orEvent:Fire({Type = &quot;Deactivated&quot;}) end)
&#9;&#9;&#9;local cancelC = CancelValues.bindForCancel.Event:connect(function() orEvent:Fire({Type = &quot;Canceled&quot;}) end)
&#9;
&#9;&#9;&#9;-- activate the plugin temporarily to get the mouse
&#9;&#9;&#9;--plugin:Activate(true)
&#9;&#9;&#9;--local mouse = plugin:GetMouse()
&#9;
&#9;&#9;&#9;local messageBox = RbxGui.CreateMessageDialog(&quot;Interactive Mode&quot;, &quot;Draw where you want mountains to be located in the level.\n&quot;..
&#9;&#9;&#9;&#9; &quot;Click and drag to draw.\n&quot;..
&#9;&#9;&#9;&#9; &quot;Hold down shift to erase instead.&quot;, 
&#9;&#9;&#9; {{Text = &quot;Done&quot;, Function = function()
&#9;&#9;&#9; &#9;orEvent:Fire({Type = &quot;ClickDone&quot;})
&#9;&#9;&#9; end}})
&#9;&#9;&#9;messageBox.Parent = MainScreenGui
&#9;&#9;&#9;messageBox:TweenSizeAndPosition(UDim2.new(0, 320, 0, 170), UDim2.new(0, 10, 0, 10), &apos;Out&apos;, &apos;Quad&apos;, 2)
&#9;
&#9;&#9;&#9;-- initialize the terrain map
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;mountainMask[x] = {}
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;-- set up the mouse
&#9;&#9;&#9;local mouseDown = false
&#9;&#9;&#9;local shiftHeld = false
&#9;&#9;&#9;local function doPaint()
&#9;&#9;&#9;&#9;if mouse.Target and mouse.Target:IsA(&apos;Terrain&apos;) then
&#9;&#9;&#9;&#9;&#9;local cell = mouse.Target:WorldToCellPreferSolid(mouse.Hit.p)
&#9;
&#9;&#9;&#9;&#9;&#9;-- do a paint. Note: We paint into the mountain mask with true/false rather than 0/1 in order
&#9;&#9;&#9;&#9;&#9;-- to make the AA algorithm that we apply to the results faster.
&#9;&#9;&#9;&#9;&#9;for dx = -10, 10 do
&#9;&#9;&#9;&#9;&#9;&#9;for dz = -10, 10 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local x, z = cell.x + dx, cell.z + dz
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local datax, dataz = x - minx + 1, z - minz + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if x &gt;= minx and x &lt;= maxx and z &gt;= minz and z &lt;= maxz and dx*dx + dz*dz &lt; 10*10 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if shiftHeld then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--terrain:SetCell(x, 0, z, 5, 0, 0) -- asphalt
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;terrain:FillRegion(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Region3.new(Vector3.new(x*4, -4, z*4), Vector3.new((x+1)*4, 0, (z+1)*4)),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;4,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.Material.Sand)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[datax][dataz] = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--terrain:SetCell(x, 0, z, 16, 0, 0) --blue plastic
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;terrain:FillRegion(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Region3.new(Vector3.new(x*4, -4, z*4), Vector3.new((x+1)*4, 0, (z+1)*4)),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;4,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.Material.Slate)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[datax][dataz] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;local mouseC1 = mouse.Button1Down:connect(function()
&#9;&#9;&#9;&#9;mouseDown = true
&#9;&#9;&#9;&#9;doPaint()
&#9;&#9;&#9;end)
&#9;&#9;&#9;local mouseC2 = mouse.Button1Up:connect(function()
&#9;&#9;&#9;&#9;mouseDown = false
&#9;&#9;&#9;end)
&#9;&#9;&#9;local mouseC3 = mouse.Move:connect(function()
&#9;&#9;&#9;&#9;if mouseDown then
&#9;&#9;&#9;&#9;&#9;doPaint()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;local mouseC4 = mouse.KeyDown:connect(function(key)
&#9;&#9;&#9;&#9;if string.byte(key) == 48 then -- shift key = 48, for both right and left shift
&#9;&#9;&#9;&#9;&#9;shiftHeld = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;local mouseC5 = mouse.KeyUp:connect(function(key)
&#9;&#9;&#9;&#9;if string.byte(key) == 48 then -- shift key = 48, for both right and left shift
&#9;&#9;&#9;&#9;&#9;shiftHeld = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;
&#9;&#9;&#9;-- wait for the user to be done
&#9;&#9;&#9;local hresult = orEvent.Event:wait()
&#9;
&#9;&#9;&#9;-- disconnect all of the events that we made
&#9;&#9;&#9;deactivatingC:disconnect()
&#9;&#9;&#9;cancelC:disconnect()
&#9;&#9;&#9;mouseC1:disconnect()
&#9;&#9;&#9;mouseC2:disconnect()
&#9;&#9;&#9;mouseC3:disconnect()
&#9;&#9;&#9;mouseC4:disconnect()
&#9;&#9;&#9;mouseC5:disconnect()
&#9;
&#9;&#9;&#9;-- kill the message box
&#9;&#9;&#9;messageBox:Destroy()
&#9;
&#9;&#9;&#9;-- get rid of the canvas
&#9;&#9;&#9;terrain:FillRegion(region, 4, Enum.Material.Air)
&#9;
&#9;&#9;&#9;-- depending on why they are done, do stuff
&#9;&#9;&#9;local AA_SIZE = 8
&#9;&#9;&#9;if hresult.Type == &quot;ClickDone&quot; then
&#9;&#9;&#9;&#9;local newMask = {}
&#9;
&#9;&#9;&#9;&#9;UpdateGenerationProgressMessage(&quot;Antialiasing selection&quot;)
&#9;
&#9;&#9;&#9;&#9;-- cache some stuff into locals for a faster runtime
&#9;&#9;&#9;&#9;local _w, _l = GenerateOptions.width, GenerateOptions.length
&#9;
&#9;&#9;&#9;&#9;-- generate a bucket map so that we can easily find what areas need to be anti-aliased
&#9;&#9;&#9;&#9;local bucketMap = {} -- [][] = 0 =&gt; ground, 1 =&gt; mountain, 2 =&gt; both
&#9;&#9;&#9;&#9;local bwidth = ceil(_w/AA_SIZE)
&#9;&#9;&#9;&#9;local blength = ceil(_l/AA_SIZE)
&#9;&#9;&#9;&#9;for bx = 1, bwidth do
&#9;&#9;&#9;&#9;&#9;bucketMap[bx] = {}
&#9;&#9;&#9;&#9;&#9;for bz = 1, blength do
&#9;&#9;&#9;&#9;&#9;&#9;bucketMap[bx][bz] = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;for bx = 1, bwidth do
&#9;&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(bx / bwidth * 0.5)
&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;for bz = 1, blength do
&#9;&#9;&#9;&#9;&#9;&#9;local foundMountain = false
&#9;&#9;&#9;&#9;&#9;&#9;local foundGround = false
&#9;&#9;&#9;&#9;&#9;&#9;for x = (bx-1)*AA_SIZE + 1, min(bx*AA_SIZE, _w) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for z = (bz-1)*AA_SIZE + 1, min(bz*AA_SIZE, _l) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if mountainMask[x][z] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;foundMountain = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;foundGround = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if foundGround and foundMountain then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- this and all adjancent buckets need anti aliasing
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for dx = -1, 1 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for dz = -1, 1 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local xc, zc = bx+dx, bz+dz
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if xc &gt; 0 and zc &gt; 0 and xc &lt;= bwidth and zc &lt;= blength then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;bucketMap[xc][zc] = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;for x = 1, _w do
&#9;&#9;&#9;&#9;&#9;newMask[x] = {}
&#9;&#9;&#9;&#9;&#9;for z = 1, _l do
&#9;&#9;&#9;&#9;&#9;&#9;newMask[x][z] = mountainMask[x][z] and 1 or 0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;-- now, for each bucket, if it needs AA, then we AA all of the cells within it
&#9;&#9;&#9;&#9;for bx = 1, bwidth do
&#9;&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(bx / bwidth * 0.5 + 0.5)
&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;for bz = 1, blength do
&#9;&#9;&#9;&#9;&#9;&#9;if bucketMap[bx][bz] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for x = (bx-1)*AA_SIZE + 1, min(bx*AA_SIZE, GenerateOptions.width) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for z = (bz-1)*AA_SIZE + 1, min(bz*AA_SIZE, GenerateOptions.length) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local count, total = 0, 0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for dx = -AA_SIZE,AA_SIZE do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for dz = -AA_SIZE,AA_SIZE do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local xc, zc = x + dx, z + dz
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if xc &lt;= _w and xc &gt; 0 and zc &gt; 0 and zc &lt;= _l then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;total = total + (mountainMask[xc][zc] and 1 or 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;count = count + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;newMask[x][z] = total / count&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;
&#9;
&#9;&#9;&#9;&#9;mountainMask = newMask
&#9;
&#9;&#9;&#9;elseif hresult.Type == &quot;Deactivated&quot; or hresult.Type == &quot;Canceled&quot; then
&#9;&#9;&#9;&#9;-- return an empty mask
&#9;&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;&#9;mountainMask[x][z] = 0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;return mountainMask, SteepMountains
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;--now, using the mountainMap weighted average between the mountain values and the base values
&#9;&#9;--once we&apos;ve done that we have to scale them up to make maximum usage of our available vertical
&#9;&#9;--space. The highest peok should be at exactly y=amplitude specified by the user
&#9;&#9;--We reuse the SteepMountains array as a place to write the results out to before we do a
&#9;&#9;--seoond round scaling them up.
&#9;&#9;local maxValue = 0
&#9;&#9;local minValue = huge
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;local steepFrac = SwitchMap[x][z]
&#9;&#9;&#9;&#9;local shallowFrac = 1-steepFrac
&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;local mountainHeight = steepFrac *sin4_smallbias_curve(SteepMountains[x][z])
&#9;&#9;&#9;&#9; + shallowFrac*ShallowMountains[x][z]
&#9;&#9;&#9;&#9;if mountainHeight &gt; maxValue then maxValue = mountainHeight end
&#9;&#9;&#9;&#9;if mountainHeight &lt; minValue then minValue = mountainHeight end
&#9;&#9;&#9;&#9;SteepMountains[x][z] = mountainHeight
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;local usedFrac = (maxValue-minValue) / (GenerateOptions.mountainHeight-GenerateOptions.baseHeight) --1 less or else we get cut off without doing an extra floor()
&#9;
&#9;&#9;--now, scale and add the mountain layer to the baseLayer. We can do both of these steps in the
&#9;&#9;--same loop. This time we will re-use the SteepMountain layer as the total scaled mountain layer
&#9;&#9;--to.
&#9;&#9;--here we apply the mountain frequency option from the options.
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;for z = 1, GenerateOptions.length do 
&#9;&#9;&#9;&#9;local mountainLayer = GenerateOptions.baseHeight + (SteepMountains[x][z]-minValue)*(1/usedFrac)
&#9;&#9;&#9;&#9;mountainLayer = 
&#9;&#9;&#9;&#9;&#9;mountainLayer 
&#9;&#9;&#9;&#9;&#9;- 6*MountainDetailB[x][z]
&#9;&#9;&#9;&#9;&#9;+ 5*MountainDetailC[x][z]
&#9;&#9;&#9;&#9;local highDetailShow = MountainHighDetailShow[x][z] 
&#9;&#9;&#9;&#9;local highDetailFrac;
&#9;&#9;&#9;&#9;if highDetailShow &gt; 0.25 and highDetailShow &lt; 0.75 then
&#9;&#9;&#9;&#9;&#9;highDetailFrac = 1
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;highDetailFrac = (abs(highDetailShow - 0.5)-0.25) / 0.25
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;mountainLayer = mountainLayer + highDetailFrac*4*MountainDetailA[x][z]
&#9;&#9;&#9;&#9;SteepMountains[x][z] = mountainLayer
&#9;&#9;&#9;&#9;local mask = mountainMask[x][z]*GenerateOptions.mountainFrequency -- TODO: What&apos;s the problem here??
&#9;&#9;&#9;&#9;baseLayer[x][z] = (1-mask)*baseLayer[x][z]
&#9;&#9;&#9;&#9; +( mask)*mountainLayer
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;--return the values
&#9;&#9;return mountainMask, SteepMountains
&#9;end
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- There may be some holes left over, fill them.
&#9;-- Any areas which are &lt;= 0 in the base layer we&apos;re building are holes, and should be changed to
&#9;-- a value of 1
&#9;------------------------------------------------------------------------------------------------------
&#9;local function FillHoles(baseLayer)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Filling Holes&quot;)
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;CancelValues.setAmountFunc(x / GenerateOptions.width)
&#9;&#9;&#9;pause()
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;if baseLayer[x][z] &lt; 2 then
&#9;&#9;&#9;&#9;&#9;baseLayer[x][z] = 2
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Next we draw lakes into the map.
&#9;-- The lake drawing process finds local minima in the map, and then flood-fills them to as
&#9;-- high a level as it can without the flood-fill spilling into a very large area. This seems
&#9;-- inefficient but it actually does not take that much time to fill a reasonable number of local
&#9;-- minima using this approach.
&#9;-- We need to take the base mask as a parameter so that we ensure the lake fills do not spill into
&#9;-- the areas reserved for the bases.
&#9;--
&#9;-- Returns: A mask of where water was placed
&#9;------------------------------------------------------------------------------------------------------
&#9;local Directions = {{1,0,1}, {-1,0,1}, {0,1,1}, {0,-1,1},
&#9;{-1,-1,sqrt(2)}, {-1,1,sqrt(2)}, {1,-1,sqrt(2)}, {1,1,sqrt(2)}}
&#9;local function PlaceLakes(baseLayer)
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Filling Lakes&quot;)
&#9;&#9;wait()
&#9;&#9;
&#9;&#9;local depth = 0
&#9;&#9;if GenerateOptions.waterMode == &quot;Ocean&quot; or GenerateOptions.waterMode == &quot;Both&quot; then
&#9;&#9;&#9;local depth = GenerateOptions.sealevel
&#9;&#9;end
&#9;&#9;
&#9;&#9;--first generate the water mask
&#9;&#9;local waterMask = {}
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;waterMask[x] = {}
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;waterMask[x][z] = depth
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;-- generate lakes
&#9;&#9;if GenerateOptions.waterMode == &quot;Lakes&quot; or GenerateOptions.waterMode == &quot;Both&quot; then
&#9;&#9;&#9;--generate a certain density of lakes
&#9;&#9;&#9;local total = GenerateOptions.width * GenerateOptions.length * GenerateOptions.lakesPerSquare
&#9;&#9;&#9;for i = 1, total do
&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(i/total)
&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;
&#9;&#9;&#9;&#9;--select a random position
&#9;&#9;&#9;&#9;local x,z = random(1,GenerateOptions.width), random(1,GenerateOptions.length)
&#9;
&#9;&#9;&#9;&#9;--now, we need to find the local minimum nearest to this position
&#9;&#9;&#9;&#9;while true do
&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;--see if we will drop down in any of the directions
&#9;&#9;&#9;&#9;&#9;local leastDir, leastChange = nil,100
&#9;&#9;&#9;&#9;&#9;local h = baseLayer[x][z]
&#9;&#9;&#9;&#9;&#9;for _, dir in pairs(Directions) do 
&#9;&#9;&#9;&#9;&#9;&#9;local nx,nz = x+dir[1],z+dir[2]
&#9;&#9;&#9;&#9;&#9;&#9;if InBound(nx,nz) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local hn = baseLayer[nx][nz]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if hn &lt; h and abs(hn-h) &lt; leastChange then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;leastDir = dir
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;leastChange = abs(hn-h)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if not leastDir then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;x = x + leastDir[1]
&#9;&#9;&#9;&#9;&#9;z = z + leastDir[2]
&#9;&#9;&#9;&#9;&#9;if leastChange == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;--(x,z) is now the local min nearest the random location. If there is not already a
&#9;&#9;&#9;&#9;--water-feature there then try to generate one.
&#9;&#9;&#9;&#9;if waterMask[x][z] == 0 then
&#9;&#9;&#9;&#9;&#9;--now, in order to get the deepest possible lake, we try to generate one at sereval
&#9;&#9;&#9;&#9;&#9;--heights, starting with the deepest. Doing anywhere from 1 deep to 3 deep works nicely.
&#9;&#9;&#9;&#9;&#9;for y = floor(baseLayer[x][z])+5, floor(baseLayer[x][z])+1, -1 do
&#9;&#9;&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;&#9;&#9;--we need to make a temporary map to store this attpmt&apos;s changes in, rather than
&#9;&#9;&#9;&#9;&#9;&#9;--just applying them right to the water mask.
&#9;&#9;&#9;&#9;&#9;&#9;local tmpWaterMask = {}
&#9;&#9;&#9;&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;tmpWaterMask[x] = {}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tmpWaterMask[x][z] = waterMask[x][z]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;&#9;&#9;--now do a flood-fill
&#9;&#9;&#9;&#9;&#9;&#9;local filledCount = 0
&#9;&#9;&#9;&#9;&#9;&#9;local function FloodFill(x,z)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not InBound(x,z) then return true end
&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if tmpWaterMask[x][z] == 0 or y &gt; tmpWaterMask[x][z] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if y &gt; floor(baseLayer[x][z]) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--place water here
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tmpWaterMask[x][z] = y
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;filledCount = filledCount+1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if filledCount &gt; GenerateOptions.lakeMaxSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--bail out early, don&apos;t flood bases
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not FloodFill(x-1,z ) then return false end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not FloodFill(x+1,z ) then return false end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not FloodFill(x ,z-1) then return false end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not FloodFill(x ,z+1) then return false end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--flag as tested
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tmpWaterMask[x][z] = -1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if FloodFill(x,z) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--we found a good lake, now add it to the waterMask (we can do this with just
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--assignment because we were editing a copy of the old water mask)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;waterMask = tmpWaterMask
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;--and return the waterMask
&#9;&#9;return waterMask
&#9;end
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Now that the heightmap is fully constructed, coloring.
&#9;-- All of the coloring is done as post-process using only various hightmaps from previous phases. The
&#9;-- advantage of this is that it is easy to change the look and feel of the map when adding new
&#9;-- features, as opposed to if a persistent coloring state were maintained as the heigh-map is
&#9;-- build up, where you would have to worry about ovecdraw from following phases.
&#9;-- It also turns out to be faster to do it this way. It is qutie tricky to decide how to color in
&#9;-- phases based on what previous and furture phases do, as opposed to in a single coloring pass here.
&#9;--
&#9;-- Returns: A map of CellMaterial codes, or special color codes, that can be used in drawing out the
&#9;-- heightmap to the terrain.
&#9;------------------------------------------------------------------------------------------------------
&#9;local function ColorMap(baseLayer, mountainMask, mountainMap, waterMask)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Coloring Map&quot;)
&#9;&#9;--first, make a map that we will use to decide where to put sand, and where to put grass
&#9;&#9;--the map to write the colors out to
&#9;&#9;local ColorMap = {}
&#9;
&#9;&#9;--now, we do a single pass over every square in the map, and color it
&#9;&#9;if GenerateOptions.colorMode == &quot;Auto Color&quot; then
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(x / GenerateOptions.width)
&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;&#9;ColorMap[x] = {}
&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;--first, weneed to find all the heights of all of the nearby squares, so we can calculate
&#9;&#9;&#9;&#9;&#9;--both an average height at this location, and a total variance at this location.
&#9;&#9;&#9;&#9;&#9;local _1,_2,_3,_4,_5,_6,_7,_8,_9 =
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x+1,z+1),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x+1,z ),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x+1,z-1),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x ,z+1),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x ,z ),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x ,z-1),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x-1,z+1),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x-1,z ),
&#9;&#9;&#9;&#9;&#9;&#9;at(baseLayer,x-1,z-1)
&#9;&#9;&#9;&#9;&#9;local h = _5
&#9;&#9;&#9;&#9;&#9;local avr = (_1+_2+_3+_4+_5+_6+_7+_8+_9)/9
&#9;&#9;&#9;&#9;&#9;local tot = (abs(_1-avr) + abs(_2-avr) + abs(_3-avr) + 
&#9;&#9;&#9;&#9;&#9; abs(_4-avr) + abs(_5-avr) + abs(_6-avr) + 
&#9;&#9;&#9;&#9;&#9; abs(_7-avr) + abs(_8-avr) + abs(_9-avr))
&#9;&#9;&#9;&#9;&#9;local waterLevel = waterMask[x][z]
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;if waterLevel &gt; _5 then
&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Sand
&#9;&#9;&#9;&#9;&#9;&#9;baseLayer[x][z] = math.min(baseLayer[x][z] + tot/8, waterLevel - 1)
&#9;&#9;&#9;&#9;&#9;elseif abs(h-avr) &gt; 1 and GenerateOptions.colorCliffs then
&#9;&#9;&#9;&#9;&#9;&#9;--~~if the average is far from the height then we are in a sharp slope region. We give
&#9;&#9;&#9;&#9;&#9;&#9;--these areas a special color code so that where they are drawn they will not just
&#9;&#9;&#9;&#9;&#9;&#9;--be single color columns like the rest, which would lead to vertical striping~~
&#9;&#9;&#9;&#9;&#9;&#9;-- **REMOVED**, disabled until smooth terrain gets more materials to work with
&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Slate
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;local mountainHeight = mountainMask[x][z]*mountainMap[x][z]*GenerateOptions.mountainFrequency
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if tot &gt; 5 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--we are in a steep area in the mountains, but not a really steep area
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--reuse the sandy map for a bit of variation in the mountain material
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if GenerateOptions.colorMountains then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Slate
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Grass
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;elseif mountainHeight &gt; 30 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--it&apos;s both not steep, and high in the mountains. These areas are snow-covered
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--peaks, color them snowey
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if GenerateOptions.snowtoppedMountains then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Concrete -- todo: Should be snowey once material arrives
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if GenerateOptions.colorMountains then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Slate
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Grass
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--it&apos;s a smooth area. Decide whether to place sand or grass. Sand should only be
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--placed in concave areas which are not in the mountains:
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--        (not in mountains)             (concave)     (not too high either)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--if (sandy*(1-mountainMask[x][z])&gt;1.5) and (h&lt;=avr) and (baseLayer[x][z] &lt; 15) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--&#9;ColorMap[x][z] = Enum.Material.Sand --sand
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Grass --grass
&#9;&#9;&#9;&#9;&#9;&#9;&#9;--end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;-- If the color would be grass, apply flecks
&#9;&#9;&#9;&#9;&#9;if ColorMap[x][z] == Enum.Material.Grass or ColorMap[x][z] == Enum.Material.Sand then
&#9;&#9;&#9;&#9;&#9;&#9;local flecks = 0.4*FlecksMapA[x][z] + 0.3*FlecksMapB[x][z] + 0.3*FlecksMapC[x][z]
&#9;&#9;&#9;&#9;&#9;&#9;if flecks &lt; math.random()*0.55 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Slate
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;elseif GenerateOptions.colorMode == &quot;Solid Color&quot; then
&#9;&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;&#9;ColorMap[x] = {}
&#9;&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;&#9;ColorMap[x][z] = Enum.Material.Grass
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;end
&#9;
&#9;&#9;--done, return the color map
&#9;&#9;return ColorMap
&#9;end
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Finally we draw trees to the surface.
&#9;-- We generate a noise treemap, and then trees are placed:
&#9;-- In grassy areas
&#9;-- Which are not covered in water
&#9;------------------------------------------------------------------------------------------------------
&#9;local function DrawTrees(baseLayer, waterMask, colormap)
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Generating Trees&quot;)
&#9;&#9;wait()
&#9;&#9;
&#9;&#9;-- if the is no vegetation, then stop right away
&#9;&#9;if not GenerateOptions.vegetationMode then return end
&#9;&#9;
&#9;&#9;local treeMap = {}
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;treeMap[x] = {}
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;treeMap[x][z] = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function DoNext(x, z, w)
&#9;&#9;&#9;if treeMap[x] and treeMap[x][z] then
&#9;&#9;&#9;&#9;if treeMap[x][z] == 0 then
&#9;&#9;&#9;&#9;&#9;treeMap[x][z] = w
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;local Total = GenerateOptions.width * GenerateOptions.length * GenerateOptions.vegetationDensity
&#9;&#9;for i = 1, Total do
&#9;&#9;&#9;CancelValues.setAmountFunc(i / Total)
&#9;&#9;&#9;pause()
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;local x,z = random(4,GenerateOptions.width-4),random(4,GenerateOptions.length-4)
&#9;&#9;&#9;local treeDensity = TreeMapA[x][z] + TreeMapB[x][z]
&#9;&#9;&#9;
&#9;&#9;&#9;if treeDensity &gt; 1.1 and colormap[x][z] == Enum.Material.Grass and waterMask[x][z] &lt;= 0 then
&#9;&#9;&#9;&#9;treeMap[x][z] = 1
&#9;&#9;&#9;&#9;DoNext(x - 1, z, 0.5)
&#9;&#9;&#9;&#9;DoNext(x + 1, z, 0.5)
&#9;&#9;&#9;&#9;DoNext(x, z - 1, 0.5)
&#9;&#9;&#9;&#9;DoNext(x, z + 1, 0.5)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return treeMap
&#9;end
&#9;
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- Now, we actually draw out the level to the Terrain instance.
&#9;------------------------------------------------------------------------------------------------------
&#9;local function DrawTerrain(baseLayer, colormap, waterMask, treeMap)
&#9;&#9;CancelValues.setAmountFunc(0)
&#9;&#9;UpdateGenerationProgressMessage(&quot;Drawing Terrain&quot;)
&#9;&#9;
&#9;&#9;local width = GenerateOptions.width
&#9;&#9;local length = GenerateOptions.length
&#9;&#9;local xbase = -floor(width/2) + GenerateOptions.xpos
&#9;&#9;local zbase = -floor(length/2) + GenerateOptions.zpos
&#9;&#9;
&#9;&#9;local globalMaxHeight = 0
&#9;&#9;for x = 1, GenerateOptions.width do
&#9;&#9;&#9;for z = 1, GenerateOptions.length do
&#9;&#9;&#9;&#9;globalMaxHeight = max(globalMaxHeight, ceil(baseLayer[x][z]))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;&#9;local CHUNK_SIZE = 32
&#9;&#9;local chunkCount = ceil(width / CHUNK_SIZE)
&#9;&#9;
&#9;&#9;for chunkNum = 1, chunkCount do
&#9;&#9;&#9;local fullAmount = chunkNum/chunkCount
&#9;&#9;&#9;local nextAmount = (chunkNum + 1)/chunkCount
&#9;&#9;&#9;local difAmount = nextAmount - fullAmount
&#9;&#9;&#9;CancelValues.setAmountFunc(fullAmount)
&#9;&#9;&#9;if CancelValues.cancelActions then return end
&#9;&#9;&#9;pause()
&#9;&#9;&#9;
&#9;&#9;&#9;if chunkNum == chunkCount then
&#9;&#9;&#9;&#9;CHUNK_SIZE = width - (chunkCount-1) * CHUNK_SIZE
&#9;&#9;&#9;end
&#9;&#9;&#9;-- Calculate the chunk data
&#9;&#9;&#9;local chunkMaterials = {}
&#9;&#9;&#9;local chunkOccupancies = {}
&#9;&#9;&#9;for x = 1, CHUNK_SIZE do
&#9;&#9;&#9;&#9;pause()
&#9;&#9;&#9;&#9;CancelValues.setAmountFunc(fullAmount + difAmount * (x/CHUNK_SIZE))
&#9;&#9;&#9;&#9;chunkMaterials[x] = {}
&#9;&#9;&#9;&#9;chunkOccupancies[x] = {}
&#9;&#9;&#9;&#9;for z = 1, length do
&#9;&#9;&#9;&#9;&#9;local truex = x + (chunkNum - 1) * CHUNK_SIZE
&#9;&#9;&#9;&#9;&#9;local color = colormap[truex][z]
&#9;&#9;&#9;&#9;&#9;local waterLevel = waterMask[truex][z]
&#9;&#9;&#9;&#9;&#9;local tree = treeMap[truex][z]
&#9;&#9;&#9;&#9;&#9;local truey = baseLayer[truex][z]
&#9;&#9;&#9;&#9;&#9;local y = ceil(truey)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;for yc = 1, globalMaxHeight do
&#9;&#9;&#9;&#9;&#9;&#9;if not chunkOccupancies[x][yc] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc] = {}
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if not chunkMaterials[x][yc] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc] = {}
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if yc &lt;= y then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (y - yc) &lt; GenerateOptions.soilDepth then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = color
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Slate
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;elseif yc &lt;= waterLevel then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Water
&#9;&#9;&#9;&#9;&#9;&#9;elseif tree &gt; 0 and yc &lt;= y + 8 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if tree == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if yc &lt;= y + 5 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = random(4, 10)/10
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.WoodPlanks
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 0.5
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Brick
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if yc &gt;= y + 4 and yc &lt;= y + 7 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 0.2
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Brick
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Air
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][yc][z] = 0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;chunkMaterials[x][yc][z] = Enum.Material.Air
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;chunkOccupancies[x][y][z] = 1 - (y - truey)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- Calculate the chunk region
&#9;&#9;&#9;local chunkRegion = Region3.new(
&#9;&#9;&#9;&#9;Vector3.new(xbase + (chunkNum - 1) * CHUNK_SIZE, 0, zbase) * 4,
&#9;&#9;&#9;&#9;Vector3.new(xbase + chunkNum * CHUNK_SIZE, globalMaxHeight, zbase + length) * 4
&#9;&#9;&#9;)
&#9;
&#9;&#9;&#9;-- Draw the chunk
&#9;&#9;&#9;terrain:WriteVoxels(chunkRegion, 4, chunkMaterials, chunkOccupancies)
&#9;&#9;end
&#9;end
&#9;
&#9;------------------------------------------------------------------------------------------------------
&#9;-- And finally call on all of the generation code
&#9;------------------------------------------------------------------------------------------------------
&#9;UpdateGenerationProgressMessage(&quot;Generating Terrain&quot;)
&#9;wait(0.3)
&#9;local function DoTask(Function, ...)
&#9;&#9;local resulta, resultb, resultc = Function(...)
&#9;&#9;if CancelValues.cancelActions then On(); return UnloadProgressBar() end
&#9;&#9;wait(0.3)
&#9;&#9;return resulta, resultb, resultc
&#9;end
&#9;
&#9;do
&#9;&#9;DoTask(GeneratePerlinMaps)
&#9;&#9;DoTask(ClearTerrain)
&#9;&#9;local baseLayer = DoTask(MakeBaseLayer)
&#9;&#9;DoTask(ApplyCliffs, baseLayer)
&#9;&#9;local mountainMask, mountainMap = DoTask(ApplyMountains, baseLayer)
&#9;&#9;DoTask(FillHoles, baseLayer)
&#9;&#9;local waterMask = DoTask(PlaceLakes, baseLayer)
&#9;&#9;local colormap = DoTask(ColorMap, baseLayer, mountainMask, mountainMap, waterMask)
&#9;&#9;local treeMap = DoTask(DrawTrees, baseLayer, waterMask, colormap)
&#9;&#9;DoTask(DrawTerrain, baseLayer, colormap, waterMask, treeMap)
&#9;end
&#9;UpdateGenerationProgressMessage(&quot;Finishing Generation&quot;)
&#9;wait(0.3)

&#9;-- Clean up the progress bar.
&#9;UnloadProgressBar()

&#9;--Turn on the plugin again
&#9;On()
end

-- Clears all terrain.
function ClearTerrain()
&#9;-- toolbarbutton:SetActive(false)
&#9;Off()
&#9;
&#9;--Erase Terrain
&#9;terrain:Clear()
&#9;
&#9;--Erase Terrain End
&#9;UnloadProgressBar()
end


--==========================================================================================================--
-- Main Plugin GUI Setup ==--
--==========================================================================================================--

--screengui
MainScreenGui = Instance.new(&quot;ScreenGui&quot;, game.Players.LocalPlayer.PlayerGui)
MainScreenGui.Name = &apos;TerrainCreatorGui&apos;

-- Gui frame for the plugin.
local terrainPropertiesDragBar, terrainFrame, terrainHelpFrame, terrainCloseEvent = RbxGui.CreatePluginFrame(&quot;Terrain Generator&quot;,UDim2.new(0,186,0,487),UDim2.new(0,0,0,0),false,MainScreenGui)
terrainPropertiesDragBar.Visible = false
terrainCloseEvent.Event:connect(function()
&#9;Off()
end)

terrainHelpFrame.Size = UDim2.new(0,300,0,539)

-- Create the help text:

local terrainHelpText = Instance.new(&quot;TextLabel&quot;,terrainHelpFrame)
terrainHelpText.Name = &quot;HelpText&quot;
terrainHelpText.Font = Enum.Font.ArialBold
terrainHelpText.FontSize = Enum.FontSize.Size12
terrainHelpText.TextColor3 = Color3.new(227/255,227/255,227/255)
terrainHelpText.TextXAlignment = Enum.TextXAlignment.Left
terrainHelpText.TextYAlignment = Enum.TextYAlignment.Top
terrainHelpText.Position = UDim2.new(0,4,0,4)
terrainHelpText.Size = UDim2.new(1,-8,0,132)
terrainHelpText.BackgroundTransparency = 1
terrainHelpText.TextWrap = true
terrainHelpText.Text = [[ &lt;&gt; Generate Terrain &lt;&gt;
================= Basic Options =================
 - Width: Terrain size in the X direction.
 - Length: Terrain size in the Z direction.
 - Base Height: The lowest point that will be present in
 the terrain.
================== Hill Options =================
 - Hill Density: A smaller value gives fewer, smoother 
 hills, while a larger value gives more sharp 
 frequent hills.
 - Enable Cliffs: If enabled, cliffs will be sliced into
]]

local helpSecondText = terrainHelpText:clone()
helpSecondText.Name = &quot;HelpSecondText&quot;
helpSecondText.Position = UDim2.new(0,0,1,0)
helpSecondText.Size = UDim2.new(1,0,0,157)
helpSecondText.Text = [[ random locations on the map.
 - Cliff Density: If cliffs are enabled, the larger the
 value the more cliffs will be added to the map.
================ Mountain Options ==============
 - Region Dropdown: Mountains can be placed in one 
 of several different regions around the map, or 
 placed in a custom region of your choice by using 
 the &quot;Interactive&quot; mode.
 - Max Mountain Height: The maximum elevation that
 mountains placed in the region will reach.
 - Mountainous %: How mountainous is the chosen 
 region? 100% = place only mountains there,
 0% = place only hills there.
]]
helpSecondText.Parent = terrainHelpText

local helpThirdText = helpSecondText:clone()
helpThirdText.Name = &quot;HelpThirdText&quot;
helpThirdText.Position = UDim2.new(0,0,1,0)
helpThirdText.Size = UDim2.new(1,0,0,157)
helpThirdText.Text = [[ - Mountain Size: How wide are the mountains to be, 
 in terms of the width of the whole map?
================== Water Options ===============
 - Water Dropdown: A sea level can be chosen to fill
 the whole level to, or lakes can be placed around
 the level, or both.
 - Lake Density: How many lakes to place in the level?
 - Lake max size: How large should the lakes be?
 - Sea level: What water-level to fill the level up to?
================ Material Options ===============
 - Material Dropdown: Select to either color the level
 one solid color, or automatically color it based on 
 the landscape and some settings.
]]
helpThirdText.Parent = helpSecondText

local helpFourthText = helpThirdText:clone()
helpFourthText.Name = &quot;HelpFourthText&quot;
helpFourthText.Position = UDim2.new(0,0,1,0)
helpFourthText.Size = UDim2.new(1,0,0,120)
helpFourthText.Text = [[ - Color Mountains: Color steep slopes and high 
 places with a grey color?
 - Snow on Mountaintops: Color the tops of high 
 mountains with a white color?
 - Color Cliffs: Color sharp cliffs with a grey color?
 - Add Sandy Regions: Color some low, flat areas with
 a yellow color?
]]
helpFourthText.Parent = helpThirdText

--==========================================================================================================--
-- Population of the GUI with all the setting controlls ==--
--==========================================================================================================--

-- small utility to easily change the position of GUI elements while still having them
-- relatively positioned.
local curY = 10
local function setY(v) curY = v end
local function addY(v) curY = curY + v end

-- Slider for controlling the width of the terran area. Terran is created in a region this wide.
widthLabel = CreateStandardLabel(&quot;WidthLabel&quot;, UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), &quot;&quot;, terrainFrame)
addY(16)
widthSliderGui, widthSliderPosition = CreateStandardSlider(&apos;WidthSliderGui&apos;, UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), 1024, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(widthSliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.width = widthSliderPosition.Value
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;widthLabel.Text = &quot;Width: &quot;..TerrainOptions.width
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, terrainFrame)
addY(25)
widthSliderPosition.Value = TerrainOptions.width

-- Slider for controlling the length of the terran area. Terran is created in a region this long.
lengthLabel = CreateStandardLabel(&quot;LengthLabel&quot;, UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), &quot;&quot;, terrainFrame)
addY(16)
lengthSliderGui, lengthSliderPosition = CreateStandardSlider(&apos;LengthSliderGui&apos;, UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), 1024, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(lengthSliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.length = lengthSliderPosition.Value
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lengthLabel.Text = &quot;Length: &quot;..TerrainOptions.length
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, terrainFrame)
addY(25)
lengthSliderPosition.Value = TerrainOptions.length


-- Slider for controlling the baseHeight, how deep the base terrain should be.
baseHeightLabel = CreateStandardLabel(&quot;BaseHeightLabel&quot;, UDim2.new(0, 8, 0, curY), UDim2.new(0, 67, 0, 14), &quot;&quot;, terrainFrame)
addY(16)
baseHeightSliderGui, baseHeightSliderPosition = CreateStandardSlider(&apos;BaseHeightSliderGui&apos;, UDim2.new(0,1,0,curY), UDim2.new(0,10,0.5,-2), game.Workspace.Terrain.MaxExtents.Max.Y, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(baseHeightSliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.baseHeight = baseHeightSliderPosition.Value - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;baseHeightLabel.Text = &quot;Base Height: &quot;.. (TerrainOptions.baseHeight)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, terrainFrame)
addY(25)
baseHeightSliderPosition.Value = TerrainOptions.baseHeight
local accordionBoxAtY = curY


-----------------------
-- hill settings
hillSettingsFrame = Instance.new(&quot;Frame&quot;)

-- hill size slider
hillDensityLabel = CreateStandardLabel(&quot;DensityLabel&quot;, UDim2.new(0, 8, 0, 0), UDim2.new(0, 67, 0, 14), &quot;&quot;, hillSettingsFrame)
hillDensitySliderGui, hillDensitySliderPosition = CreateStandardSlider(&apos;DensitySliderGui&apos;, UDim2.new(0,1,0,16), UDim2.new(0,10,0.5,-2), 21, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(hillDensitySliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.hillSizeModifier = 2^((hillDensitySliderPosition.Value - 11)/10)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;hillDensityLabel.Text = &quot;Hill density modifier: &quot;..string.format(&quot;%1.2fx&quot;, TerrainOptions.hillSizeModifier)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, hillSettingsFrame)
hillDensitySliderPosition.Value = log(TerrainOptions.hillSizeModifier)/log(2)*10 + 11

-- cliffs modifier
function onEnableCliffs()
&#9;TerrainOptions.enableCliffs = not TerrainOptions.enableCliffs
&#9;if TerrainOptions.enableCliffs then
&#9;&#9;enableCliffsCheckbox.Text = &quot;X&quot;
&#9;&#9;cliffDensitySliderGui.Visible = true
&#9;&#9;cliffDensityLabel.Visible = true
&#9;else
&#9;&#9;enableCliffsCheckbox.Text = &quot;&quot;
&#9;&#9;cliffDensitySliderGui.Visible = false
&#9;&#9;cliffDensityLabel.Visible = false
&#9;end
end
enableCliffsLabel = CreateStandardLabel(&quot;EnableCliffsLabel&quot;, UDim2.new(0, 44, 0, 41), UDim2.new(0, 50, 0, 24), &quot;Enable Cliffs&quot;, hillSettingsFrame)
enableCliffsCheckbox = CreateStandardButton(&quot;EnableCliffsCheckbox&quot;, UDim2.new(0, 10, 0, 41), &apos;&apos;, 
&#9; onEnableCliffs, hillSettingsFrame, UDim2.new(0, 24, 0, 24))

cliffDensityLabel = CreateStandardLabel(&quot;CliffDensityLabel&quot;, UDim2.new(0, 8, 0, 65), UDim2.new(0, 67, 0, 14), &quot;&quot;, hillSettingsFrame)
cliffDensitySliderGui, cliffDensitySliderPosition = CreateStandardSlider(&apos;CliffDensitySliderGui&apos;, UDim2.new(0,1,0,81), UDim2.new(0,10,0.5,-2), 21, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(cliffDensitySliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.cliffDensityModifier = 2^((cliffDensitySliderPosition.Value - 11)/10)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cliffDensityLabel.Text = &quot;Cliff density modifier: &quot;..string.format(&quot;%1.2fx&quot;, TerrainOptions.cliffDensityModifier)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, hillSettingsFrame)
cliffDensitySliderPosition.Value = log(TerrainOptions.cliffDensityModifier)/log(2)*10 + 11

onEnableCliffs()
onEnableCliffs()



-----------------------
-- mountain settings
mountainSettingsFrame = Instance.new(&apos;Frame&apos;)

function onMountainPatternDropdown(value) 
&#9;TerrainOptions.mountainMode = value
&#9;for _, o in pairs(mountainControlSet) do
&#9;&#9;o.Visible = (value ~= &quot;None&quot;)
&#9;end
&#9;if value == &quot;None&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(No mountains)&quot;
&#9;elseif value == &quot;Whole Map&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(The entire map contains mountains)&quot;
&#9;elseif value == &quot;Ridge&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(One ridge of mountains down the middle of the map)&quot;
&#9;elseif value == &quot;Ring&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(Edges of map contain mountains, with hills in the middle)&quot;
&#9;elseif value == &quot;Random&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(Mountains are randomly placed around the map)&quot;
&#9;elseif value == &quot;Interactive&quot; then
&#9;&#9;mountainPatternDescriptionLabel.Text = &quot;(Draw a custom region where you want mountains to be located)&quot;
&#9;end
end
mountainPatternDropdown, mountainPatternSet = CreateStandardDropdown(&quot;MountainPatternDropdown&quot;,
&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0,0,0,0),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;{&quot;None&quot;, &quot;Whole Map&quot;, &quot;Ridge&quot;, &quot;Ring&quot;, &quot;Random&quot;, &quot;Interactive&quot;},
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&quot;Ridge&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;onMountainPatternDropdown, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainSettingsFrame)

mountainPatternDescriptionLabel = CreateStandardLabel(&quot;DescriptionLabel&quot;, UDim2.new(0, 10, 0, 29), UDim2.new(0, 186, 0, 44), &quot;&quot;, mountainSettingsFrame)
mountainPatternDescriptionLabel.Font = &quot;Arial&quot;
mountainPatternDescriptionLabel.TextWrap = true
mountainPatternDescriptionLabel.TextYAlignment = &quot;Top&quot;

mountainAmplitudeLabel = CreateStandardLabel(&quot;AmplitudeLabel&quot;, UDim2.new(0, 8, 0, 76), UDim2.new(0, 67, 0, 14), &quot;&quot;, mountainSettingsFrame)
mountainAmplitudeSliderGui, mountainAmplitudeSliderPosition = CreateStandardSlider(&apos;AmplitudeSliderGui&apos;, UDim2.new(0,1,0,92), UDim2.new(0,10,0.5,-2), 62, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(mountainAmplitudeSliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.mountainHeight = mountainAmplitudeSliderPosition.Value + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;mountainAmplitudeLabel.Text = &quot;Max mountain height: &quot;..TerrainOptions.mountainHeight
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, mountainSettingsFrame)
mountainAmplitudeSliderPosition.Value = TerrainOptions.mountainHeight

mountainFrequencyLabel = CreateStandardLabel(&quot;FrequencyLabel&quot;, UDim2.new(0, 8, 0, 117), UDim2.new(0, 67, 0, 14), &quot;&quot;, mountainSettingsFrame)
mountainFrequencySlider, mountainFrequencySliderPosition = CreateStandardSlider(&apos;FrequencySlider&apos;, UDim2.new(0,1,0,133), UDim2.new(0,10,0.5,-2), 11,
&#9; function(mountainFrequencySliderPosition)
&#9; &#9;TerrainOptions.mountainFrequency = (mountainFrequencySliderPosition.Value-1)/10
&#9; &#9;mountainFrequencyLabel.Text = &quot;Region is &quot;..(TerrainOptions.mountainFrequency*100)..&quot;% mountainous&quot;
&#9; end, nil, mountainSettingsFrame)
mountainFrequencySliderPosition.Value = TerrainOptions.mountainFrequency*10 + 1

mountainFeatureSizeLabel = CreateStandardLabel(&quot;FeatureSizeLabel&quot;, UDim2.new(0, 8, 0, 158), UDim2.new(0, 67, 0, 14), &quot;&quot;, mountainSettingsFrame)
mountainFeatureSizeSlider, mountainFeatureSizeSliderPosition = CreateStandardSlider(&apos;FeatureSizeSlider&apos;, UDim2.new(0,1,0,174), UDim2.new(0,10,0.5,-2), 41,
&#9; function(mountainFeatureSizeSliderPosition)
&#9; &#9;TerrainOptions.mountainSize = (mountainFeatureSizeSliderPosition.Value-1)/40
&#9; &#9;mountainFeatureSizeLabel.Text = 
&#9; &#9;&#9;&quot;Mountain Size: &quot;..(TerrainOptions.mountainSize*100)..&quot;% of map&quot;
&#9; end, nil, mountainSettingsFrame)
mountainFeatureSizeSliderPosition.Value = TerrainOptions.mountainSize*40 + 1

mountainControlSet = {mountainAmplitudeLabel, mountainAmplitudeSliderGui, mountainFrequencyLabel, mountainFrequencySlider,
 mountainFeatureSizeLabel, mountainFeatureSizeSlider}
onMountainPatternDropdown(&quot;Ridge&quot;)


-----------------------
-- water settings
waterSettingsFrame = Instance.new(&apos;Frame&apos;)

-- water mode dropdown
function onSetWaterMode(value)
&#9;TerrainOptions.waterMode = value
&#9;--
&#9;if value == &quot;None&quot; then
&#9;&#9;sealevelLabel.Visible = false
&#9;&#9;sealevelSliderGui.Visible = false
&#9;end
&#9;if value == &quot;Lakes&quot; or value == &quot;Both&quot; then
&#9;&#9;lakeDensityLabel.Visible = true
&#9;&#9;lakeDensitySliderGui.Visible = true
&#9;&#9;lakeMaxSizeLabel.Visible = true
&#9;&#9;lakeMaxSizeSliderGui.Visible = true
&#9;&#9;lakeDensityLabel.Position = UDim2.new(0, 8, 0, 34)
&#9;&#9;lakeDensitySliderGui.Position = UDim2.new(0, 0, 0, 50)
&#9;&#9;lakeMaxSizeLabel.Position = UDim2.new(0, 8, 0, 75)
&#9;&#9;lakeMaxSizeSliderGui.Position = UDim2.new(0, 0, 0, 91)
&#9;else
&#9;&#9;lakeDensityLabel.Visible = false
&#9;&#9;lakeDensitySliderGui.Visible = false
&#9;&#9;lakeMaxSizeLabel.Visible = false
&#9;&#9;lakeMaxSizeSliderGui.Visible = false
&#9;end
&#9;if value == &quot;Ocean&quot; then
&#9;&#9;sealevelLabel.Visible = true
&#9;&#9;sealevelSliderGui.Visible = true
&#9;&#9;sealevelLabel.Position = UDim2.new(0, 8, 0, 34)
&#9;&#9;sealevelSliderGui.Position = UDim2.new(0, 0, 0, 50)
&#9;elseif value == &quot;Both&quot; then
&#9;&#9;sealevelLabel.Visible = true
&#9;&#9;sealevelSliderGui.Visible = true
&#9;&#9;sealevelLabel.Position = UDim2.new(0, 8, 0, 116)
&#9;&#9;sealevelSliderGui.Position = UDim2.new(0, 0, 0, 132)
&#9;else
&#9;&#9;sealevelLabel.Visible = false
&#9;&#9;sealevelSliderGui.Visible = false
&#9;end
end
waterModeDropdown, waterModeSet = CreateStandardDropdown(&quot;WaterModeDropdown&quot;,
 UDim2.new(0,0,0,0),
 {&quot;None&quot;, &quot;Lakes&quot;, &quot;Ocean&quot;, &quot;Both&quot;},
 &quot;None&quot;,
 onSetWaterMode,
 waterSettingsFrame)

-- Slider for controlling the waterHeight, how much water to fill.
lakeDensityLabel = CreateStandardLabel(&quot;LakeFrequencyLabel&quot;, UDim2.new(0, 8, 0, 2), UDim2.new(0, 67, 0, 14), &quot;&quot;, waterSettingsFrame)
lakeDensitySliderGui, lakeDensitySliderPosition = CreateStandardSlider(&apos;LakeFrequencySliderGui&apos;, UDim2.new(0,1,0,18), UDim2.new(0,10,0.5,-2), 4, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(lakeDensitySliderPosition) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local val = lakeDensitySliderPosition.Value
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local str, num;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if val == 1 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;str, num = &quot;No lakes.&quot;, 0
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif val == 2 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;str, num = &quot;1 lake / 20000 squares&quot;, 1/20000
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif val == 3 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;str, num = &quot;2 lakes/ 20000 squares&quot;, 1/10000
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;elseif val == 4 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;str, num = &quot;4 lakes/ 20000 squares&quot;, 1/5000
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.lakesPerSquare = num
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lakeDensityLabel.Text = &quot;Lakes: &quot;..str
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, waterSettingsFrame)
lakeDensitySliderPosition.Value = 3

-- Slider for the lake max size
lakeMaxSizeLabel = CreateStandardLabel(&quot;LakeMaxSizeLabel&quot;, UDim2.new(0, 8, 0, 2), UDim2.new(0, 67, 0, 14), &quot;&quot;, waterSettingsFrame)
lakeMaxSizeSliderGui, lakeMaxSizeSliderPosition = CreateStandardSlider(&apos;LakeMaxSizeSliderGui&apos;, UDim2.new(0,1,0,18), UDim2.new(0,10,0.5,-2), 5, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(lakeMaxSizeSliderPosition)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TerrainOptions.lakeMaxSize = lakeMaxSizeSliderPosition.Value*1000
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lakeMaxSizeLabel.Text = &quot;Lake max size: &quot;..TerrainOptions.lakeMaxSize..&quot; squares&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end, nil, waterSettingsFrame)
lakeMaxSizeSliderPosition.Value = TerrainOptions.lakeMaxSize/1000

-- Slider for the sea level
sealevelLabel = CreateStandardLabel(&quot;SeaLevelLabel&quot;, UDim2.new(0, 8, 0, 2), UDim2.new(0, 67, 0, 14), &quot;&quot;, waterSettingsFrame)
sealevelSliderGui, sealevelSliderPosition = CreateStandardSlider(&quot;SealevelSliderGui&quot;, UDim2.new(0,1,0,18), UDim2.new(0,10,0.5,-2), 31,
 function(sealevelSliderPosition)
 &#9;TerrainOptions.sealevel = sealevelSliderPosition.Value - 1
 &#9;sealevelLabel.Text = &quot;Sea level: &quot;..TerrainOptions.sealevel
 end, nil, waterSettingsFrame)
sealevelSliderPosition.Value = TerrainOptions.sealevel + 1

waterModeSet(TerrainOptions.waterMode)
-- programetrically setting the water mode does not call set callback oddly 
-- enough, so it has to be manually called here to lay things out right.
onSetWaterMode(TerrainOptions.waterMode) 



--------------------------
-- vegetation settings
vegetationSettingsFrame = Instance.new(&apos;Frame&apos;)

vegetationCheckBox = CreateStandardButton(&quot;GenerateButton&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0, 10, 0, 0),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &apos;&apos;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &#9;setVegetationMode(not TerrainOptions.vegetationMode)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; end,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; vegetationSettingsFrame,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0, 24, 0, 24))
function setVegetationMode(st)
&#9;TerrainOptions.vegetationMode = st
&#9;if st then
&#9;&#9;vegetationCheckBox.Text = &quot;X&quot;
&#9;&#9;vegetationSliderGui.Visible = true
&#9;&#9;-- get the text to update to what it should be
&#9;&#9;onVegetationSlider(vegetationSliderPosition)
&#9;else
&#9;&#9;vegetationCheckBox.Text = &quot;&quot;
&#9;&#9;vegetationLabel.Text = &quot;Vegetation not enabled&quot;
&#9;&#9;vegetationSliderGui.Visible = false
&#9;end
end

function onVegetationSlider(vegetationSliderPosition)
&#9;TerrainOptions.vegetationDensity = vegetationSliderPosition.Value / 200
&#9;local suffix = (vegetationSliderPosition.Value &gt; 1) and &quot;s&quot; or &quot;&quot;
&#9;vegetationLabel.Text = vegetationSliderPosition.Value..&quot; tree&quot;..suffix..&quot; / 200 squares&quot;
end

vegetationLabel = CreateStandardLabel(&quot;VegetationLabel&quot;, UDim2.new(0, 44, 0, 5), UDim2.new(0, 50, 0, 14), &quot;&quot;, vegetationSettingsFrame)
vegetationSliderGui, vegetationSliderPosition = CreateStandardSlider(&quot;VegetationSliderGui&quot;, UDim2.new(0,1,0,24), UDim2.new(0,10,0.5,-2), 4,
 onVegetationSlider, nil, vegetationSettingsFrame)
vegetationSliderPosition.Value = TerrainOptions.vegetationDensity * 200
setVegetationMode(TerrainOptions.vegetationMode)



--------------------------
-- material settings 
materialSettingsFrame = Instance.new(&apos;Frame&apos;)

function onSetColorMode(value)
&#9;TerrainOptions.colorMode = value
&#9;for _, o in pairs(materialControlSet) do
&#9;&#9;o.Visible = (value == &quot;Auto Color&quot;)
&#9;end
end
colorModeDropdown, colorModeSet = CreateStandardDropdown(&quot;ColorModeDropdown&quot;,
 UDim2.new(0,0,0,0),
 {&quot;Solid Color&quot;, &quot;Auto Color&quot;},
 &quot;Auto Color&quot;,
 onSetColorMode,
 materialSettingsFrame)

function onColorMountainsMode()
&#9;TerrainOptions.colorMountains = not TerrainOptions.colorMountains
&#9;if TerrainOptions.colorMountains then
&#9;&#9;colorMountainsCheckbox.Text = &quot;X&quot;
&#9;else
&#9;&#9;colorMountainsCheckbox.Text = &quot;&quot;
&#9;end
end
colorMountainsLabel = CreateStandardLabel(&quot;ColorMountainsLabel&quot;, UDim2.new(0, 44, 0, 34), UDim2.new(0, 50, 0, 24), &quot;Color mountains&quot;, materialSettingsFrame)
colorMountainsCheckbox = CreateStandardButton(&quot;ColorMountainsCheckbox&quot;, UDim2.new(0, 10, 0, 34), &apos;&apos;, 
&#9; onColorMountainsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onColorMountainsMode()
onColorMountainsMode()

function onSnowtoppedMountainsMode()
&#9;TerrainOptions.snowtoppedMountains = not TerrainOptions.snowtoppedMountains
&#9;if TerrainOptions.snowtoppedMountains then
&#9;&#9;snowtoppedMountainsCheckbox.Text = &quot;X&quot;
&#9;else
&#9;&#9;snowtoppedMountainsCheckbox.Text = &quot;&quot;
&#9;end
end
snowtoppedMountainsLabel = CreateStandardLabel(&quot;SnowtoppedMountainsLabel&quot;, UDim2.new(0, 44, 0, 56), UDim2.new(0, 50, 0, 24), &quot;Snow on mountaintops&quot;, materialSettingsFrame)
snowtoppedMountainsCheckbox = CreateStandardButton(&quot;SnowtoppedMountaisCheckbox&quot;, UDim2.new(0, 10, 0, 56), &apos;&apos;, 
&#9; onSnowtoppedMountainsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onSnowtoppedMountainsMode()
onSnowtoppedMountainsMode()

function onColorCliffsMode()
&#9;TerrainOptions.colorCliffs = not TerrainOptions.colorCliffs
&#9;if TerrainOptions.colorCliffs then
&#9;&#9;colorCliffsCheckbox.Text = &quot;X&quot;
&#9;else
&#9;&#9;colorCliffsCheckbox.Text = &quot;&quot;
&#9;end
end
colorCliffsLabel = CreateStandardLabel(&quot;ColorCliffsLabel&quot;, UDim2.new(0, 44, 0, 78), UDim2.new(0, 50, 0, 24), &quot;Color cliffs&quot;, materialSettingsFrame)
colorCliffsCheckbox = CreateStandardButton(&quot;ColorCliffsCheckbox&quot;, UDim2.new(0, 10, 0, 78), &apos;&apos;, 
&#9; onColorCliffsMode, materialSettingsFrame, UDim2.new(0, 24, 0, 24))
onColorCliffsMode()
onColorCliffsMode()

materialControlSet = {colorMountainsLabel, colorMountainsCheckbox, snowtoppedMountainsLabel, snowtoppedMountainsCheckbox,
 colorCliffsLabel, colorCliffsCheckbox}

-----------------------
-- main accordion for all of those settings
mainSettingsAccordion = CreateStandardAccordion(&quot;MoreSettingsAccordion&quot;, 
 UDim2.new(0, 0, 0, accordionBoxAtY), 
 UDim2.new(1, 0, 0, 310),
 {
 &#9;{Name = &apos;Hills&apos;, Gui = hillSettingsFrame, Height = 125};
 &#9;{Name = &apos;Mountains&apos;, Gui = mountainSettingsFrame, Height = 200};
 &#9;{Name = &apos;Water&apos;, Gui = waterSettingsFrame, Height = 175};
 &#9;{Name = &apos;Vegetation&apos;, Gui = vegetationSettingsFrame, Height = 50};
 &#9;{Name = &apos;Materials&apos;, Gui = materialSettingsFrame, Height = 150};
 }, 
 terrainFrame)


-- Button to generate terrain using the current settings.
generateButton = CreateStandardButton(&quot;GenerateButton&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0.5, 0, 0, 445),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &apos;Generate&apos;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ConfirmGenerateTerrain,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; terrainFrame,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0, 100, 0, 40))&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; 
-- Button to clear terrain using. All terrain will be removed.
clearButton = CreateStandardButton(&quot;ClearButton&quot;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0.5, -100, 0, 445),
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; &apos;Clear&apos;,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; ConfirmClearTerrain,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; terrainFrame,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; UDim2.new(0, 100, 0, 40))&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9; 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;
--==========================================================================================================--
-- Final definition of main On/Off functions ==--
--==========================================================================================================--

-- Run when the popup is activated.
function On(mouseHandMeDown)
&#9;--plugin:Activate(true)
&#9;--toolbarbutton:SetActive(true)
&#9;terrainPropertiesDragBar.Visible = true
&#9;on = true
&#9;mouse = mouseHandMeDown
end

-- Run when the popup is deactivated.
function Off()
&#9;--toolbarbutton:SetActive(false)
&#9;ClearConformation()
&#9;on = false

&#9;-- Hide the popup gui.
&#9;terrainPropertiesDragBar.Visible = false&#9;
end

-- and we&apos;re finally done loading
loaded = true

return {
&#9;[&apos;On&apos;]= On,
&#9;[&apos;Off&apos;] = Off,
}</ProtectedString>
			</Properties>
		</Item>
	</Item>
</roblox>