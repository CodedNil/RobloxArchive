<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="LocalScript" referent="RBX17262A50E46A4A319BD9D03267001E56">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">CameraScript</string>
			<ProtectedString name="Source"><![CDATA[local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')

-- Issue with play solo? (F6)
while not UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled do
	wait()
end

local RootCamera = script:WaitForChild('RootCamera')
local ClassicCamera = require(RootCamera:WaitForChild('ClassicCamera'))()
local FollowCamera = require(RootCamera:WaitForChild('FollowCamera'))()
local PopperCam = require(script:WaitForChild('PopperCam'))
local Invisicam = require(script:WaitForChild('Invisicam'))
local ClickToMove = require(script:WaitForChild('ClickToMove'))()
local StarterPlayer = game:GetService('StarterPlayer')


local EnabledCamera = nil
local EnabledOcclusion = nil

local currentCameraConn = nil
local updateConn = nil

local CachedParts = {}
local TransparencyDirty = true
local LastTransparency = 0


local function IsTouch()
	return UserInputService.TouchEnabled
end

local function FuzzyEquals(num1, num2)
	return num1 > num2 - 0.01 and num1 < num2 + 0.01
end

local function Round(num, places)
	places = places or 0
	local decimalPivot = 10^places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end



local function shouldUseCustomCamera()
	local player = PlayersService.LocalPlayer
	local currentCamera = workspace.CurrentCamera
	if player then
		if currentCamera == nil or (currentCamera and currentCamera.CameraType == Enum.CameraType.Custom) then
			return true, player, currentCamera
		end
	end
	return false, player, currentCamera
end

local function isClickToMoveOn()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		if IsTouch() then -- Touch
			if player.DevTouchMovementMode == Enum.DevTouchMovementMode.ClickToMove then
				return true
			end
		else -- Computer
			if player.DevComputerMovementMode == Enum.DevComputerMovementMode.ClickToMove then
				return true
			end
		end
	end
	return false	
end

local function getCurrentCameraMode()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		if IsTouch() then -- Touch (iPad, etc...)
			if isClickToMoveOn() then
				return Enum.DevTouchMovementMode.ClickToMove.Name
			else
				return player.DevTouchCameraMode.Name
			end
		else -- Computer
			if isClickToMoveOn() then
				return Enum.DevComputerMovementMode.ClickToMove.Name
			else
				return player.DevComputerCameraMode.Name
			end
		end
	end
end

local function getCameraOcclusionMode()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		return player.DevCameraOcclusionMode
	end
end

local function ModifyCharacterTransparency()
	local currentCamera = workspace.CurrentCamera
	local player = PlayersService.LocalPlayer
	local character = player and player.Character
	if player and character and currentCamera then
		local distance = player:DistanceFromCharacter(currentCamera.CoordinateFrame.p)
		local transparency = Round(math.max(0, math.min(1, (7 - distance) / 5)), 2)
		if TransparencyDirty or LastTransparency ~= transparency then
			for child, _ in pairs(CachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			TransparencyDirty = false
			LastTransparency = transparency
		end
	end
end

local function Update()
	if EnabledCamera then
		EnabledCamera:Update()
	end
	if EnabledOcclusion and EnabledCamera and not EnabledCamera:IsInFirstPerson() then
		EnabledOcclusion:Update()
	end
	if shouldUseCustomCamera() then
		--ModifyCharacterTransparency()
	end
end

local function OnCameraMovementModeChange(newCameraMode)
	if newCameraMode == Enum.DevComputerMovementMode.ClickToMove.Name then
		ClickToMove:Start()
		EnabledCamera = nil
	else
		if newCameraMode == Enum.ComputerCameraMovementMode.Classic.Name then
			EnabledCamera = ClassicCamera
		elseif newCameraMode == Enum.ComputerCameraMovementMode.Follow.Name then
			EnabledCamera = FollowCamera
		else -- They are disabling our special movement code
			EnabledCamera = nil
		end
		ClickToMove:Stop()
	end
	
	local newOcclusionMode = getCameraOcclusionMode()
	if EnabledOcclusion == Invisicam and newOcclusionMode ~= Enum.DevCameraOcclusionMode.Invisicam then
		Invisicam:Cleanup()
	end
	if newOcclusionMode == Enum.DevCameraOcclusionMode.Zoom then
		EnabledOcclusion = PopperCam
	elseif newOcclusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		EnabledOcclusion = Invisicam
	else
		EnabledOcclusion = false
	end
	
	if updateConn then
		updateConn:disconnect()
	end
	updateConn = PlayersService.LocalPlayer:GetMouse().Move:connect(Update)
end

local function OnNewCamera()
	OnCameraMovementModeChange(getCurrentCameraMode())
		
	local currentCamera = workspace.CurrentCamera
	if currentCamera then
		if currentCameraConn then
			currentCameraConn:disconnect()
			currentCameraConn = nil
		end
		currentCameraConn = currentCamera.Changed:connect(function(prop)
			if prop == 'CameraType' then
				OnCameraMovementModeChange(getCurrentCameraMode())
				TransparencyDirty = true
			elseif prop == 'CameraSubject' then
				TransparencyDirty = true
			end
		end)
	end
end

local function OnCharacterAdded(character)
	CachedParts = {}
	local function IsValidPartToModify(part)
		local function HasToolAncestor(object)
			if object.Parent == nil then return false end
			return object.Parent:IsA('Tool') or HasToolAncestor(object.Parent) 
		end
		
		if part:IsA('BasePart') or part:IsA('Decal') then
			return not HasToolAncestor(part)
		end
		return false
	end
	local function CachePartsRecursive(object)
		if object then
			if IsValidPartToModify(object) then
				CachedParts[object] = true
				TransparencyDirty = true
			end
			for _, child in pairs(object:GetChildren()) do
				CachePartsRecursive(child)
			end
		end
	end
	character.DescendantAdded:connect(function(object)
		-- This is a part we want to invisify
		if IsValidPartToModify(object) then
			CachedParts[object] = true
			TransparencyDirty = true
		-- There is now a tool under the character
		elseif object:IsA('Tool') then
			object.DescendantAdded:connect(function(toolChild)
				CachedParts[toolChild] = nil
				if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
					-- Reset the transparency
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			object.DescendantRemoving:connect(function(formerToolChild)
				wait() -- wait for new parent
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
					if IsValidPartToModify(formerToolChild) then
						CachedParts[formerToolChild] = true
						TransparencyDirty = true
					end
				end
			end)
		end
	end)
	character.DescendantRemoving:connect(function(object)
		if CachedParts[object] then
			CachedParts[object] = nil
			-- Reset the transparency
			object.LocalTransparencyModifier = 0
		end
	end)
	CachePartsRecursive(character)
end

local function OnPlayerAdded(player)
	player.CharacterRemoving:connect(function() CachedParts = {} end)
	player.CharacterAdded:connect(OnCharacterAdded)
	if player.Character then
		OnCharacterAdded(player.Character)
	end
	
	workspace.Changed:connect(function(prop)
		if prop == 'CurrentCamera' then
			OnNewCamera()
		end
	end)
	
	player.Changed:connect(function(prop)
		OnCameraMovementModeChange(getCurrentCameraMode())
	end)
	
	if updateConn then
		updateConn:disconnect()
	end
	updateConn = player:GetMouse().Move:connect(Update)
	
	OnNewCamera()
	OnCameraMovementModeChange(getCurrentCameraMode())	
end

do
	while PlayersService.LocalPlayer == nil do wait() end
	OnPlayerAdded(PlayersService.LocalPlayer)
end
]]></ProtectedString>
		</Properties>
		<Item class="ModuleScript" referent="RBXFA646A692298491C891EFC06525CFF60">
			<Properties>
				<string name="Name">ShiftLockController</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: ShiftLockController
	// Written by: jmargh
	// Description: Manages the state of shift lock mode
	
	// Required by:
		RootCamera
--]]
local ContextActionService = game:GetService('ContextActionService')
local Players = game:GetService('Players')
local StarterPlayer = game:GetService('StarterPlayer')
local UserInputService = game:GetService('UserInputService')

local ShiftLockController = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local PlayerGui = LocalPlayer:WaitForChild('PlayerGui')
local ScreenGui = nil
local ShiftLockIcon = nil
local IsShiftLockMode = false
local IsShiftLocked = false
local IsActionBound = false

-- wrapping long conditional in function
local function isShiftLockMode()
	return false
end

if not UserInputService.TouchEnabled then	-- TODO: Remove when safe on mobile
	IsShiftLockMode = isShiftLockMode()
end

--[[ Constants ]]--
local SHIFT_LOCK_OFF = 'rbxasset://textures/ui/mouseLock_off.png'
local SHIFT_LOCK_ON = 'rbxasset://textures/ui/mouseLock_on.png'
local SHIFT_LOCK_CURSOR = 'rbxasset://textures/MouseLockedCursor.png'

--[[ Local Functions ]]--
local function onShiftLockToggled()
	IsShiftLocked = not IsShiftLocked
	if IsShiftLocked then
		ShiftLockIcon.Image = SHIFT_LOCK_ON
		Mouse.Icon = SHIFT_LOCK_CURSOR
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	else
		ShiftLockIcon.Image = SHIFT_LOCK_OFF
		Mouse.Icon = ""
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

local function initialize()
	if ScreenGui then
		ScreenGui:Destroy()
		ScreenGui = nil
	end
	ScreenGui = Instance.new('ScreenGui')
	ScreenGui.Name = "ControlGui"
	
	local frame = Instance.new('Frame')
	frame.Name = "BottomLeftControl"
	frame.Size = UDim2.new(0, 130, 0, 46)
	frame.Position = UDim2.new(0, 0, 1, -46)
	frame.BackgroundTransparency = 1
	frame.Parent = ScreenGui
	
	ShiftLockIcon = Instance.new('ImageButton')
	ShiftLockIcon.Name = "MouseLockLabel"
	ShiftLockIcon.Size = UDim2.new(0, 62, 0, 62)
	ShiftLockIcon.Position = UDim2.new(0, 2, 0, -65)
	ShiftLockIcon.BackgroundTransparency = 1
	ShiftLockIcon.Image = IsShiftLocked and SHIFT_LOCK_ON or SHIFT_LOCK_OFF
	ShiftLockIcon.Visible = IsShiftLockMode
	ShiftLockIcon.Parent = frame
	
	ShiftLockIcon.MouseButton1Click:connect(onShiftLockToggled)
	
	ScreenGui.Parent = PlayerGui
end

--[[ Public API ]]--
function ShiftLockController:IsShiftLocked()
	return IsShiftLockMode and IsShiftLocked
end

--[[ Input/Settings Changed Events ]]--
local mouseLockSwitchFunc = function(actionName, inputState, inputObject)
	if IsShiftLockMode and inputState == Enum.UserInputState.Begin then
		onShiftLockToggled()
	end
end

local function disableShiftLock()
	if ShiftLockIcon then ShiftLockIcon.Visible = false end
	IsShiftLockMode = false
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	Mouse.Icon = ""
	ContextActionService:UnbindAction("ToggleShiftLock")
	IsActionBound = false
end

local function enableShiftLock()
	IsShiftLockMode = isShiftLockMode()
	if IsShiftLockMode then
		if ShiftLockIcon then
			ShiftLockIcon.Visible = true
		end
		if IsShiftLocked then
			Mouse.Icon = SHIFT_LOCK_CURSOR
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		end
		if not IsActionBound then
			ContextActionService:BindActionToInputTypes("ToggleShiftLock", mouseLockSwitchFunc, false, Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift)
			IsActionBound = true
		end
	end
end

LocalPlayer.Changed:connect(function(property)
	if property == 'DevEnableMouseLock' then
		if LocalPlayer.DevEnableMouseLock then
			enableShiftLock()
		else
			disableShiftLock()
		end
	elseif property == 'DevComputerMovementMode' then
		if LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.ClickToMove or
			LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable then
			--
			disableShiftLock()
		else
			enableShiftLock()
		end
	end
end)

LocalPlayer.CharacterAdded:connect(function(character)
	-- we need to recreate guis on character load
	if not UserInputService.TouchEnabled then
		initialize()
	end
end)

--[[ Initialization ]]--
if not UserInputService.TouchEnabled then -- TODO: Remove when safe!
	initialize()
	if isShiftLockMode() then
		ContextActionService:BindActionToInputTypes("ToggleShiftLock", mouseLockSwitchFunc, false, Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift)
		IsActionBound = true
	end
end

return ShiftLockController
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX5418959F50B6428FAF2644F80DC46A89">
			<Properties>
				<string name="Name">PopperCam</string>
				<ProtectedString name="Source"><![CDATA[-- PopperCam Version 12
-- OnlyTwentyCharacters

local PopperCam = {} -- Guarantees your players won't see outside the bounds of your map!

---------------
-- Constants --
---------------

local POP_RESTORE_RATE = 0.3
local CAST_SCREEN_SCALES = { -- (Relative)
	Vector2.new(1, 1) / 2, -- Center
	Vector2.new(0, 0), -- Top left
	Vector2.new(1, 0), -- Top right
	Vector2.new(1, 1), -- Bottom right
	Vector2.new(0, 1), -- Bottom left
}
local NEAR_CLIP_PLANE_OFFSET = 0.5 --NOTE: Not configurable

---------------
-- Variables --
---------------

local PlayersService = game:GetService('Players')
local Player = PlayersService.LocalPlayer
local PlayerMouse = Player:GetMouse()

local Camera = nil
local CameraChangeConn = nil

local PlayerCharacters = {} -- For ignoring in raycasts
local VehicleParts = {} -- Also just for ignoring

local LastPopAmount = 0
local LastZoomLevel = 0

---------------------
-- Local Functions --
---------------------

local function CastRay(fromPoint, toPoint, ignoreList)
	local vector = toPoint - fromPoint
	local ray = Ray.new(fromPoint, vector.Unit * math.min(vector.Magnitude, 999))
	return workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {})
end

-- Casts and recasts until it hits either: nothing, or something not transparent or collidable
local function PiercingCast(fromPoint, toPoint, ignoreList) --NOTE: Modifies ignoreList!
	repeat
		local hitPart, hitPoint = CastRay(fromPoint, toPoint, ignoreList)
		if hitPart and (hitPart.Transparency > 0.95 or hitPart.CanCollide == false) then
			table.insert(ignoreList, hitPart)
		else
			return hitPart, hitPoint
		end
	until false
end

local function ScreenToWorld(screenPoint, screenSize, pushDepth)
	local cameraFOV, cameraCFrame = Camera.FieldOfView, Camera.CoordinateFrame
	local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(cameraFOV) / 2))
	local direction = Vector3.new(screenPoint.x - (screenSize.x / 2), (screenSize.y / 2) - screenPoint.y, -imagePlaneDepth)
	local worldDirection = (cameraCFrame:vectorToWorldSpace(direction)).Unit
	local theta = math.acos(math.min(1, worldDirection:Dot(cameraCFrame.lookVector)))
	local fixedPushDepth = pushDepth / math.sin((math.pi / 2) - theta)
	return cameraCFrame.p + worldDirection * fixedPushDepth
end

local function OnCameraChanged(property)
	if property == 'CameraSubject' then
		local newSubject = Camera.CameraSubject
		if newSubject and newSubject:IsA('VehicleSeat') then
			VehicleParts = newSubject:GetConnectedParts(true)
		else
			VehicleParts = {}
		end
	end
end

local function OnCharacterAdded(player, character)
	PlayerCharacters[player] = character
end

local function OnPlayersChildAdded(child)
	if child:IsA('Player') then
		child.CharacterAdded:connect(function(character)
			OnCharacterAdded(child, character)
		end)
		if child.Character then
			OnCharacterAdded(child, child.Character)
		end
	end
end

local function OnPlayersChildRemoved(child)
	if child:IsA('Player') then
		PlayerCharacters[child] = nil
	end
end

local function OnWorkspaceChanged(property)
	if property == 'CurrentCamera' then
		local newCamera = workspace.CurrentCamera
		if newCamera then
			Camera = newCamera
			
			if CameraChangeConn then
				CameraChangeConn:disconnect()
			end
			CameraChangeConn = Camera.Changed:connect(OnCameraChanged)
		end
	end
end

-----------------------
-- Exposed Functions --
-----------------------

function PopperCam:Update()
	-- First, prep some intermediate vars
	local focusPoint = Camera.Focus.p
	local cameraCFrame = Camera.CoordinateFrame
	local cameraFrontPoint = cameraCFrame.p + (cameraCFrame.lookVector * NEAR_CLIP_PLANE_OFFSET)
	local screenSize = Vector2.new(PlayerMouse.ViewSizeX, PlayerMouse.ViewSizeY)
	local ignoreList = {}
	for _, character in pairs(PlayerCharacters) do
		table.insert(ignoreList, character)
	end
	for _, basePart in pairs(VehicleParts) do
		table.insert(ignoreList, basePart)
	end
	
	-- Cast rays at the near clip plane, from corresponding points near the focus point,
	-- and find the direct line that is the most cut off
	local largest = 0
	for _, screenScale in pairs(CAST_SCREEN_SCALES) do
		local clipWorldPoint = ScreenToWorld(screenSize * screenScale, screenSize, NEAR_CLIP_PLANE_OFFSET)
		local rayStartPoint = focusPoint + (clipWorldPoint - cameraFrontPoint)
		local _, hitPoint = PiercingCast(rayStartPoint, clipWorldPoint, ignoreList)
		local cutoffAmount = (hitPoint - clipWorldPoint).Magnitude
		if cutoffAmount > largest then
			largest = cutoffAmount
		end
	end
	
	-- Then check if the user zoomed since the last frame,
	-- and if so, reset our pop history so we stop tweening
	local zoomLevel = (cameraCFrame.p - focusPoint).Magnitude
	if math.abs(zoomLevel - LastZoomLevel) > 0.001 then
		LastPopAmount = 0
	end
	
	-- Finally, pop (zoom) the camera in by that most-cut-off amount, or the last pop amount if that's more
	local popAmount = math.max(largest, LastPopAmount)
	if popAmount > 0 then
		Camera.CoordinateFrame = cameraCFrame + (cameraCFrame.lookVector * popAmount)
		LastPopAmount = math.max(popAmount - POP_RESTORE_RATE, 0) -- Shrink it for the next frame
	end
	
	LastZoomLevel = zoomLevel
end

------------------
-- Script Logic --
------------------

-- Connect to the current and all future cameras
workspace.Changed:connect(OnWorkspaceChanged)
OnWorkspaceChanged('CurrentCamera')

-- Connect to all Players so we can ignore their Characters
PlayersService.ChildRemoved:connect(OnPlayersChildRemoved)
PlayersService.ChildAdded:connect(OnPlayersChildAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
	OnPlayersChildAdded(player)
end

return PopperCam
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXBAE280F7E15144B79E9AF6473D8A9C1D">
			<Properties>
				<string name="Name">RootCamera</string>
				<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')

local CameraScript = script.Parent
local ShiftLockController = require(CameraScript:WaitForChild('ShiftLockController'))

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	print("Trying to clamp when low:", low , "is larger than high:" , high , "returning input value.")
	return num
end

local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					humanoidCache[player] = child
					return child
				end
			end
		end
	end
end

local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)

local function CreateCamera()
	local this = {}
	
	this.ShiftLock = false
	this.Sensitivity = 0.2
	local isFirstPerson = false

	function this:GetShiftLock()
		return ShiftLockController:IsShiftLocked()
	end
	
	function this:GetHumanoid()
		local player = PlayersService.LocalPlayer
		return findPlayerHumanoid(player)
	end
	
	function this:GetHumanoidRootPart()
		local humanoid = this:GetHumanoid()
		return humanoid and humanoid.Torso
	end
	
	function this:GetSubjectPosition()
		local result = nil
		local camera = workspace.CurrentCamera
		if camera then
			local cameraSubject = camera.CameraSubject
			if cameraSubject:IsA('BasePart') then
				result = cameraSubject.CFrame.p
			elseif cameraSubject:IsA('Humanoid') then
				local humanoidRootPart = cameraSubject.Torso
				if humanoidRootPart and humanoidRootPart:IsA('BasePart') then
					result = humanoidRootPart.CFrame.p + Vector3.new(0, 1.5, 0) +
						humanoidRootPart.CFrame:vectorToWorldSpace(cameraSubject.CameraOffset)
				end
			end
		end
		return result
	end

	function this:ResetCameraLook()
		local camera = workspace.CurrentCamera
		if camera then
			self.cameraLook = camera and camera.CoordinateFrame.lookVector
		end
	end

	function this:GetCameraLook()
		if self.cameraLook == nil then
			self.cameraLook = workspace.CurrentCamera and workspace.CurrentCamera.CoordinateFrame.lookVector or Vector3.new(0,0,1)
		end
		return self.cameraLook
	end

	function this:GetCameraZoom()
		if this.currentZoom == nil then
			local player = PlayersService.LocalPlayer
			this.currentZoom = player and clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, 10) or 10
		end
		return this.currentZoom
	end
	
	function this:GetCameraActualZoom()
		local camera = workspace.CurrentCamera
		if camera then
			return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		end
	end
	
	function this:ViewSizeX()
		local result = 1024
		local player = PlayersService.LocalPlayer
		local mouse = player and player:GetMouse()
		if mouse then
			result = mouse.ViewSizeX
		end
		return result
	end
	
	function this:ViewSizeY()
		local result = 768
		local player = PlayersService.LocalPlayer
		local mouse = player and player:GetMouse()
		if mouse then
			result = mouse.ViewSizeY
		end
		return result
	end
	
	function this:ScreenTranslationToAngle(translationVector)
		local screenX = this:ViewSizeX()
		local screenY = this:ViewSizeY()
		-- moving your finger across the screen should be a full rotation
		local xTheta = (translationVector.x / screenX) * math.pi*2
		local yTheta = (translationVector.y / screenY) * math.pi
		return Vector2.new(xTheta, yTheta)
	end
	
	function this:RotateCamera(startLook, xyRotateVector)		
		-- Could cache these values so we don't have to recalc them all the time
		local startCFrame = CFrame.new(Vector3.new(), startLook)
		local startVertical = math.asin(startLook.y)
		local yTheta = clamp(-MAX_Y + startVertical, -MIN_Y + startVertical, xyRotateVector.y)
		self.cameraLook = (CFrame.Angles(0, -xyRotateVector.x, 0) * startCFrame * CFrame.Angles(-yTheta,0,0)).lookVector
		return this:GetCameraLook()
	end
	
	function this:IsInFirstPerson()
		return isFirstPerson
	end
	
	function this:ZoomCamera(desiredZoom)
		local player = PlayersService.LocalPlayer
		if player then
			if player.CameraMode == Enum.CameraMode.LockFirstPerson then
				this.currentZoom = 0
			else
				this.currentZoom = clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredZoom)
			end
		end
		-- set mouse behavior
		if self:GetCameraZoom() < 2 then
			isFirstPerson = true
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		else
			isFirstPerson = false
			if not self:GetShiftLock() then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
		return self:GetCameraZoom()
	end
	
	local function rk4Integrator(position, velocity, t)
		local direction = velocity < 0 and -1 or 1
		local function acceleration(p, v)
			local accel = direction * math.max(1, (p / 3.3) + 0.5)
			return accel
		end
		
		local p1 = position
		local v1 = velocity
		local a1 = acceleration(p1, v1)
		local p2 = p1 + v1 * (t / 2)
		local v2 = v1 + a1 * (t / 2)
		local a2 = acceleration(p2, v2)
		local p3 = p1 + v2 * (t / 2)
		local v3 = v1 + a2 * (t / 2)
		local a3 = acceleration(p3, v3)
		local p4 = p1 + v3 * t
		local v4 = v1 + a3 * t
		local a4 = acceleration(p4, v4)
		
		local positionResult = position + (v1 + 2 * v2 + 2 * v3 + v4) * (t / 6)
		local velocityResult = velocity + (a1 + 2 * a2 + 2 * a3 + a4) * (t / 6)
		return positionResult, velocityResult
	end
	
	function this:ZoomCameraBy(zoomScale)
		local zoom = this:GetCameraActualZoom()
		if zoom then
			-- Can break into more steps to get more accurate integration
			zoom = rk4Integrator(zoom, zoomScale, 1)
			self:ZoomCamera(zoom)
		end
		return self:GetCameraZoom()
	end
	
	function this:ZoomCameraFixedBy(zoomIncrement)
		return self:ZoomCamera(self:GetCameraZoom() + zoomIncrement)
	end	
	
	function this:Update()
	end
	
	---- Input Events ----
	local startPos = nil
	local lastPos = nil
	local panBeginLook = nil
	
	local fingerTouches = {}
	local NumUnsunkTouches = 0
	
	local StartingDiff = nil
	local pinchBeginZoom = nil
	
	this.ZoomEnabled = true
	this.PanEnabled = true
	this.KeyPanEnabled = true
	
	local function OnTouchBegan(input, processed)
		fingerTouches[input] = processed
		if not processed then			
			NumUnsunkTouches = NumUnsunkTouches + 1
		end
	end
	
	local function OnTouchChanged(input, processed)
		if fingerTouches[input] == nil then
			fingerTouches[input] = processed
			if not processed then			
				NumUnsunkTouches = NumUnsunkTouches + 1
			end
		end
		
		if NumUnsunkTouches == 1 then
			if fingerTouches[input] == false then
				panBeginLook = panBeginLook or this:GetCameraLook()
				startPos = startPos or input.Position
				lastPos = lastPos or startPos					
				this.UserPanningTheCamera = true
				
				local totalTrans = input.Position - startPos
				lastPos = input.Position
				if this.PanEnabled then
					this:RotateCamera(panBeginLook, this:ScreenTranslationToAngle(totalTrans))
				end
			end
		else
			panBeginLook = nil
			startPos = nil
			lastPos = nil				
			this.UserPanningTheCamera = false
		end
		if NumUnsunkTouches == 2 then
			local unsunkTouches = {}
			for touch, wasSunk in pairs(fingerTouches) do
				if not wasSunk then
					table.insert(unsunkTouches, touch)
				end
			end
			if #unsunkTouches == 2 then
				local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
				if StartingDiff and pinchBeginZoom then
					local scale = difference / math.max(0.01, StartingDiff)
					local clampedScale = clamp(0.1, 10, scale)
					if this.ZoomEnabled then
						this:ZoomCamera(pinchBeginZoom / clampedScale)
					end
				else
					StartingDiff = difference
					pinchBeginZoom = this:GetCameraZoom()
				end
			end
		else
			StartingDiff = nil
			pinchBeginZoom = nil
		end
	end
	
	local function OnTouchEnded(input, processed)
		if fingerTouches[input] == false then
			if NumUnsunkTouches == 1 then
				panBeginLook = nil
				startPos = nil
				lastPos = nil
				this.UserPanningTheCamera = false
			elseif NumUnsunkTouches == 2 then
				StartingDiff = nil
				pinchBeginZoom = nil
			end
		end
		
		if fingerTouches[input] ~= nil and fingerTouches[input] == false then
			NumUnsunkTouches = NumUnsunkTouches - 1
		end
		fingerTouches[input] = nil
	end
	
	local function OnMouse2Down(input, processed)
		if processed then return end
		-- Check if they are in first-person
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		end
		panBeginLook = this:GetCameraLook()
		startPos = input.Position
		lastPos = startPos
		this.UserPanningTheCamera = true
	end
	
	local function OnMouse2Up(input, processed)
		-- Check if they are in first-person
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
		
		panBeginLook = nil
		startPos = nil
		lastPos = nil
		this.UserPanningTheCamera = false
	end
	
	local function OnMouseMoved(input, processed)
		if startPos and lastPos and panBeginLook then
			local currPos = lastPos + input.Delta
			if this:IsInFirstPerson() then
				currPos = lastPos + input.Delta * this.Sensitivity
			end
			local totalTrans = currPos - startPos
			lastPos = currPos
			if this.PanEnabled then
				-- NOTE: we probably should not add the delta if we are already maxed out on the rotation angle.
				this:RotateCamera(panBeginLook, this:ScreenTranslationToAngle(totalTrans))
			end
		elseif this:IsInFirstPerson() or this:GetShiftLock() then
			if this.PanEnabled then
				this:RotateCamera(this:GetCameraLook(), this:ScreenTranslationToAngle(input.Delta))
			end
		end
	end
	
	local function OnMouseWheel(input, processed)
		if not processed then
			if this.ZoomEnabled then
				this:ZoomCameraBy(clamp(-1, 1, -input.Position.Z) * 1.4)
			end
		end
	end
	
	local function OnKeyDown(input, processed)
		if processed then return end
		if this.ZoomEnabled then
			if input.KeyCode == Enum.KeyCode.I then
				this:ZoomCameraBy(-5)
			elseif input.KeyCode == Enum.KeyCode.O then
				this:ZoomCameraBy(5)
			end
		end
		if panBeginLook == nil and this.KeyPanEnabled then
			if input.KeyCode == Enum.KeyCode.Left then
				this.TurningLeft = true
			elseif input.KeyCode == Enum.KeyCode.Right then
				this.TurningRight = true
			elseif input.KeyCode == Enum.KeyCode.Comma then
				this:RotateCamera(this:GetCameraLook(), Vector2.new(math.rad(-35),0))
				this.LastCameraTransform = nil
			elseif input.KeyCode == Enum.KeyCode.Period then
				this:RotateCamera(this:GetCameraLook(), Vector2.new(math.rad(35),0))
				this.LastCameraTransform = nil
			elseif input.KeyCode == Enum.KeyCode.PageUp then
			--elseif input.KeyCode == Enum.KeyCode.Home then
				this:RotateCamera(this:GetCameraLook(), Vector2.new(0,math.rad(15)))
				this.LastCameraTransform = nil
			elseif input.KeyCode == Enum.KeyCode.PageDown then
			--elseif input.KeyCode == Enum.KeyCode.End then
				this:RotateCamera(this:GetCameraLook(), Vector2.new(0,math.rad(-15)))
				this.LastCameraTransform = nil
			end
		end
	end
	
	local function OnKeyUp(input, processed)
		if input.KeyCode == Enum.KeyCode.Left then
			this.TurningLeft = false
		elseif input.KeyCode == Enum.KeyCode.Right then
			this.TurningRight = false
		end
	end
	
	function this:ConnectInputEvents()
		-- Mouse and Touch
		UserInputService.InputBegan:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchBegan(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
				OnMouse2Down(input, processed)
			end
		end)
		
		UserInputService.InputChanged:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchChanged(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseMovement then
				OnMouseMoved(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseWheel then
				OnMouseWheel(input, processed)
			end
		end)
		
		UserInputService.InputEnded:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchEnded(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
				OnMouse2Up(input, processed)
			end
		end)
		
		-- Keyboard
		UserInputService.InputBegan:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Keyboard then
				OnKeyDown(input, processed)
			end
		end)
		
		UserInputService.InputEnded:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Keyboard then
				OnKeyUp(input, processed)
			end
		end)
	end
	
	local function OnPlayerAdded(player)
		player.Changed:connect(function(prop)
			if prop == "CameraMode" or prop == "CameraMaxZoomDistance" or prop == "CameraMinZoomDistance" then
				 this:ZoomCameraBy(0)
			end
		end)
		
		local function OnCharacterAdded(newCharacter)
			this:ZoomCamera(10)
			local humanoid = findPlayerHumanoid(player)
			local start = tick()
			while tick() - start < 0.3 and (humanoid == nil or humanoid.Torso == nil) do
				wait()
				humanoid = findPlayerHumanoid(player)
			end
			local function setLookBehindChatacter()
				if humanoid and humanoid.Torso and player.Character == newCharacter then
					this.cameraLook = (humanoid.Torso.CFrame.lookVector - Vector3.new(0,0.7,0)).unit
					-- reset old camera info so follow cam doesn't rotate us
					this.LastCameraTransform = nil
				end
			end
			setLookBehindChatacter()
			-- The following code is to set the camera again after they have been rotated by the spawn point.
			local setLookVector = this:GetCameraLook()
			spawn(function()
				wait()
				if this:GetCameraLook() == setLookVector then
					setLookBehindChatacter()
				end
			end)
		end
		
		player.CharacterAdded:connect(OnCharacterAdded)
		if player.Character then
			spawn(function() OnCharacterAdded(player.Character) end)
		end
	end
	if PlayersService.LocalPlayer then
		OnPlayerAdded(PlayersService.LocalPlayer)
	end
	PlayersService.ChildAdded:connect(function(child)
		if child and PlayersService.LocalPlayer == child then
			OnPlayerAdded(PlayersService.LocalPlayer)
		end 
	end)
		
	return this
end

return CreateCamera
]]></ProtectedString>
			</Properties>
			<Item class="ModuleScript" referent="RBX8E297070D6FB43B284BECFC1635A1952">
				<Properties>
					<string name="Name">ClassicCamera</string>
					<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local UP_VECTOR = Vector3.new(0, 1, 0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	print("Trying to clamp when low:", low , "is larger than high:" , high , "returning input value.")
	return num
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

-- May return NaN or inf or -inf
-- This is a way of finding the angle between the two vectors:
local function findAngleBetweenXZVectors(vec2, vec1)
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function CreateClassicCamera()
	local module = RootCameraCreator()
	module:ConnectInputEvents()
	
	local tweenAcceleration = math.rad(250)
	local tweenSpeed = math.rad(0)
	local tweenMaxSpeed = math.rad(250)
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end	
		
		if lastUpdate then
			-- Cap out the delta to 0.5 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.5, now - lastUpdate)
			local angle = self.TurningLeft and -120 or 0
			angle = angle + (self.TurningRight and 120 or 0)			
			if angle ~= 0 then
				userPanningTheCamera = true
				self:RotateCamera(self:GetCameraLook(), Vector2.new(math.rad(angle * delta), 0))
			 end
		end

		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			tweenSpeed = 0
		end

		local subjectPosition = self:GetSubjectPosition()
		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			if self:GetShiftLock() and not self:IsInFirstPerson() then
				local offset = ((self:GetCameraLook() * XZ_VECTOR):Cross(UP_VECTOR).unit * 1.75)

				if IsFiniteVector3(offset) then
					subjectPosition = subjectPosition + offset
				end
				zoom = math.max(zoom, 5)
			else
				if self.LastCameraTransform and not userPanningTheCamera then
					local humanoid = self:GetHumanoid()
					local cameraSubject = camera and camera.CameraSubject
					local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
					local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
					if (isInVehicle or isOnASkateboard) and lastUpdate and humanoid and humanoid.Torso then
						local forwardVector = humanoid.Torso.CFrame.lookVector
						if isOnASkateboard then
							forwardVector = cameraSubject.CFrame.lookVector
						end
						local timeDelta = (now - lastUpdate)
						
						tweenSpeed = clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)

						local percent = clamp(0, 1, tweenSpeed * timeDelta)
						if self:IsInFirstPerson() then
							percent = 1
						end
						
						local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
						if IsFinite(y) and math.abs(y) > 0.0001 then
							self:RotateCamera(self:GetCameraLook(), Vector3.new(y * percent, 0, 0))
						end
					end
				end
			end
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		
		lastUpdate = now
	end
	
	return module
end

return CreateClassicCamera
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX21921F8C70F54CE3A7BC420D58664FB1">
				<Properties>
					<string name="Name">FixedCamera</string>
					<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)


local function CreateFixedCamera()
	local module = RootCameraCreator()
	module:ConnectInputEvents()
	module.PanEnabled = false
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end
		
		local subjectPosition = self:GetSubjectPosition()		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end
	
	return module
end

return CreateFixedCamera
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX150EA58A8D324A629936D38BFEBB0F62">
				<Properties>
					<string name="Name">FollowCamera</string>
					<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local UP_VECTOR = Vector3.new(0, 1, 0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	print("Trying to clamp when low:", low , "is larger than high:" , high , "returning input value.")
	return num
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

-- May return NaN or inf or -inf
local function findAngleBetweenXZVectors(vec2, vec1)
	-- This is a way of finding the angle between the two vectors:
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function CreateFollowCamera()
	local module = RootCameraCreator()	
	module:ConnectInputEvents()
	
	local tweenAcceleration = math.rad(250)
	local tweenSpeed = math.rad(0)
	local tweenMaxSpeed = math.rad(250)
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer

		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end
		
		if lastUpdate then
			-- Cap out the delta to 0.5 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.5, now - lastUpdate)
			local angle = self.TurningLeft and -120 or 0
			angle = angle + (self.TurningRight and 120 or 0)
			if angle ~= 0 then
				userPanningTheCamera = true
				self:RotateCamera(self:GetCameraLook(), Vector2.new(math.rad(angle * delta), 0))
			end
		end
		
		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			tweenSpeed = 0
		end
		
		local subjectPosition = self:GetSubjectPosition()		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			if self:GetShiftLock() and not self:IsInFirstPerson() then
				local offset = ((self:GetCameraLook() * XZ_VECTOR):Cross(UP_VECTOR).unit * 1.75)
				-- Check for NaNs
				if IsFiniteVector3(offset) then
					subjectPosition = subjectPosition + offset
				end
				zoom = math.max(zoom, 5)
			else
				if self.LastCameraTransform and not userPanningTheCamera then
					local humanoid = self:GetHumanoid()
					local cameraSubject = camera and camera.CameraSubject
					local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
					local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
					local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
					if (isClimbing or isInVehicle or isOnASkateboard) and lastUpdate and humanoid and humanoid.Torso then
						local forwardVector = humanoid.Torso.CFrame.lookVector
						if isOnASkateboard then
							forwardVector = cameraSubject.CFrame.lookVector
						end
						local timeDelta = (now - lastUpdate)
						
						tweenSpeed = clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
						
						local percent = clamp(0, 1, tweenSpeed * timeDelta)
						if not isClimbing and self:IsInFirstPerson() then
							percent = 1
						end
						local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
						-- Check for NaN
						if IsFinite(y) and math.abs(y) > 0.0001 then
							self:RotateCamera(self:GetCameraLook(), Vector3.new(y * percent, 0, 0))
						end
					elseif not self:IsInFirstPerson() then
						local lastVec = -(self.LastCameraTransform.p - subjectPosition)
						local y = findAngleBetweenXZVectors(lastVec, self:GetCameraLook())
						-- Check for NaNs
						if IsFinite(y) and math.abs(y) > 0.0001 then
							self:RotateCamera(self:GetCameraLook(), Vector3.new(y, 0, 0))
						end
					end
				end
			end
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		
		lastUpdate = now
	end
	
	return module
end

return CreateFollowCamera
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE34AE3F4F8DE4D898D10817C4C5407A4">
				<Properties>
					<string name="Name">WatchCamera</string>
					<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)


local function CreateWatchCamera()
	local module = RootCameraCreator()
	module:ConnectInputEvents()
	module.PanEnabled = false
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
			self.LastZoom = nil
		end	
		
		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player and camera then		
			if self.LastCameraTransform then
				local humanoid = self:GetHumanoid()
				if humanoid and humanoid.Torso then
					-- TODO: let the paging buttons move the camera but not the mouse/touch
					-- currently neither do
					local diffVector = subjectPosition - self.LastCameraTransform.p
					self.cameraLook = diffVector.unit
					
					if self.LastZoom and self.LastZoom == self:GetCameraZoom() then
						-- Don't clobber the zoom if they zoomed the camera
						local zoom = diffVector.magnitude
						self:ZoomCamera(zoom)
					end
				end
			end
			
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
			self.LastZoom = zoom
		end
		lastUpdate = now
	end
	
	return module
end

return CreateWatchCamera
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5551245BED194A73A6D7F0ECB0AB2919">
				<Properties>
					<string name="Name">TrackCamera</string>
					<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local function CreateTrackCamera()
	local module = RootCameraCreator()
	module:ConnectInputEvents()
	module.PanEnabled = false

	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end	
		
		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * self:GetCameraLook()), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end
	
	return module
end

return CreateTrackCamera
]]></ProtectedString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9F55333BECE94760BEFB226DD1D7CB34">
				<Properties>
					<string name="Name">ScriptableCamera</string>
					<ProtectedString name="Source"><![CDATA[local RootCameraCreator = require(script.Parent)

local function CreateScriptableCamera()
	local module = RootCameraCreator()
	
	local lastUpdate = tick()
	function module:Update()
	end
	
	return module
end

return CreateScriptableCamera
]]></ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXC64AD6B8C8164B2DA2A8AE5F238B7943">
			<Properties>
				<string name="Name">Invisicam</string>
				<ProtectedString name="Source"><![CDATA[-- Invisicam Version 2.5 (Occlusion Series)
-- For the latest standalone version see id=183837794
-- OnlyTwentyCharacters

local Invisicam = {}

---------------
-- Constants --
---------------

local FADE_TARGET = 0.75
local FADE_RATE = 0.1

local MODE = {
	CUSTOM = 1, -- Whatever you want!
	LIMBS = 2, -- Track limbs
	MOVEMENT = 3, -- Track movement
	CORNERS = 4, -- Char model corners
	CIRCLE1 = 5, -- Circle of casts around character
	CIRCLE2 = 6, -- Circle of casts around character, camera relative
	LIMBMOVE = 7, -- LIMBS mode + MOVEMENT mode
}
Invisicam.MODE = MODE

local STARTING_MODE = MODE.LIMBS

local LIMB_TRACKING_SET = {
	['Head'] = true,
	['Left Arm'] = true,
	['Right Arm'] = true,
	['Left Leg'] = true,
	['Right Leg'] = true,
}
local CORNER_FACTORS = {
	Vector3.new(1, 1, -1),
	Vector3.new(1, -1, -1),
	Vector3.new(-1, -1, -1),
	Vector3.new(-1, 1, -1)
}
local CIRCLE_CASTS = 10
local MOVE_CASTS = 3

---------------
-- Variables --
---------------

local RunService = game:GetService('RunService')
local PlayersService = game:GetService('Players')
local Player = PlayersService.LocalPlayer

local Camera = nil
local Character = nil
local Torso = nil

local Mode = nil
local Behaviors = {} -- Map of modes to behavior fns
local SavedHits = {} -- Objects currently being faded in/out
local TrackedLimbs = {} -- Used in limb-tracking casting modes

---------------
--| Utility |--
---------------

local function AssertTypes(param, ...)
	local allowedTypes = {}
	local typeString = ''
	for _, typeName in pairs({...}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end

local function CameraCast(worldPoint, ignoreList)
	local cameraPoint = Camera.CoordinateFrame.p
	local vector = worldPoint - cameraPoint
	local ray = Ray.new(cameraPoint, vector.Unit * math.min(vector.Magnitude, 999))
	return workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
end

-----------------------
--| Local Functions |--
-----------------------

local function LimbBehavior(castPoints)
	for _, limb in pairs(TrackedLimbs) do
		if limb.Parent then
			table.insert(castPoints, limb.Position)
		end
	end
end

local function MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = Torso.Position, Torso.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * Torso.CFrame.lookVector * horizontalSpeed
		table.insert(castPoints, position + offsetVector)
	end
end

local function CornerBehavior(castPoints)
	local cframe = Torso.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = Character:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
	table.insert(castPoints, centerPoint)
	for _, factor in pairs(CORNER_FACTORS) do
		table.insert(castPoints, centerPoint + (rotation * (halfSize * factor)))
	end
end

local function CircleBehavior(castPoints)
	local cframe = nil
	if Mode == MODE.CIRCLE1 then
		cframe = Torso.CFrame
	else
		local camCFrame = Camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + Torso.Position
	end
	table.insert(castPoints, cframe.p)
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = (2 * math.pi / CIRCLE_CASTS) * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		table.insert(castPoints, cframe * offset)
	end
end

local function LimbMoveBehavior(castPoints)
	LimbBehavior(castPoints)
	MoveBehavior(castPoints)
end

local function OnCharacterAdded(character)
	Character = character
	Torso = Character:WaitForChild('Torso')
	
	TrackedLimbs = {}
	for _, child in pairs(Character:GetChildren()) do
		if child:IsA('BasePart') and LIMB_TRACKING_SET[child.Name] then
			table.insert(TrackedLimbs, child)
		end
	end
end

local function OnWorkspaceChanged(property)
	if property == 'CurrentCamera' then
		local newCamera = workspace.CurrentCamera
		if newCamera then
			Camera = newCamera
		end
	end
end

-----------------------
-- Exposed Functions --
-----------------------

-- Update. Called every frame after the camera movement step
function Invisicam:Update()
	-- Make a list of world points to raycast to
	local castPoints = {}
	Behaviors[Mode](castPoints)
	
	-- Cast to get a list of objects between the camera and the cast points
	local currentHits = {}
	local ignoreList = {Character}
	local function add(hit)
		currentHits[hit] = true
		if not SavedHits[hit] then
			SavedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	for _, worldPoint in pairs(castPoints) do
		repeat
			local hitPart = CameraCast(worldPoint, ignoreList)
			if hitPart then
				add(hitPart)
				for _, child in pairs(hitPart:GetChildren()) do
					if child:IsA('Decal') or child:IsA('Texture') then
						add(child)
					end
				end
				table.insert(ignoreList, hitPart) -- Next ray will go through this part
			end
		until not hitPart
	end
	
	-- Fade out objects that are in the way, restore those that aren't anymore
	for hit, originalFade in pairs(SavedHits) do
		local currentFade = hit.LocalTransparencyModifier
		if currentHits[hit] then -- Fade
			if currentFade < FADE_TARGET then
				hit.LocalTransparencyModifier = math.min(currentFade + FADE_RATE, FADE_TARGET)
			end
		else -- Restore
			if currentFade > originalFade then
				hit.LocalTransparencyModifier = math.max(originalFade, currentFade - FADE_RATE)
			else
				SavedHits[hit] = nil
			end
		end
	end
end

function Invisicam:SetMode(newMode)
	AssertTypes(newMode, 'number')
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			Mode = newMode
			return
		end
	end
	error("Invalid mode number")
end

function Invisicam:SetCustomBehavior(func)
	AssertTypes(func, 'function')
	Behaviors[MODE.CUSTOM] = func
end

-- Want to turn off Invisicam? Be sure to call this after.
function Invisicam:Cleanup()
	for hit, originalFade in pairs(SavedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end

---------------------
--| Running Logic |--
---------------------

-- Connect to the current and all future cameras
workspace.Changed:connect(OnWorkspaceChanged)
OnWorkspaceChanged('CurrentCamera')

Player.CharacterAdded:connect(OnCharacterAdded)
if Player.Character then
	OnCharacterAdded(Player.Character)
end

Invisicam:SetMode(STARTING_MODE)

Behaviors[MODE.CUSTOM] = function() end -- (Does nothing until SetCustomBehavior)
Behaviors[MODE.LIMBS] = LimbBehavior
Behaviors[MODE.MOVEMENT] = MoveBehavior
Behaviors[MODE.CORNERS] = CornerBehavior
Behaviors[MODE.CIRCLE1] = CircleBehavior
Behaviors[MODE.CIRCLE2] = CircleBehavior
Behaviors[MODE.LIMBMOVE] = LimbMoveBehavior

return Invisicam
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXF48FD55ED2A9493F8077A9AB5DCFBC12">
			<Properties>
				<string name="Name">ClickToMove</string>
				<ProtectedString name="Source"><![CDATA[-- Written By Kip Turner, Copyright Roblox 2014


local UIS = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local PlayerService = game:GetService("Players")
local RunService = game:GetService("RunService")
local DebrisService = game:GetService('Debris')
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local CameraScript = script.Parent
local ClassicCameraModule = require(CameraScript:WaitForChild('RootCamera'):WaitForChild('ClassicCamera'))

local Player = PlayerService.localPlayer
local MyMouse = Player:GetMouse()


local DirectPathEnabled = false
local SHOW_PATH = false

local RayCastIgnoreList = workspace.FindPartOnRayWithIgnoreList
local GetPartsTouchingExtents = workspace.FindPartsInRegion3

-- Bindable for when we want touch emergency controls
-- TODO: Click to move should probably have it's own gui touch controls
-- to manage this.
local BindableEvent_OnFailStateChanged = nil
if UIS.TouchEnabled then
	BindableEvent_OnFailStateChanged = Instance.new('BindableEvent')
	BindableEvent_OnFailStateChanged.Name = "OnClickToMoveFailStateChange"
	local CameraScript = script.Parent
	local PlayerScripts = CameraScript.Parent
	BindableEvent_OnFailStateChanged.Parent = PlayerScripts
end


--------------------------UTIL LIBRARY-------------------------------
local Utility = {}
do
	local Signal = {}

	function Signal.Create()
		local sig = {}
		
		local mSignaler = Instance.new('BindableEvent')
		
		local mArgData = nil
		local mArgDataCount = nil
		
		function sig:fire(...)
			mArgData = {...}
			mArgDataCount = select('#', ...)
			mSignaler:Fire()
		end
		
		function sig:connect(f)
			if not f then error("connect(nil)", 2) end
			return mSignaler.Event:connect(function()
				f(unpack(mArgData, 1, mArgDataCount))
			end)
		end
		
		function sig:wait()
			mSignaler.Event:wait()
			assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
			return unpack(mArgData, 1, mArgDataCount)
		end
		
		return sig
	end
	Utility.Signal = Signal
	
	function Utility.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				else
					obj[k] = v
				end
			end
			return obj
		end
	end
	
	local function clamp(low, high, num)
		return math.max(math.min(high, num), low)
	end
	Utility.Clamp = clamp
	
	local function ViewSizeX()
		local x = MyMouse and MyMouse.ViewSizeX or 0
		local y = MyMouse and MyMouse.ViewSizeY or 0
		if x == 0 then
			return 1024
		else
			if x > y then
				return x
			else
				return y
			end
		end
	end
	Utility.ViewSizeX = ViewSizeX
	
	local function ViewSizeY()
		local x = MyMouse and MyMouse.ViewSizeX or 0
		local y = MyMouse and MyMouse.ViewSizeY or 0
		if y == 0 then
			return 768
		else
			if x > y then
				return y
			else
				return x
			end
		end
	end
	Utility.ViewSizeY = ViewSizeY
	
	local function AspectRatio()
		return ViewSizeX() / ViewSizeY()
	end
	Utility.AspectRatio = AspectRatio
	
	local function FindChacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChild("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindChacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindChacterAncestor = FindChacterAncestor
	
	
	local NEAR_CLIP_PLANE_OFFSET = 0.5
	local function ScreenToWorld(screenPoint, screenSize, pushDepth, camera)
		local cameraFOV, cameraCFrame = camera.FieldOfView, camera.CoordinateFrame
		local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(cameraFOV) / 2))
		local direction = Vector3.new(screenPoint.x - (screenSize.x / 2), (screenSize.y / 2) - screenPoint.y, -imagePlaneDepth)
		local worldDirection = (cameraCFrame:vectorToWorldSpace(direction)).Unit
		local theta = math.acos(math.min(1, worldDirection:Dot(cameraCFrame.lookVector)))
		local fixedPushDepth = pushDepth / math.sin((math.pi / 2) - theta)
		return cameraCFrame.p + worldDirection * fixedPushDepth, worldDirection
	end
	local function GetUnitRay(x, y, viewWidth, viewHeight, camera)
		
		local rayOrigin, rayDirection = ScreenToWorld(Vector2.new(x,y), Vector2.new(viewWidth, viewHeight), NEAR_CLIP_PLANE_OFFSET, camera)
		
		return Ray.new(rayOrigin, rayDirection.unit);
	end
	Utility.GetUnitRay = GetUnitRay
	
	local RayCastIgnoreList = workspace.FindPartOnRayWithIgnoreList
	local function Raycast(ray, ignoreNonCollidable, ignoreList)
		local ignoreList = ignoreList or {}
		local hitPart, hitPos = RayCastIgnoreList(workspace, ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				table.insert(ignoreList, hitPart)
				return Raycast(ray, ignoreNonCollidable, ignoreList)
			end
			return hitPart, hitPos
		end
		return nil, nil
	end
	Utility.Raycast = Raycast
	
	
	Utility.Round = function(num, roundToNearest)
		roundToNearest = roundToNearest or 1
		return math.floor((num + roundToNearest/2) / roundToNearest) * roundToNearest
	end
	
	local function AveragePoints(positions)
		local avgPos = Vector2.new(0,0)
		if #positions > 0 then
			for i = 1, #positions do
				avgPos = avgPos + positions[i]
			end
			avgPos = avgPos / #positions
		end
		return avgPos
	end
	Utility.AveragePoints = AveragePoints
	
	local function FuzzyEquals(numa, numb)
		return numa + 0.1 > numb and numa - 0.1 < numb
	end
	Utility.FuzzyEquals = FuzzyEquals
	
	local LastInput = 0
	UIS.InputBegan:connect(function(inputObject, wasSunk)
		if not wasSunk then
			if inputObject.UserInputType == Enum.UserInputType.Touch or
					inputObject.UserInputType == Enum.UserInputType.MouseButton1 or
					inputObject.UserInputType == Enum.UserInputType.MouseButton2 then
				LastInput = tick()
			end
		end
	end)
	Utility.GetLastInput = function()
		return LastInput
	end
end

local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					humanoidCache[player] = child
					return child
				end
			end
		end
	end
end

local function CFrameInterpolator(c0, c1) -- (CFrame from, CFrame to) -> (float theta, (float fraction -> CFrame between))
	local fromAxisAngle = CFrame.fromAxisAngle
	local components = CFrame.new().components
	local inverse = CFrame.new().inverse
	local v3 = Vector3.new
	local acos = math.acos
	local sqrt = math.sqrt
	local invroot2 = 1 / math.sqrt(2)
	-- The expanded matrix
	local _, _, _, xx, yx, zx, 
	               xy, yy, zy, 
	               xz, yz, zz = components(inverse(c0)*c1)
	-- The cos-theta of the axisAngles from 
	local cosTheta = (xx + yy + zz - 1)/2
	-- Rotation axis
	local rotationAxis = v3(yz-zy, zx-xz, xy-yx)
	-- The position to tween through
	local positionDelta = (c1.p - c0.p)
	-- Theta
	local theta;			
	-- Catch degenerate cases
	if cosTheta >= 0.999 then
		-- Case same rotation, just return an interpolator over the positions
		return 0, function(t)
			return c0 + positionDelta*t
		end	
	elseif cosTheta <= -0.999 then
		-- Case exactly opposite rotations, disambiguate
		theta = math.pi
		xx = (xx + 1) / 2
		yy = (yy + 1) / 2
		zz = (zz + 1) / 2
		if xx > yy and xx > zz then
			if xx < 0.001 then
				rotationAxis = v3(0, invroot2, invroot2)
			else
				local x = sqrt(xx)
				xy = (xy + yx) / 4
				xz = (xz + zx) / 4
				rotationAxis = v3(x, xy/x, xz/x)
			end
		elseif yy > zz then
			if yy < 0.001 then
				rotationAxis = v3(invroot2, 0, invroot2)
			else
				local y = sqrt(yy)
				xy = (xy + yx) / 4
				yz = (yz + zy) / 4
				rotationAxis = v3(xy/y, y, yz/y)
			end	
		else
			if zz < 0.001 then
				rotationAxis = v3(invroot2, invroot2, 0)
			else
				local z = sqrt(zz)
				xz = (xz + zx) / 4
				yz = (yz + zy) / 4
				rotationAxis = v3(xz/z, yz/z, z)
			end
		end
	else
		-- Normal case, get theta from cosTheta
		theta = acos(cosTheta)
	end
	-- Return the interpolator
	return theta, function(t)
		return c0*fromAxisAngle(rotationAxis, theta*t) + positionDelta*t
	end
end
---------------------------------------------------------

local Signal = Utility.Signal
local Create = Utility.Create

--------------------------CHARACTER CONTROL-------------------------------
local function CreateController()
	local this = {}

	this.TorsoLookPoint = nil
	
	function this:SetTorsoLookPoint(point)
		local humanoid = findPlayerHumanoid(Player)
		if humanoid then
			humanoid.AutoRotate = false
		end
		this.TorsoLookPoint = point
		self:UpdateTorso()
		delay(2,
			function()
			-- this isnt technically correct for detecting if this is the last issue to the setTorso function
			if this.TorsoLookPoint == point then
				this.TorsoLookPoint = nil
				if humanoid then
					humanoid.AutoRotate = true
				end
			end
		end)
	end
	
	function this:UpdateTorso(point)
		if this.TorsoLookPoint then
			point = this.TorsoLookPoint
		else
			return
		end
		
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			local lookVec = (point - torso.CFrame.p).unit
			local squashedLookVec = Vector3.new(lookVec.X, 0, lookVec.Z).unit
			torso.CFrame = CFrame.new(torso.CFrame.p, torso.CFrame.p + squashedLookVec)
		end
	end
	
	return this
end

local CharacterControl = CreateController()
-----------------------------------------------------------------------

--------------------------PC AUTO JUMPER-------------------------------

local function GetCharacter()
	return Player and Player.Character
end

local function GetTorso()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid and humanoid.Torso
end

local function IsPartAHumanoid(part)
	return part and part.Parent and (part.Parent:FindFirstChild('Humanoid') ~= nil)
end

local function doAutoJump()
	local character = GetCharacter()
	if (character == nil) then
		return;
	end
	
	local humanoid = findPlayerHumanoid(Player)
	if (humanoid == nil) then
		return;
	end

	local rayLength = 1.5; 
	-- This is how high a ROBLOXian jumps from the mid point of his torso 
	local jumpHeight = 7.0; 

	local torso = GetTorso()
	if (torso == nil) then
		return; 
	end

	local torsoCFrame = torso.CFrame;
	local torsoLookVector = torsoCFrame.lookVector; 
	local torsoPos = torsoCFrame.p; 

	local torsoRay = Ray.new(torsoPos + Vector3.new(0, -torso.Size.Y/2, 0), torsoLookVector * rayLength); 
	local jumpRay = Ray.new(torsoPos + Vector3.new(0, jumpHeight - torso.Size.Y, 0), torsoLookVector * rayLength); 
		
	local hitPart, _ = RayCastIgnoreList(workspace, torsoRay, {character}, false)
	local jumpHitPart, _ = RayCastIgnoreList(workspace, jumpRay, {character}, false)

	if (hitPart and jumpHitPart == nil and hitPart.CanCollide == true) then
		 -- NOTE: this follow line is not in the C++ impl, but an improvement  in Click to Move
		if not IsPartAHumanoid(hitPart) then
			humanoid.Jump = true;
		end
	end
end

local NO_JUMP_STATES = 
{
	[Enum.HumanoidStateType.FallingDown] = false;
	[Enum.HumanoidStateType.Flying] = false;
	[Enum.HumanoidStateType.Freefall] = false;
	[Enum.HumanoidStateType.GettingUp] = false;
	[Enum.HumanoidStateType.Ragdoll] = false;
	[Enum.HumanoidStateType.Running] = false;
	[Enum.HumanoidStateType.Seated] = false;
	[Enum.HumanoidStateType.Swimming] = false;
	
	-- Special case to detect if we are on a ladder
	[Enum.HumanoidStateType.Climbing] = false;
}

local function enableAutoJump()
	local humanoid = findPlayerHumanoid(Player)
	local currentState = humanoid and humanoid:GetState()
	if currentState then
		return NO_JUMP_STATES[currentState] == nil
	end
	return false
end

local function getAutoJump()
	return true
end

local function vec3IsZero(vec3)
	return vec3.magnitude < 0.05
end

-- NOTE: This function is radically different from the engine's implementation
local function calcDesiredWalkVelocity()
	-- TEMP
	return Vector3.new(1,1,1)
end

local function preStepSimulatorSide(dt)
	if getAutoJump() and enableAutoJump() then
		local desiredWalkVelocity = calcDesiredWalkVelocity();
		if (not vec3IsZero(desiredWalkVelocity)) then
			doAutoJump(); 
		end
	end
end

local function AutoJumper()
	local this = {}
	local running = false
	local runRoutine = nil
	
	function this:Run()
		running = true
		local thisRoutine = nil
		thisRoutine = coroutine.create(function()
			while running and thisRoutine == runRoutine do
				this:Step()
				wait()
			end
		end)
		runRoutine = thisRoutine
		coroutine.resume(thisRoutine)
	end
	
	function this:Stop()
		running = false
	end
	
	function this:Step()
		preStepSimulatorSide()
	end
	
	return this
end

-----------------------------------------------------------------------------

-----------------------------------PATHER--------------------------------------

local function CreateDestinationIndicator(pos)
	local destinationGlobe = Create'Part'
	{
		Name = 'PathGlobe';
		TopSurface = 'Smooth';
		BottomSurface = 'Smooth';
		Shape = 'Ball';
		CanCollide = false;
		Size = Vector3.new(2,2,2);
		BrickColor = BrickColor.new('Institutional white');
		Transparency = 0;
		Anchored = true;
		CFrame = CFrame.new(pos);
	}
	return destinationGlobe
end

local function Pather(character, point)
	local this = {}
	
	this.Cancelled = false
	this.Started = false
	
	this.Finished = Signal.Create()
	this.PathFailed = Signal.Create()
	this.PathStarted = Signal.Create()

	this.PathComputed = false
	
	function this:YieldUntilPointReached(character, point, timeout)
		timeout = timeout or 10000000
		
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		local start = tick()
		local lastMoveTo = start
		while torso and tick() - start < timeout and this.Cancelled == false do
			local diffVector = (point - torso.CFrame.p)
			local xzMagnitude = (diffVector * Vector3.new(1,0,1)).magnitude
			if xzMagnitude < 6 then 
				-- Jump if the path is telling is to go upwards
				if diffVector.Y >= 2 then
					humanoid.Jump = true
				end
			end
			-- The hard-coded number 2 here is from the engine's MoveTo implementation
			if xzMagnitude < 2 then
				return true
			end
			-- Keep on issuing the move command because it will automatically quit every so often.
			if tick() - lastMoveTo > 1.5 then
				humanoid:MoveTo(point)
				lastMoveTo = tick()
			end
			CharacterControl:UpdateTorso(point)
			wait()
		end
		return false
	end
	
	function this:Cancel()
		this.Cancelled = true
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if humanoid and torso then
			humanoid:MoveTo(torso.CFrame.p)
		end
	end
	
	function this:CheckOcclusion(point1, point2, character, torsoRadius)
		--print("Point1" , point1 , "point2" , point2)
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torsoRadius == nil then
			torsoRadius = torso and Vector3.new(torso.Size.X/2,0,torso.Size.Z/2) or Vector3.new(1,0,1)
		end
		
		local diffVector = point2 - point1
		local directionVector = diffVector.unit
		
		local rightVector = Vector3.new(0,1,0):Cross(directionVector) * torsoRadius
		
		local rightPart, _ = Utility.Raycast(Ray.new(point1 + rightVector, diffVector + rightVector), true, {character})
		local hitPart, _ = Utility.Raycast(Ray.new(point1, diffVector), true, {character})
		local leftPart, _ = Utility.Raycast(Ray.new(point1 - rightVector, diffVector - rightVector), true, {character})
		
		if rightPart or hitPart or leftPart then
			return false
		end
		
		-- Make sure we have somewhere to stand on
		local midPt = (point2 + point1) / 2
		local studsBetweenSamples = 2
		for i = 1, math.floor(diffVector.magnitude/studsBetweenSamples) do
			local downPart, _ = Utility.Raycast(Ray.new(point1 + directionVector * i * studsBetweenSamples, Vector3.new(0,-7,0)), true, {character})
			if not downPart then
				return false
			end
		end
		
		return true
	end
	
	function this:SmoothPoints(pathToSmooth)
		local result = {}
		
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		for i = 1, #pathToSmooth do
			table.insert(result, pathToSmooth[i])
		end
		
		-- Backwards for safe-deletion
		for i = #result - 1, 1, -1 do
			if i + 1 <= #result then
				
				local nextPoint = result[i+1]				
				local thisPoint = result[i]
				
				local lastPoint = result[i-1]
				if lastPoint == nil then
					lastPoint = torso and Vector3.new(torso.CFrame.p.X, thisPoint.Y, torso.CFrame.p.Z)
				end
				
				if lastPoint and Utility.FuzzyEquals(thisPoint.Y, lastPoint.Y) and Utility.FuzzyEquals(thisPoint.Y, nextPoint.Y) then
					if this:CheckOcclusion(lastPoint, nextPoint, character) then
						table.remove(result, i)
						-- Move i back one to recursively-smooth
						i = i + 1
					end
				end
			end
		end
		
		return result
	end
	
	function this:CheckNeighboringCells(character)
		local pathablePoints = {}
		local humanoid = findPlayerHumanoid(Player)
		local torso = character and humanoid and humanoid.Torso
		if torso then
			local torsoCFrame = torso.CFrame
			local torsoPos = torsoCFrame.p
			-- Minus and plus 2 is so we can get it into the cell-corner space and then translate it back into cell-center space
			local roundedPos = Vector3.new(Utility.Round(torsoPos.X-2,4)+2, Utility.Round(torsoPos.Y-2,4)+2, Utility.Round(torsoPos.Z-2,4)+2)
			local neighboringCells = {}
			for x = -4, 4, 8 do
				for z = -4, 4, 8 do
					table.insert(neighboringCells, roundedPos + Vector3.new(x,0,z))
				end
			end
			for _, testPoint in pairs(neighboringCells) do
				local pathable = this:CheckOcclusion(roundedPos, testPoint, character, Vector3.new(0,0,0))
				if pathable then
					table.insert(pathablePoints, testPoint)
				end
			end
		end
		return pathablePoints
	end
	
	function this:ComputeDirectPath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			local startPt = torso.CFrame.p
			local finishPt = point
			if (finishPt - startPt).magnitude < 150 then
				-- move back the destination by 2 studs or otherwise the pather will collide with the object we are trying to reach
				finishPt = finishPt - (finishPt - startPt).unit * 2
				if this:CheckOcclusion(startPt, finishPt, character, Vector3.new(0,0,0)) then
					local pathResult = {}
					pathResult.Status = Enum.PathStatus.Success
					function pathResult:GetPointCoordinates()
						return {finishPt}
					end
					return pathResult
				end
			end
		end
	end
	
	local function AllAxisInThreshhold(targetPt, otherPt, threshold)
		return math.abs(targetPt.X - otherPt.X) <= threshold and 
			math.abs(targetPt.Y - otherPt.Y) <= threshold and
			math.abs(targetPt.Z - otherPt.Z) <= threshold
	end
	
	function this:ComputePath()
		local smoothed = false
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			if this.PathComputed then return end
			this.PathComputed = true
			-- Will yield the script since it is an Async script (start, finish, maxDistance)
			-- Try to use the smooth function, but it may not exist yet :(
			local success = pcall(function()
				this.pathResult = PathfindingService:ComputeSmoothPathAsync(torso.CFrame.p, point, 400)
				smoothed = true
			end)
			if not success then
				this.pathResult = PathfindingService:ComputeRawPathAsync(torso.CFrame.p, point, 400)
				smoothed = false
			end
			this.pointList = this.pathResult and this.pathResult:GetPointCoordinates()
			local pathFound = false
			if this.pathResult.Status == Enum.PathStatus.FailFinishNotEmpty then
				-- Lets try again with a slightly set back start point; it is ok to do this again so the FailFinishNotEmpty uses little computation
				local diffVector = point - workspace.CurrentCamera.CoordinateFrame.p
				if diffVector.magnitude > 2 then
					local setBackPoint = point - (diffVector).unit * 2.1
					local success = pcall(function()
						this.pathResult = PathfindingService:ComputeSmoothPathAsync(torso.CFrame.p, setBackPoint, 400)
						smoothed = true
					end)
					if not success then
						this.pathResult = PathfindingService:ComputeRawPathAsync(torso.CFrame.p, setBackPoint, 400)
						smoothed = false
					end
					this.pointList = this.pathResult and this.pathResult:GetPointCoordinates()
					pathFound = true
				end
			end
			if this.pathResult.Status == Enum.PathStatus.ClosestNoPath and #this.pointList >= 1 and pathFound == false then
				local otherPt = this.pointList[#this.pointList]
				if AllAxisInThreshhold(point, otherPt, 4) and (torso.CFrame.p - point).magnitude > (otherPt - point).magnitude then
					local pathResult = {}
					pathResult.Status = Enum.PathStatus.Success
					function pathResult:GetPointCoordinates()
						return {this.pointList}
					end
					this.pathResult = pathResult
					pathFound = true
				end
			end
			if (this.pathResult.Status == Enum.PathStatus.FailStartNotEmpty or this.pathResult.Status == Enum.PathStatus.ClosestNoPath) and pathFound == false then
				local pathablePoints = this:CheckNeighboringCells(character)
				for _, otherStart in pairs(pathablePoints) do
					local pathResult;
					local success = pcall(function()
						pathResult = PathfindingService:ComputeSmoothPathAsync(otherStart, point, 400)
						smoothed = true
					end)
					if not success then
						pathResult = PathfindingService:ComputeRawPathAsync(otherStart, point, 400)
						smoothed = false
					end
					if pathResult and pathResult.Status == Enum.PathStatus.Success then
						this.pathResult = pathResult
						if this.pathResult then
							this.pointList = this.pathResult:GetPointCoordinates()
							table.insert(this.pointList, 1, otherStart)
						end
						break
					end
				end
			end
			if DirectPathEnabled then
				if this.pathResult.Status ~= Enum.PathStatus.Success then
					local directPathResult = this:ComputeDirectPath()
					if directPathResult and directPathResult.Status == Enum.PathStatus.Success then
						this.pathResult = directPathResult
						this.pointList = directPathResult:GetPointCoordinates()
					end
				end
			end
		end
		return smoothed
	end
	
	function this:IsValidPath()
		this:ComputePath()
		local pathStatus = this.pathResult.Status
		return pathStatus == Enum.PathStatus.Success
	end
	
	function this:GetPathStatus()
		this:ComputePath()
		return this.pathResult.Status
	end
		
	function this:Start()
		spawn(function()
			local humanoid = findPlayerHumanoid(Player)
			--humanoid.AutoRotate = false
			local torso = humanoid and humanoid.Torso
			if torso then		
				if this.Started then return end
				this.Started = true
				-- Will yield the script since it is an Async function script (start, finish, maxDistance)
				local smoothed = this:ComputePath()
				if this:IsValidPath() then
					this.PathStarted:fire()
					-- smooth out zig-zaggy paths
					local smoothPath = smoothed and this.pointList or this:SmoothPoints(this.pointList)
					for i, point in pairs(smoothPath) do
						if humanoid then
							if this.Cancelled then
								return
							end
							
							local wayPoint = nil
							if SHOW_PATH then
								wayPoint = CreateDestinationIndicator(point)
								wayPoint.BrickColor = BrickColor.new("New Yeller")
								wayPoint.Parent = workspace
							end
							
							humanoid:MoveTo(point)
														
							local distance = ((torso.CFrame.p - point) * Vector3.new(1,0,1)).magnitude
							local approxTime = 10
							if math.abs(humanoid.WalkSpeed) > 0 then
								approxTime = distance / math.abs(humanoid.WalkSpeed)
							end
							
							local yielding = true
							
							if i == 1 then
								--local rotatedCFrame = CameraModule:LookAtPreserveHeight(point)
								if CameraModule then
									local rotatedCFrame = CameraModule:LookAtPreserveHeight(smoothPath[#smoothPath])
									local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
								end
								--CharacterControl:SetTorsoLookPoint(point)
							end
							---[[
							if (humanoid.Torso.CFrame.p - point).magnitude > 9 then
								spawn(function()
									while yielding and this.Cancelled == false do
										if CameraModule then
											local look = CameraModule:GetCameraLook()
											local squashedLook = (look * Vector3.new(1,0,1)).unit
											local direction = ((point - workspace.CurrentCamera.CoordinateFrame.p) * Vector3.new(1,0,1)).unit
											
											local theta = math.deg(math.acos(squashedLook:Dot(direction)))
											
											if tick() - Utility.GetLastInput() > 2 and theta > (workspace.CurrentCamera.FieldOfView / 2) then
												local rotatedCFrame = CameraModule:LookAtPreserveHeight(point)
												local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
												--return
											end
										end
										wait(0.1)
									end
								end)
							end
							--]]
							local didReach = this:YieldUntilPointReached(character, point, approxTime * 3 + 1)
							
							yielding = false
							
							if SHOW_PATH then
								wayPoint:Destroy()
							end
							
							if not didReach then
								this.PathFailed:fire()
								return
							end
						end
					end
					
					this.Finished:fire()
					return
				end
			end
			this.PathFailed:fire()
		end)
	end
	
	return this
end

-------------------------------------------------------------------------

local function FlashRed(object)
	local origColor = object.BrickColor
	local redColor = BrickColor.new("Really red")
	local start = tick()
	local duration = 4
	spawn(function()
		while object and tick() - start < duration do
			object.BrickColor = origColor
			wait(0.13)
			if object then
				object.BrickColor = redColor
			end
			wait(0.13)
		end
	end)
end

local joystickWidth = 250
local joystickHeight = 250
local function IsInBottomLeft(pt)
	return pt.X <= joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function IsInBottomRight(pt)
	return pt.X >= Utility.ViewSizeX() - joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function CheckAlive(character)
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end

local function GetEquippedTool(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA('Tool') then
				return child
			end
		end
	end	
end

local function ExploreWithRayCast(currentPoint, originDirection)
	local TestDistance = 40
	local TestVectors = {}
	do
		local forwardVector = originDirection;
		for i = 0, 15 do
			table.insert(TestVectors, CFrame.Angles(0, math.pi / 8 * i, 0) * forwardVector)
		end
	end
	
	local testResults = {}
	-- Heuristic should be something along the lines of distance and closeness to the traveling direction
	local function ExploreHeuristic()
		for _, testData in pairs(testResults) do
			local walkDirection = -1 * originDirection
			local directionCoeff = (walkDirection:Dot(testData['Vector']) + 1) / 2
			local distanceCoeff = testData['Distance'] / TestDistance
			testData["Value"] = directionCoeff * distanceCoeff
		end
	end
	
	for i, vec in pairs(TestVectors) do
		local hitPart, hitPos = Utility.Raycast(Ray.new(currentPoint, vec * TestDistance), true, {Player.Character})
		if hitPos then
			table.insert(testResults, {Vector = vec; Distance = (hitPos - currentPoint).magnitude})
		else
			table.insert(testResults, {Vector = vec; Distance = TestDistance})
		end
	end
	
	ExploreHeuristic()
	
	table.sort(testResults, function(a,b) return a["Value"] > b["Value"] end)
	
	return testResults	
end

local TapId = 1
local ExistingPather = nil
local ExistingIndicator = nil
local PathCompleteListener = nil
local PathFailedListener = nil

local function CleanupPath()
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		DebrisService:AddItem(ExistingIndicator, 0)
		ExistingIndicator = nil
	end	
end


local AutoJumperInstance = nil
local ShootCount = 0
local FailCount = 0
local function OnTap(tapPositions)	
	-- Good to remember if this is the latest tap event
	TapId = TapId + 1
	local thisTapId = TapId
	
	
	local camera = workspace.CurrentCamera
	local character = Player.Character

	
	if not CheckAlive(character) then return end
	
	-- This is a path tap position
	if #tapPositions == 1 then
		-- Filter out inputs that are by the sticks.
		if UIS.TouchEnabled == true and UIS.ModalEnabled == false and (IsInBottomRight(tapPositions[1]) or IsInBottomLeft(tapPositions[1])) then return end
		if camera then
			local unitRay = Utility.GetUnitRay(tapPositions[1].x, tapPositions[1].y, MyMouse.ViewSizeX, MyMouse.ViewSizeY, camera)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction*400)
			local hitPart, hitPt = Utility.Raycast(ray, true, {character})
			
			local hitChar, hitHumanoid = Utility.FindChacterAncestor(hitPart)
			local torso = character and character:FindFirstChild("Humanoid") and character:FindFirstChild("Humanoid").Torso
			local startPos = torso.CFrame.p
			if hitChar and hitHumanoid and hitHumanoid.Torso and (hitHumanoid.Torso.CFrame.p - torso.CFrame.p).magnitude < 7 then
				CleanupPath()
				
				local myHumanoid = findPlayerHumanoid(Player)
				if myHumanoid then
					myHumanoid:MoveTo(hitPt)
				end
				
				ShootCount = ShootCount + 1
				local thisShoot = ShootCount
				-- Do shooot
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
					LastFired = tick()
				end
			elseif hitPt and character then
				local thisPather = Pather(character, hitPt)
				if thisPather:IsValidPath() then
					FailCount = 0
					-- TODO: Remove when bug in engine is fixed
					Player:Move(Vector3.new(1, 0, 0))
					Player:Move(Vector3.new(0, 0, 0))
					thisPather:Start()
					if BindableEvent_OnFailStateChanged then
						BindableEvent_OnFailStateChanged:Fire(false)
					end
--					if CameraModule then
--						CameraModule:Start()
--					end
					CleanupPath()
				
					local destinationGlobe = CreateDestinationIndicator(hitPt)
					destinationGlobe.Parent = camera
					
					ExistingPather = thisPather
					ExistingIndicator = destinationGlobe
									
					if AutoJumperInstance then
						AutoJumperInstance:Run()
					end
					
					PathCompleteListener = thisPather.Finished:connect(function()
						if AutoJumperInstance then
							AutoJumperInstance:Stop()
						end
						if destinationGlobe then
							if ExistingIndicator == destinationGlobe then
								ExistingIndicator = nil
							end
							DebrisService:AddItem(destinationGlobe, 0)
							destinationGlobe = nil
						end
						if hitChar then
							local humanoid = findPlayerHumanoid(Player)
							ShootCount = ShootCount + 1
							local thisShoot = ShootCount
							-- Do shoot
							local currentWeapon = GetEquippedTool(character)
							if currentWeapon then
								currentWeapon:Activate()
								LastFired = tick()
							end
							if humanoid then
								humanoid:MoveTo(hitPt)
							end
						end
						local finishPos = torso and torso.CFrame.p --hitPt
						if finishPos and startPos and tick() - Utility.GetLastInput() > 2 then
							local exploreResults = ExploreWithRayCast(finishPos, ((startPos - finishPos) * Vector3.new(1,0,1)).unit)
							-- Check for Nans etc..
							if exploreResults[1] and exploreResults[1]["Vector"] and exploreResults[1]["Vector"].magnitude >= 0.5 and exploreResults[1]["Distance"] > 3 then
								if CameraModule then
									local rotatedCFrame = CameraModule:LookAtPreserveHeight(finishPos + exploreResults[1]["Vector"] * exploreResults[1]["Distance"])
									local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
								end
							end
						end
					end)
					PathFailedListener = thisPather.PathFailed:connect(function()
						if AutoJumperInstance then
							AutoJumperInstance:Stop()
						end
						if destinationGlobe then
							FlashRed(destinationGlobe)
							DebrisService:AddItem(destinationGlobe, 3)
						end
					end)
				else
					if hitPt then
						-- Feedback here for when we don't have a good path
						local failedGlobe = CreateDestinationIndicator(hitPt)
						FlashRed(failedGlobe)
						DebrisService:AddItem(failedGlobe, 1)
						failedGlobe.Parent = camera
						if ExistingIndicator == nil then
							FailCount = FailCount + 1
							if FailCount >= 3 then
								if BindableEvent_OnFailStateChanged then
									BindableEvent_OnFailStateChanged:Fire(true)
								end
--								if CameraModule then
--									CameraModule:Stop()
--								end
								workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
								CleanupPath()
							end
						end
					end
				end
			else
				-- no hit pt
			end
		end
	elseif #tapPositions >= 2 then
		if camera then
			ShootCount = ShootCount + 1
			local thisShoot = ShootCount
			-- Do shoot
			local avgPoint = Utility.AveragePoints(tapPositions)
			local unitRay = Utility.GetUnitRay(avgPoint.x, avgPoint.y, MyMouse.ViewSizeX, MyMouse.ViewSizeY, camera)
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
				LastFired = tick()
			end
		end
	end
end

local function SetUpGestureRecognizers()
	local MAX_FINGERS = 11
	local InputHistory = {}
	
	local function FindInputObject(inputObject)
		for i = 1, #InputHistory do
			if InputHistory[i] == inputObject then
				return InputHistory[i], i
			end
		end
	end
	
	local function PopInput(inputObject)
		local _, i = FindInputObject(inputObject)
		if i then
			table.remove(InputHistory, i)
			return true
		end
		return false
	end
	
	local function PushInput(inputObject)
		-- Make sure it isn't in the list already
		if FindInputObject(inputObject) then return false end
		
		if #InputHistory >= MAX_FINGERS then
			-- Pop old dead inputs when we maxxed out
			for i = 1, #InputHistory do
				if InputHistory[i].UserInputState == Enum.UserInputState.End then
					table.remove(InputHistory, i)
					break
				end
			end
		end
		if #InputHistory >= MAX_FINGERS then
			print("No more room for input; failing to add input")
			for i = 1, #InputHistory do
				print(tostring(i) .. ":" .. tostring(inputObject.UserInputState))
			end
			
			return false
		end
		
		
		local startPos = Instance.new("Vector3Value")
		startPos.Value = inputObject.Position -- Vector3.new(inputObject.Position.X, inputObject.Position.Y, 0)
		startPos.Name = "StartPos" -- Have to use Vector3value because there is no vector2 value
		startPos.Parent = inputObject
		
		local startTime = Instance.new("NumberValue")
		startTime.Value = tick()
		startTime.Name = "StartTime"
		startTime.Parent = inputObject
		
		
		table.insert(InputHistory, inputObject)
		return true
	end
	
	
	UIS.InputBegan:connect(function(inputObject)
		if inputObject.UserInputType == Enum.UserInputType.Touch then
			PushInput(inputObject)
			
			local wasInBottomLeft = IsInBottomLeft(inputObject.Position)
			local wasInBottomRight = IsInBottomRight(inputObject.Position)
			if wasInBottomRight or wasInBottomLeft then
				for i, otherInput in pairs(InputHistory) do
					local otherInputInLeft = IsInBottomLeft(otherInput.Position)
					local otherInputInRight = IsInBottomRight(otherInput.Position)
					if otherInput.UserInputState ~= Enum.UserInputState.End and ((wasInBottomLeft and otherInputInRight) or (wasInBottomRight and otherInputInLeft)) then
						-- TODO: Is this still a valid code path?
						UIS.ModalEnabled = false
--						if CameraModule then
--							CameraModule:Stop()
--						end
						workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
					end
				end
			end
		end
	end)
	
	UIS.InputEnded:connect(function(inputObject)
		if inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		do
			local lookedUpObject = FindInputObject(inputObject)
			
			local endTime = Instance.new("NumberValue")
			endTime.Value = tick()
			endTime.Name = "EndTime"
			endTime.Parent = lookedUpObject
		end
	end)
end


local function CreateClickToMoveModule()
	local this = {}
	
	local LastStateChange = 0
	local LastState = Enum.HumanoidStateType.Running
	local LastMouseUpTime = 0
	
	local TapConn = nil
	local MouseUpConn = nil
	local MouseDownConn = nil
	local MouseButton2DownConn = nil
	local RotateConn = nil
	local MouseWheelBackwardConn = nil
	local MouseWheelForwardConn = nil
	local HumanoidDiedConn = nil
	local CharacterChildAddedConn = nil
	local KeyboardInputBeganConn = nil
	local OnCharacterAddedConn = nil
	local RenderSteppedConn = nil
	
	local function disconnectEvent(event)
		if event then
			event:disconnect()
		end
	end
	
	local function DisconnectEvents()
		disconnectEvent(TapConn)
		disconnectEvent(MouseUpConn)
		disconnectEvent(MouseDownConn)
		disconnectEvent(MouseButton2DownConn)
		disconnectEvent(MouseWheelForwardConn)
		disconnectEvent(MouseWheelBackwardConn)
		disconnectEvent(RotateConn)
		disconnectEvent(HumanoidDiedConn)
		disconnectEvent(CharacterChildAddedConn)
		disconnectEvent(KeyboardInputBeganConn)
		disconnectEvent(OnCharacterAddedConn)
		disconnectEvent(RenderSteppedConn)
	end
	
	
	-- Setup the camera
	CameraModule = ClassicCameraModule()
	
	do
		-- Extend The Camera Module Class
		function CameraModule:LookAtPreserveHeight(newLookAtPt)
			local camera = 	workspace.CurrentCamera
			
			local focus = camera.Focus.p
						
			local cameraCFrame = camera.CoordinateFrame
			local mag = Vector3.new(cameraCFrame.lookVector.x, 0, cameraCFrame.lookVector.z).magnitude
			local newLook = (Vector3.new(newLookAtPt.x, focus.y, newLookAtPt.z) - focus).unit * mag
			local flippedLook = newLook + Vector3.new(0, cameraCFrame.lookVector.y, 0)
			
			local distance = (focus - camera.CoordinateFrame.p).magnitude
			
			local newCamPos = focus - flippedLook.unit * distance
			return CFrame.new(newCamPos, newCamPos + flippedLook)
		end
		
		function CameraModule:TweenCameraLook(desiredCFrame, speed)
			local e = 2.718281828459
			local function SCurve(t)
				return 1/(1 + e^(-t*1.5))
			end
			local function easeOutSine(t, b, c, d)
				if t >= d then return b + c end
				return c * math.sin(t/d * (math.pi/2)) + b;
			end
			
			local theta, interper = CFrameInterpolator(CFrame.new(Vector3.new(), self:GetCameraLook()), desiredCFrame - desiredCFrame.p)
			theta = Utility.Clamp(0, math.pi, theta)
			local duration = 0.65 * SCurve(theta - math.pi/4) + 0.15
			if speed then
				duration = theta / speed
			end
			local start = tick()
			local finish = start + duration
		
			self.UpdateTweenFunction = function()
				local currTime = tick() - start
				local alpha = Utility.Clamp(0, 1, easeOutSine(currTime, 0, 1, duration))
				local newCFrame = interper(alpha)
				self.cameraLook = newCFrame.lookVector
				return (currTime >= finish or alpha >= 1)
			end
		end
	end
	--- Done Extending

	local function OnCharacterAdded(character)
		DisconnectEvents()
		
		
		if UIS.TouchEnabled then -- Mobile	
			SetUpGestureRecognizers()
			
			TapConn = UIS.TouchTap:connect(function(touchPositions, sunk)				
				if not sunk then
					OnTap(touchPositions)
				end
			end)
			
			MouseUpConn = MyMouse.Button1Up:connect(function()
				LastMouseUpTime = tick()
			end)
			
			local function OnCharacterChildAdded(child)
				if child:IsA('Tool') then
					child.ManualActivationOnly = true
				elseif child:IsA('Humanoid') then
					disconnectEvent(HumanoidDiedConn)
					HumanoidDiedConn = child.Died:connect(function()
						DebrisService:AddItem(ExistingIndicator, 1)		
						if AutoJumperInstance then
							AutoJumperInstance:Stop()
							AutoJumperInstance = nil
						end
					end)
				end
			end
			
			CharacterChildAddedConn = character.ChildAdded:connect(function(child)
				OnCharacterChildAdded(child)
			end)
			for _, child in pairs(character:GetChildren()) do
				OnCharacterChildAdded(child)
			end
		else -- PC
			if AutoJumperInstance then
				AutoJumperInstance:Stop()
				AutoJumperInstance = nil
			end
			AutoJumperInstance = AutoJumper()
			-- PC simulation
			local mouse1Down = tick()
			local mouse1DownPos = Vector2.new()
			local mouse1Up = tick()
			local mouse2Down = tick()
			local mouse2DownPos = Vector2.new()
			local mouse2Up = tick()
			
			local movementKeys = {
				[Enum.KeyCode.W] = true;
				[Enum.KeyCode.A] = true;
				[Enum.KeyCode.S] = true;
				[Enum.KeyCode.D] = true;
				[Enum.KeyCode.Up] = true;
				[Enum.KeyCode.Down] = true;
			}
			
			KeyboardInputBeganConn = UIS.InputBegan:connect(function(inputObject, processed)
				if processed then return end
				if inputObject.UserInputType == Enum.UserInputType.Keyboard and movementKeys[inputObject.KeyCode] then
					 CleanupPath() -- Cancel path when you use the keyboard controls.
				end
			end)
			
			MouseDownConn = MyMouse.Button1Down:connect(function()
				mouse1Down = tick()
				mouse1DownPos = Vector2.new(MyMouse.X, MyMouse.Y)
			end)
			MouseButton2DownConn = MyMouse.Button2Down:connect(function()
				mouse2Down = tick()
				mouse2DownPos = Vector2.new(MyMouse.X, MyMouse.Y)
			end)
			MouseUpConn = MyMouse.Button2Up:connect(function()
				mouse2Up = tick()			
				local currPos = Vector2.new(MyMouse.X, MyMouse.Y)
				if mouse2Up - mouse2Down < 0.25 and (currPos - mouse2DownPos).magnitude < 5 then
					local positions = {currPos}
					OnTap(positions)
				end
			end)
			MouseWheelBackwardConn = MyMouse.WheelBackward:connect(function()
				Player.CameraMode = Enum.CameraMode.Classic
			end)
			MouseWheelForwardConn = MyMouse.WheelForward:connect(function()
				if (workspace.CurrentCamera.CoordinateFrame.p - workspace.CurrentCamera.Focus.p).magnitude < 0.8 then
					Player.CameraMode = Enum.CameraMode.LockFirstPerson
				end
			end)
		end
		RenderSteppedConn = RunService.RenderStepped:connect(function()
			if CameraModule then
				if CameraModule.UserPanningTheCamera then
					CameraModule.UpdateTweenFunction = nil
				else
					if CameraModule.UpdateTweenFunction then
						local done = CameraModule.UpdateTweenFunction()
						if done then
							CameraModule.UpdateTweenFunction = nil
						end
					end
				end
				CameraModule:Update()
			end
		end)
	end
	
	local Running = false
	
	function this:Stop()
		if Running then
			DisconnectEvents()
			CleanupPath()
			if AutoJumperInstance then
				AutoJumperInstance:Stop()
				AutoJumperInstance = nil
			end
			if CameraModule then
				CameraModule.UpdateTweenFunction = nil
			end
			Running = false
		end
	end
	
	function this:Start()
		if not Running then
			if Player.Character then -- retro-listen
				OnCharacterAdded(Player.Character)
			end
			OnCharacterAddedConn = Player.CharacterAdded:connect(OnCharacterAdded)
			Running = true
		end
	end
	
	return this
end

return CreateClickToMoveModule
]]></ProtectedString>
			</Properties>
		</Item>
	</Item>
	<Item class="LocalScript" referent="RBX98E78399E88B4732A1B353AEE349E236">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">ControlScript</string>
			<ProtectedString name="Source"><![CDATA[--[[
	// FileName: ControlScript.lua
	// Version 1.0
	// Written by: jmargh
	// Description: Manages in game controls for both touch and keyboard/mouse devices.
	
	// This script will be inserted into PlayerScripts under each player by default. If you want to
	// create your own custom controls or modify these controls, you must place a script with this
	// name, ControlScript, under StarterPlayer -> PlayerScripts.
	
	// Required Modules:
		ClickToMove
		DPad
		KeyboardMovement
		Thumbpad
		Thumbstick
		TouchJump
--]]

--[[ Services ]]--
local ContextActionService = game:GetService('ContextActionService')
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')

-- Issue with play solo? (F6)
while not UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled do
	wait()
end

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer.PlayerGui
local IsTouchDevice = UserInputService.TouchEnabled
local DevMovementMode = IsTouchDevice and LocalPlayer.DevTouchMovementMode or LocalPlayer.DevComputerMovementMode
local TouchGui = nil
local TouchControlFrame = nil
local TouchJumpModule = nil
local IsModalEnabled = UserInputService.ModalEnabled
local BindableEvent_OnFailStateChanged = nil

--[[ Modules ]]--
local CurrentControlModule = nil
local ClickToMoveTouchControls = nil
local ControlModules = {}
if IsTouchDevice then
	ControlModules.Thumbstick = require(script:WaitForChild('Thumbstick'))
	ControlModules.Thumbpad = require(script:WaitForChild('Thumbpad'))
	ControlModules.DPad = require(script:WaitForChild('DPad'))
	ControlModules.Default = ControlModules.Thumbstick
	TouchJumpModule = require(script:WaitForChild('TouchJump'))
	BindableEvent_OnFailStateChanged = script.Parent:WaitForChild('OnClickToMoveFailStateChange')
else
	ControlModules.Keyboard = require(script:WaitForChild('KeyboardMovement'))
end

--[[ Initialization/Setup ]]--
local function createTouchGuiContainer()
	if TouchGui then TouchGui:Destroy() end
	
	-- Container for all touch device guis
	TouchGui = Instance.new('ScreenGui')
	TouchGui.Name = "TouchGui"
	TouchGui.Parent = PlayerGui
	
	TouchControlFrame = Instance.new('Frame')
	TouchControlFrame.Name = "TouchControlFrame"
	TouchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	TouchControlFrame.BackgroundTransparency = 1
	TouchControlFrame.Parent = TouchGui
	
	ControlModules.Thumbstick:Create(TouchControlFrame)
	ControlModules.DPad:Create(TouchControlFrame)
	ControlModules.Thumbpad:Create(TouchControlFrame)
	TouchJumpModule:Create(TouchControlFrame)
end

--[[ Local Functions ]]--
local function setJumpModule(isEnabled)
	if not isEnabled then
		TouchJumpModule:Disable()
	elseif CurrentControlModule == ControlModules.Thumbpad or CurrentControlModule == ControlModules.Thumbstick or
		CurrentControlModule == ControlModules.Default then
		--
		TouchJumpModule:Enable()
	end
end

local function setClickToMove()
	if DevMovementMode == Enum.DevTouchMovementMode.ClickToMove or DevMovementMode == Enum.DevComputerMovementMode.ClickToMove then
		--
		if IsTouchDevice then
			ClickToMoveTouchControls = CurrentControlModule or ControlModules.Default
		end
	else
		if IsTouchDevice and ClickToMoveTouchControls then
			ClickToMoveTouchControls:Disable()
			ClickToMoveTouchControls = nil
		end
	end
end

--[[ Controls State Management ]]--
local onControlsChanged = nil
if IsTouchDevice then
	createTouchGuiContainer()
	onControlsChanged = function()
		local newModuleToEnable = nil
		local isJumpEnabled = false
		if DevMovementMode == Enum.DevTouchMovementMode.Thumbstick then
			newModuleToEnable = ControlModules.Thumbstick
			isJumpEnabled = true
		elseif DevMovementMode == Enum.DevTouchMovementMode.Thumbpad then
			newModuleToEnable = ControlModules.Thumbpad
			isJumpEnabled = true
		elseif DevMovementMode == Enum.DevTouchMovementMode.DPad then
			newModuleToEnable = ControlModules.DPad
		elseif DevMovementMode == Enum.DevTouchMovementMode.ClickToMove then
			-- Managed by CameraScript
			newModuleToEnable = nil
		elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
			newModuleToEnable = nil
		end
		setClickToMove()
		if newModuleToEnable ~= CurrentControlModule then
			if CurrentControlModule then
				CurrentControlModule:Disable()
			end
			setJumpModule(isJumpEnabled)
			CurrentControlModule = newModuleToEnable
			if CurrentControlModule and not IsModalEnabled then
				CurrentControlModule:Enable()
				if isJumpEnabled then TouchJumpModule:Enable() end
			end
		end
	end
elseif UserInputService.KeyboardEnabled then
	onControlsChanged = function()
		-- NOTE: Click to move still uses keyboard. Leaving cases in case this ever changes.
		local newModuleToEnable = nil
		if DevMovementMode == Enum.DevComputerMovementMode.KeyboardMouse then
			newModuleToEnable = ControlModules.Keyboard
		elseif DevMovementMode == Enum.DevComputerMovementMode.ClickToMove then
			-- Managed by CameraScript
			newModuleToEnable = ControlModules.Keyboard
		end 
		if newModuleToEnable ~= CurrentControlModule then
			if CurrentControlModule then
				CurrentControlModule:Disable()
			end
			CurrentControlModule = newModuleToEnable
			if CurrentControlModule then
				CurrentControlModule:Enable()
			end
		end
	end
end

--[[ Settings Changed Connections ]]--
LocalPlayer.Changed:connect(function(property)
	if IsTouchDevice and property == 'DevTouchMovementMode' then
		DevMovementMode = LocalPlayer.DevTouchMovementMode
		onControlsChanged()
	elseif not IsTouchDevice and property == 'DevComputerMovementMode' then
		DevMovementMode = LocalPlayer.DevComputerMovementMode
		onControlsChanged()
	end
end)

--[[ Touch Events ]]--
if IsTouchDevice then
	-- On touch devices we need to recreate the guis on character load.
	LocalPlayer.CharacterAdded:connect(function(character)
		createTouchGuiContainer()
		if CurrentControlModule then
			CurrentControlModule:Disable()
			CurrentControlModule = nil
		end
		onControlsChanged()
	end)
	
	UserInputService.Changed:connect(function(property)
		if property == 'ModalEnabled' then
			IsModalEnabled = UserInputService.ModalEnabled
			setJumpModule(not UserInputService.ModalEnabled)
			if UserInputService.ModalEnabled then
				if CurrentControlModule then
					CurrentControlModule:Disable()
				end
			else
				if CurrentControlModule then
					CurrentControlModule:Enable()
				end
			end
		end
	end)

	BindableEvent_OnFailStateChanged.Event:connect(function(isOn)
		if ClickToMoveTouchControls then
			if isOn then
				ClickToMoveTouchControls:Enable()
			else
				ClickToMoveTouchControls:Disable()
			end
			if ClickToMoveTouchControls == ControlModules.Thumbpad or ClickToMoveTouchControls == ControlModules.Thumbstick or
				ClickToMoveTouchControls == ControlModules.Default then
				--
				if isOn then
					TouchJumpModule:Enable()
				else
					TouchJumpModule:Disable()
				end
			end
		end
	end)
end

onControlsChanged()]]></ProtectedString>
		</Properties>
		<Item class="ModuleScript" referent="RBXB3871131C83F4365B4DC20981385D205">
			<Properties>
				<string name="Name">DPad</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: DPad
	// Version 1.0
	// Written by: jmargh
	// Description: Implements DPad controls for touch devices
--]]

local Players = game:GetService('Players')

local DPad = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local CachedHumanoid = nil
local DPadFrame = nil
local TouchObject = nil
local OnInputEnded = nil		-- defined in Create()

--[[ Constants ]]--
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local COMPASS_DIR = {
	Vector3.new(1, 0, 0),			-- E
	Vector3.new(1, 0, 1).unit,		-- SE
	Vector3.new(0, 0, 1),			-- S
	Vector3.new(-1, 0, 1).unit,		-- SW
	Vector3.new(-1, 0, 0),			-- W
	Vector3.new(-1, 0, -1).unit,	-- NW
	Vector3.new(0, 0, -1),			-- N
	Vector3.new(1, 0, -1).unit,		-- NE
}

--[[ lua Function Cache ]]--
local ATAN2 = math.atan2
local FLOOR = math.floor
local PI = math.pi

--[[ Local Functions ]]--
local function createArrowLabel(name, position, size, rectOffset, rectSize)
	local image = Instance.new('ImageLabel')
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.Size = size
	image.Position = position
	image.Parent = DPadFrame
	
	return image
end

local function getCenterPosition()
	return Vector2.new(DPadFrame.AbsolutePosition.x + DPadFrame.AbsoluteSize.x/2, DPadFrame.AbsolutePosition.y + DPadFrame.AbsoluteSize.y/2)
end

local function getHumanoid()
	local character = LocalPlayer and LocalPlayer.Character
	if character then
		if CachedHumanoid and CachedHumanoid.Parent == character then
			return CachedHumanoid
		else
			CachedHumanoid = nil
			for _,child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					CachedHumanoid = child
					return CachedHumanoid
				end
			end
		end
	end
end

--[[ Public API ]]--
function DPad:Enable()
	DPadFrame.Visible = true
end

function DPad:Disable()
	DPadFrame.Visible = false
	OnInputEnded()
end

function DPad:Create(parentFrame)
	if DPadFrame then
		DPadFrame:Destroy()
		DPadFrame = nil
	end
	
	local position = UDim2.new(0, 10, 1, -230)
	DPadFrame = Instance.new('Frame')
	DPadFrame.Name = "DPadFrame"
	DPadFrame.Active = true
	DPadFrame.Visible = false
	DPadFrame.Size = UDim2.new(0, 192, 0, 192)
	DPadFrame.Position = position
	DPadFrame.BackgroundTransparency = 1
	
	local smArrowSize = UDim2.new(0, 23, 0, 23)
	local lgArrowSize = UDim2.new(0, 64, 0, 64)
	local smImgOffset = Vector2.new(46, 46)
	local lgImgOffset = Vector2.new(128, 128)
	
	local bBtn = createArrowLabel("BackButton", UDim2.new(0.5, -32, 1, -64), lgArrowSize, Vector2.new(0, 0), lgImgOffset)
	local fBtn = createArrowLabel("ForwardButton", UDim2.new(0.5, -32, 0, 0), lgArrowSize, Vector2.new(0, 258), lgImgOffset)
	local lBtn = createArrowLabel("LeftButton", UDim2.new(0, 0, 0.5, -32), lgArrowSize, Vector2.new(129, 129), lgImgOffset)
	local rBtn = createArrowLabel("RightButton", UDim2.new(1, -64, 0.5, -32), lgArrowSize, Vector2.new(0, 129), lgImgOffset)
	local jumpBtn = createArrowLabel("JumpButton", UDim2.new(0.5, -32, 0.5, -32), lgArrowSize, Vector2.new(129, 0), lgImgOffset)
	local flBtn = createArrowLabel("ForwardLeftButton", UDim2.new(0, 35, 0, 35), smArrowSize, Vector2.new(129, 258), smImgOffset)
	local frBtn = createArrowLabel("ForwardRightButton", UDim2.new(1, -55, 0, 35), smArrowSize, Vector2.new(176, 258), smImgOffset)
	flBtn.Visible = false
	frBtn.Visible = false
	
	-- input connections
	jumpBtn.InputBegan:connect(function(inputObject)
		local character = LocalPlayer.Character
		if character then
			local humanoid = getHumanoid()
			if humanoid then
				humanoid.Jump = true
			end
		end
	end)
	
	local movementVector = nil
	local function normalizeDirection(inputPosition)
		local jumpRadius = jumpBtn.AbsoluteSize.x/2
		local centerPosition = getCenterPosition()
		local direction = Vector2.new(inputPosition.x - centerPosition.x, inputPosition.y - centerPosition.y)
		
		if direction.magnitude > jumpRadius then
			local angle = ATAN2(direction.y, direction.x)
			local octant = (FLOOR(8 * angle / (2 * PI) + 8.5)%8) + 1
			movementVector = COMPASS_DIR[octant]
		end
		
		if not flBtn.Visible and movementVector == COMPASS_DIR[7] then
			flBtn.Visible = true
			frBtn.Visible = true
		end
	end
	
	DPadFrame.InputBegan:connect(function(inputObject)
		if TouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		TouchObject = inputObject
		normalizeDirection(TouchObject.Position)
		local humanoid = getHumanoid()
		if humanoid then
			humanoid:Move(movementVector, true)
		end
	end)
	
	DPadFrame.InputChanged:connect(function(inputObject)
		if inputObject == TouchObject then
			normalizeDirection(TouchObject.Position)
			local humanoid = getHumanoid()
			if humanoid then
				humanoid:Move(movementVector, true)
			end
		end
	end)
	
	OnInputEnded = function()
		TouchObject = nil
		flBtn.Visible = false
		frBtn.Visible = false
		local humanoid = getHumanoid()
		if humanoid then
			movementVector = Vector3.new(0, 0, 0)
			humanoid:Move(movementVector, true)
		end
	end
	
	DPadFrame.InputEnded:connect(function(inputObject)
		if inputObject == TouchObject then
			OnInputEnded()
		end
	end)
	
	DPadFrame.Parent = parentFrame
end

return DPad
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX2735829EB21F4910BC05411F6F54BCC7">
			<Properties>
				<string name="Name">KeyboardMovement</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: ComputerMovementKeyboardMovement
	// Version 1.0
	// Written by: jeditkacheff/jmargh
	// Description: Implements movement controls for keyboard devices
--]]
local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local ContextActionService = game:GetService('ContextActionService')
local StarterPlayer = game:GetService('StarterPlayer')

local KeyboardMovement = {}

while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local CachedHumanoid = nil
local RenderSteppedCon = nil
local TextFocusReleasedCn = nil

--[[ Local Functions ]]--
local function getHumanoid()
	local character = LocalPlayer and LocalPlayer.Character
	if character then
		if CachedHumanoid and CachedHumanoid.Parent == character then
			return CachedHumanoid
		else
			CachedHumanoid = nil
			for _,child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					CachedHumanoid = child
					return CachedHumanoid
				end
			end
		end
	end
end

--[[ Public API ]]--
function KeyboardMovement:Enable()
	if not UserInputService.KeyboardEnabled then
		return
	end
	
	repeat wait() until LocalPlayer.Character
	local Humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
	local Mouse = LocalPlayer:GetMouse()
	local Root = LocalPlayer.Character.HumanoidRootPart
	local Torso = LocalPlayer.Character.Torso
	local Neck = Torso.Neck
	
	local function isFirstPersonOrShiftLocked()
		if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			return true
		end
	end
	
	RenderSteppedCon = RunService.RenderStepped:connect(function()
		if LocalPlayer and LocalPlayer.Character then
			if not Humanoid then return end
			local MouseDirection = Mouse.UnitRay.Direction.unit
			if tostring(MouseDirection) == "NAN, NAN, NAN" then
				return
			end
			if Humanoid and not Humanoid.Sit and not Humanoid.PlatformStand and Humanoid:GetState() ~= Enum.HumanoidStateType.Swimming and Root then
				Root.CFrame = CFrame.new(Root.Position, Root.Position + Vector3.new(MouseDirection.x, 0, MouseDirection.z))
			end
			if Neck then
				Neck.C0 = Torso.CFrame:toObjectSpace(Root.CFrame * CFrame.new(0, 1.5, 0) * CFrame.new(Humanoid.CameraOffset))
				Neck.C1 = CFrame.Angles(-math.asin(MouseDirection.y), 0, 0)
			end
		end
	end)
end

function KeyboardMovement:Disable()
end

return KeyboardMovement
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX0144E3592B9C4EF9B609EAEC58AE7285">
			<Properties>
				<string name="Name">Thumbpad</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: Thumbpad
	// Version 1.0
	// Written by: jmargh
	// Description: Implements thumbpad controls for touch devices
--]]

local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')

local Thumbpad = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local CachedHumanoid = nil
local ThumbpadFrame = nil
local TouchObject = nil
local OnInputEnded = nil	-- is defined in Create()
local OnTouchChangedCn = nil
local OnTouchEndedCn = nil

--[[ Constants ]]--
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"

--[[ Local Functions ]]--
local function createArrowLabel(name, parent, position, size, rectOffset, rectSize)
	local image = Instance.new('ImageLabel')
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.ImageColor3 = Color3.new(190/255, 190/255, 190/255)
	image.Size = size
	image.Position = position
	image.Parent = parent
	
	return image
end

local function getHumanoid()
	local character = LocalPlayer and LocalPlayer.Character
	if character and character.Parent then
		if CachedHumanoid and CachedHumanoid.Parent == character then
			return CachedHumanoid
		else
			CachedHumanoid = nil
			for _,child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					CachedHumanoid = child
					return CachedHumanoid
				end
			end
		end
	end
end

--[[ Public API ]]--
function Thumbpad:Enable()
	ThumbpadFrame.Visible = true
end

function Thumbpad:Disable()
	ThumbpadFrame.Visible = false
	OnInputEnded()
end

function Thumbpad:Create(parentFrame)
	if ThumbpadFrame then
		ThumbpadFrame:Destroy()
		ThumbpadFrame = nil
		if OnTouchChangedCn then
			OnTouchChangedCn:disconnect()
			OnTouchChangedCn = nil
		end
		if OnTouchEndedCn then
			OnTouchEndedCn:disconnect()
			OnTouchEndedCn = nil
		end
	end
	
	local isSmallScreen = parentFrame.AbsoluteSize.y <= 500
	local thumbpadSize = isSmallScreen and 70 or 120
	local position = isSmallScreen and UDim2.new(0, thumbpadSize * 1.25, 1, -thumbpadSize - 20) or
		UDim2.new(0, thumbpadSize/2 - 10, 1, -thumbpadSize * 1.75 - 10)
	
	ThumbpadFrame = Instance.new('Frame')
	ThumbpadFrame.Name = "ThumbpadFrame"
	ThumbpadFrame.Visible = false
	ThumbpadFrame.Active = true
	ThumbpadFrame.Size = UDim2.new(0, thumbpadSize + 20, 0, thumbpadSize + 20)
	ThumbpadFrame.Position = position
	ThumbpadFrame.BackgroundTransparency = 1
	
	local outerImage = Instance.new('ImageLabel')
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new(0, 0)
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbpadSize, 0, thumbpadSize)
	outerImage.Position = UDim2.new(0, 10, 0, 10)
	outerImage.Parent = ThumbpadFrame
	
	local smArrowSize = isSmallScreen and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 64, 0, 64)
	local lgArrowSize = UDim2.new(0, smArrowSize.X.Offset * 2, 0, smArrowSize.Y.Offset * 2)
	local imgRectSize = Vector2.new(110, 110)
	local smImgOffset = isSmallScreen and -4 or -9
	local lgImgOffset = isSmallScreen and -28 or -55
	
	local dArrow = createArrowLabel("DownArrow", outerImage, UDim2.new(0.5, -smArrowSize.X.Offset/2, 1, lgImgOffset), smArrowSize, Vector2.new(8, 8), imgRectSize)
	local uArrow = createArrowLabel("UpArrow", outerImage, UDim2.new(0.5, -smArrowSize.X.Offset/2, 0, smImgOffset), smArrowSize, Vector2.new(8, 266), imgRectSize)
	local lArrow = createArrowLabel("LeftArrow", outerImage, UDim2.new(0, smImgOffset, 0.5, -smArrowSize.Y.Offset/2), smArrowSize, Vector2.new(137, 137), imgRectSize)
	local rArrow = createArrowLabel("RightArrow", outerImage, UDim2.new(1, lgImgOffset, 0.5, -smArrowSize.Y.Offset/2), smArrowSize, Vector2.new(8, 137), imgRectSize)
	
	local function doTween(guiObject, endSize, endPosition)
		guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
	end
	
	local padOrigin = nil
	local deadZone = 0.1
	local isRight, isLeft, isUp, isDown = false, false, false, false
	local vForward = Vector3.new(0, 0, -1)
	local vRight = Vector3.new(1, 0, 0)
	local function doMove(pos)
		local delta = Vector2.new(pos.x, pos.y) - padOrigin
		local inputAxis = delta / (thumbpadSize/2)
		
		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = inputAxis.magnitude
		if inputAxisMagnitude < deadZone then
			inputAxis = Vector3.new(0, 0, 0)
		else
			inputAxis = inputAxis.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			-- catch possible NAN Vector
			if inputAxis.magnitude == 0 then
				inputAxis = Vector3.new(0, 0, 0)
			else
				inputAxis = Vector3.new(inputAxis.x, 0, inputAxis.y).unit
			end
		end
		
		local humanoid = getHumanoid()
		if humanoid then
			humanoid:Move(inputAxis, true)
		end
		
		local forwardDot = inputAxis:Dot(vForward)
		local rightDot = inputAxis:Dot(vRight)
		if forwardDot > 0.5 then		-- UP
			if not isUp then
				isUp, isDown = true, false
				doTween(uArrow, lgArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset, 0, smImgOffset - smArrowSize.Y.Offset * 1.5))
				doTween(dArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 1, lgImgOffset))
			end
		elseif forwardDot < -0.5 then	-- DOWN
			if not isDown then
				isDown, isUp = true, false
				doTween(dArrow, lgArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset, 1, lgImgOffset + smArrowSize.Y.Offset/2))
				doTween(uArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 0, smImgOffset))
			end
		else
			isUp, isDown = false, false
			doTween(dArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 1, lgImgOffset))
			doTween(uArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 0, smImgOffset))
		end
		
		if rightDot > 0.5 then
			if not isRight then
				isRight, isLeft = true, false
				doTween(rArrow, lgArrowSize, UDim2.new(1, lgImgOffset + smArrowSize.X.Offset/2, 0.5, -smArrowSize.Y.Offset))
				doTween(lArrow, smArrowSize, UDim2.new(0, smImgOffset, 0.5, -smArrowSize.Y.Offset/2))
			end
		elseif rightDot < -0.5 then
			if not isLeft then
				isLeft, isRight = true, false
				doTween(lArrow, lgArrowSize, UDim2.new(0, smImgOffset - smArrowSize.X.Offset * 1.5, 0.5, -smArrowSize.Y.Offset))
				doTween(rArrow, smArrowSize, UDim2.new(1, lgImgOffset, 0.5, -smArrowSize.Y.Offset/2))
			end
		else
			isRight, isLeft = false, false
			doTween(lArrow, smArrowSize, UDim2.new(0, smImgOffset, 0.5, -smArrowSize.Y.Offset/2))
			doTween(rArrow, smArrowSize, UDim2.new(1, lgImgOffset, 0.5, -smArrowSize.Y.Offset/2))
		end
	end
	
	--input connections
	ThumbpadFrame.InputBegan:connect(function(inputObject)
		if TouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		ThumbpadFrame.Position = UDim2.new(0, inputObject.Position.x - ThumbpadFrame.AbsoluteSize.x/2, 0, inputObject.Position.y - ThumbpadFrame.Size.Y.Offset/2)
		padOrigin = Vector2.new(ThumbpadFrame.AbsolutePosition.x + ThumbpadFrame.AbsoluteSize.x/2,
			ThumbpadFrame.AbsolutePosition.y + ThumbpadFrame.AbsoluteSize.y/2)
		doMove(inputObject.Position)
		TouchObject = inputObject
	end)
	
	OnTouchChangedCn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == TouchObject then
			doMove(TouchObject.Position)
		end
	end)
	
	OnInputEnded = function()
		local humanoid = getHumanoid()
		if humanoid then
			humanoid:Move(Vector3.new(0, 0, 0), true)
		end
		ThumbpadFrame.Position = position
		TouchObject = nil
		isUp, isDown, isLeft, isRight = false, false, false, false
		doTween(dArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 1, lgImgOffset))
		doTween(uArrow, smArrowSize, UDim2.new(0.5, -smArrowSize.X.Offset/2, 0, smImgOffset))
		doTween(lArrow, smArrowSize, UDim2.new(0, smImgOffset, 0.5, -smArrowSize.Y.Offset/2))
		doTween(rArrow, smArrowSize, UDim2.new(1, lgImgOffset, 0.5, -smArrowSize.Y.Offset/2))
	end
	
	OnTouchEndedCn = UserInputService.TouchEnded:connect(function(inputObject)
		if inputObject == TouchObject then
			OnInputEnded()
		end
	end)
	
	ThumbpadFrame.Parent = parentFrame
end

return Thumbpad
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXAE37EC1837D048C69A51A9FA723C9792">
			<Properties>
				<string name="Name">TouchJump</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: TouchJump
	// Version 1.0
	// Written by: jmargh
	// Description: Implements jump controls for touch devices. Use with Thumbstick and Thumbpad
--]]

local Players = game:GetService('Players')

local TouchJump = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local CachedHumanoid = nil
local JumpButton = nil
local OnInputEnded = nil		-- defined in Create()

--[[ Constants ]]--
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"

--[[ Local Functions ]]--
local function getHumanoid()
	local character = LocalPlayer and LocalPlayer.Character
	if character then
		if CachedHumanoid and CachedHumanoid.Parent == character then
			return CachedHumanoid
		else
			CachedHumanoid = nil
			for _,child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					CachedHumanoid = child
					return CachedHumanoid
				end
			end
		end
	end
end

--[[ Public API ]]--
function TouchJump:Enable()
	JumpButton.Visible = true
end

function TouchJump:Disable()
	JumpButton.Visible = false
	OnInputEnded()
end

function TouchJump:Create(parentFrame)
	if JumpButton then
		JumpButton:Destroy()
		JumpButton = nil
	end
	
	local isSmallScreen = parentFrame.AbsoluteSize.y <= 500
	local jumpButtonSize = isSmallScreen and 70 or 90
	
	JumpButton = Instance.new('ImageButton')
	JumpButton.Name = "JumpButton"
	JumpButton.Visible = false
	JumpButton.BackgroundTransparency = 1
	JumpButton.Image = TOUCH_CONTROL_SHEET
	JumpButton.ImageRectOffset = Vector2.new(176, 222)
	JumpButton.ImageRectSize = Vector2.new(174, 174)
	JumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	JumpButton.Position = isSmallScreen and UDim2.new(1, jumpButtonSize * -2.25, 1, -jumpButtonSize - 20) or
		UDim2.new(1, jumpButtonSize * -2.75, 1, -jumpButtonSize - 120)
	
	local touchObject = nil
	local function doJumpLoop()
		local character = LocalPlayer.Character
		if character then
			local humanoid = getHumanoid()
			if humanoid then
				while touchObject do
					humanoid.Jump = true
					wait(1/60)
				end
			end
		end
	end
	
	JumpButton.InputBegan:connect(function(inputObject)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		touchObject = inputObject
		JumpButton.ImageRectOffset = Vector2.new(0, 222)
		doJumpLoop()
	end)
	
	OnInputEnded = function()
		touchObject = nil
		JumpButton.ImageRectOffset = Vector2.new(176, 222)
	end
	
	JumpButton.InputEnded:connect(function(inputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)
	
	JumpButton.Parent = parentFrame
end

return TouchJump
]]></ProtectedString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7F3C7E9665804E3BAA20322B7C7AD235">
			<Properties>
				<string name="Name">Thumbstick</string>
				<ProtectedString name="Source"><![CDATA[--[[
	// FileName: Thumbstick
	// Version 1.0
	// Written by: jmargh
	// Description: Implements thumbstick controls for touch devices
--]]
local Players = game:GetService('Players')
local UserInputService = game:GetService('UserInputService')

local Thumbstick = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local CachedHumanoid = nil
local IsFollowStick = true
local ThumbstickFrame = nil
local MoveTouchObject = nil
local OnTouchEnded = nil		-- defined in Create()
local OnTouchMovedCn = nil
local OnTouchEndedCn = nil

--[[ Constants ]]--
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"

--[[ Local Functions ]]--
local function getHumanoid()
	local character = LocalPlayer and LocalPlayer.Character
	if character and character.Parent then
		if CachedHumanoid and CachedHumanoid.Parent == character then
			return CachedHumanoid
		else
			CachedHumanoid = nil
			for _,child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					CachedHumanoid = child
					return CachedHumanoid
				end
			end
		end
	end
end

--[[ Public API ]]--
function Thumbstick:Enable()
	ThumbstickFrame.Visible = true
end

function Thumbstick:Disable()
	ThumbstickFrame.Visible = false
	OnTouchEnded()
end

function Thumbstick:Create(parentFrame)
	if ThumbstickFrame then
		ThumbstickFrame:Destroy()
		ThumbstickFrame = nil
		if OnTouchMovedCn then
			OnTouchMovedCn:disconnect()
			OnTouchMovedCn = nil
		end
		if OnTouchEndedCn then
			OnTouchEndedCn:disconnect()
			OnTouchEndedCn = nil
		end
	end
		
	local isSmallScreen = parentFrame.AbsoluteSize.y <= 500
	local thumbstickSize = isSmallScreen and 70 or 120
	local position = isSmallScreen and UDim2.new(0, (thumbstickSize/2) - 10, 1, -thumbstickSize - 20) or
		UDim2.new(0, thumbstickSize/2, 1, -thumbstickSize * 1.75)
		
	ThumbstickFrame = Instance.new('Frame')
	ThumbstickFrame.Name = "ThumbstickFrame"
	ThumbstickFrame.Active = true
	ThumbstickFrame.Visible = false
	ThumbstickFrame.Size = UDim2.new(0, thumbstickSize, 0, thumbstickSize)
	ThumbstickFrame.Position = position
	ThumbstickFrame.BackgroundTransparency = 1
	
	local outerImage = Instance.new('ImageLabel')
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbstickSize, 0, thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = ThumbstickFrame
	
	StickImage = Instance.new('ImageLabel')
	StickImage.Name = "StickImage"
	StickImage.Image = TOUCH_CONTROL_SHEET
	StickImage.ImageRectOffset = Vector2.new(220, 0)
	StickImage.ImageRectSize = Vector2.new(111, 111)
	StickImage.BackgroundTransparency = 1
	StickImage.Size = UDim2.new(0, thumbstickSize/2, 0, thumbstickSize/2)
	StickImage.Position = UDim2.new(0, thumbstickSize/2 - thumbstickSize/4, 0, thumbstickSize/2 - thumbstickSize/4)
	StickImage.ZIndex = 2
	StickImage.Parent = ThumbstickFrame
	
	local centerPosition = nil
	local deadZone = 0.05
	local function doMove(direction)
		local inputAxis = direction / (thumbstickSize/2)
		
		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = inputAxis.magnitude
		if inputAxisMagnitude < deadZone then
			inputAxis = Vector3.new()
		else
			inputAxis = inputAxis.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			-- NOTE: Making inputAxis a unit vector will cause the player to instantly go max speed
			-- must check for zero length vector is using unit
			inputAxis = Vector3.new(inputAxis.x, 0, inputAxis.y)
		end
		
		local humanoid = getHumanoid()
		if humanoid then
			humanoid:Move(inputAxis, true)
		end
	end
	
	local function moveStick(pos)
		local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
		local length = relativePosition.magnitude
		local maxLength = ThumbstickFrame.AbsoluteSize.x/2
		if IsFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			ThumbstickFrame.Position = UDim2.new(
				0, pos.x - ThumbstickFrame.AbsoluteSize.x/2 - offset.x,
				0, pos.y - ThumbstickFrame.AbsoluteSize.y/2 - offset.y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		StickImage.Position = UDim2.new(0, relativePosition.x + StickImage.AbsoluteSize.x/2, 0, relativePosition.y + StickImage.AbsoluteSize.y/2)
	end
	
	-- input connections
	ThumbstickFrame.InputBegan:connect(function(inputObject)
		if MoveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		MoveTouchObject = inputObject
		ThumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - ThumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - ThumbstickFrame.Size.Y.Offset/2)
		centerPosition = Vector2.new(ThumbstickFrame.AbsolutePosition.x + ThumbstickFrame.AbsoluteSize.x/2,
			ThumbstickFrame.AbsolutePosition.y + ThumbstickFrame.AbsoluteSize.y/2)
		local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
		moveStick(inputObject.Position)
	end)
	
	OnTouchMovedCn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == MoveTouchObject then
			centerPosition = Vector2.new(ThumbstickFrame.AbsolutePosition.x + ThumbstickFrame.AbsoluteSize.x/2,
				ThumbstickFrame.AbsolutePosition.y + ThumbstickFrame.AbsoluteSize.y/2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			doMove(direction)
			moveStick(inputObject.Position)
		end
	end)
	
	OnTouchEnded = function()
		ThumbstickFrame.Position = position
		StickImage.Position = UDim2.new(0, ThumbstickFrame.Size.X.Offset/2 - thumbstickSize/4, 0, ThumbstickFrame.Size.Y.Offset/2 - thumbstickSize/4)
		MoveTouchObject = nil
		local humanoid = getHumanoid()
		if humanoid then
			humanoid:Move(Vector3.new(0, 0, 0), true)
		end
	end
	
	OnTouchEndedCn = UserInputService.TouchEnded:connect(function(inputObject, isProcessed)
		if inputObject == MoveTouchObject then
			OnTouchEnded()
		end
	end)
	
	ThumbstickFrame.Parent = parentFrame
end

return Thumbstick
]]></ProtectedString>
			</Properties>
		</Item>
	</Item>
</roblox>