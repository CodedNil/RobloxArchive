<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX4F1CA179C0BC4345A33D2CFCF8FA1E15">
		<Properties>
			<string name="Name">S3.0</string>
		</Properties>
		<Item class="Script" referent="RBX5B5270D6645B422388589C8796502B48">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Setup</string>
				<ProtectedString name="Source"><![CDATA[script.Parent:WaitForChild("Config").Parent = script:WaitForChild("S3Client")
script.S3Client.Parent = game.StarterPlayer.StarterPlayerScripts
script.NewCameraScript:Clone().Parent = game.StarterPlayer.StarterPlayerScripts

local cfnew, cfang = CFrame.new, CFrame.Angles
local rad = math.rad

local BaseAnim = {
	cfnew(-1.5, -0.2, 0) * cfang(rad(90), 0, 0),
	cfnew(1.5, 0, 0) * cfang(rad(90), 0, 0)
}
local HoldingAnim = {
	cfnew(0.3, 1.5, -0.3) * cfang(0, 0, rad(-65)),
	cfnew(0.4, 0.25, -0.3) * cfang(0, 0, rad(21))
}
local f1 = cfnew(0, 1.5, 0) * BaseAnim[1] * cfnew(0, 0, 1)
local f2 = cfnew(0, 1.5, 0) * BaseAnim[2] * cfnew(0, 0, 1)

local CameraEvent = Instance.new("RemoteEvent", game.ReplicatedStorage)
CameraEvent.Name = "AlterCameraEvent"

local WeldEvent = Instance.new("RemoteFunction", game.ReplicatedStorage)
WeldEvent.Name = "WeldArmsEvent"
function WeldEvent.OnServerInvoke(Player, Root)
	local LeftWeld = Instance.new("Weld", Root)
	LeftWeld.Part0 = Root
	
	local RightWeld = Instance.new("Weld", Root)
	RightWeld.Part0 = Root
	
	return LeftWeld, RightWeld
end

local ActiveEvent = Instance.new("RemoteFunction", game.ReplicatedStorage)
ActiveEvent.Name = "ActiveArmsEvent"
function ActiveEvent.OnServerInvoke(Player, Active, LeftShoulder, RightShoulder, LeftWeld, RightWeld, LeftArm, RightArm)
	if Active then
		LeftShoulder.Part1 = nil
		RightShoulder.Part1 = nil
		LeftWeld.Part1 = LeftArm
		RightWeld.Part1 = RightArm
		
		LeftWeld.C0 = f1
		LeftWeld.C1 = HoldingAnim[1]
		
		RightWeld.C0 = f2
		RightWeld.C1 = HoldingAnim[2]
	else
		if LeftShoulder then
			LeftShoulder.Part1 = LeftArm
		end
		if RightShoulder then
			RightShoulder.Part1 = RightArm
		end
		if LeftWeld then
			LeftWeld.Part1 = nil
		end
		if RightWeld then
			RightWeld.Part1 = nil
		end
	end
end]]></ProtectedString>
			</Properties>
			<Item class="LocalScript" referent="RBXCC44678655EF494EBAAAB33C070BD033">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">S3Client</string>
					<ProtectedString name="Source"><![CDATA[repeat wait() until _G.SRequire
local HookLib = _G.SRequire("HookLib", "HookLib")
local ArmBob, Anims, Movement, FireAnimation, BulletRay, Misc = require(script.ArmBob), require(script.Anims), require(script.Movement), require(script.FireAnimation), require(script.BulletRay), require(script.Misc)
local Config = require(script.Config)

game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)

local cfnew, cfang, v3new = CFrame.new, CFrame.Angles, Vector3.new
local rad, asin, random, max = math.rad, math.asin, math.random, math.max
local cfdnew = cfnew()

local Player = game.Players.LocalPlayer
repeat wait() until Player.Character
local Mouse = Player:GetMouse()
local Camera = workspace.CurrentCamera

local Character = Player.Character

local Humanoid, Root, Head, Torso, LeftArm, RightArm, LeftShoulder, RightShoulder
local Active, FirstPersonValues
local LeftWeld, RightWeld

local BaseAnim = {
	cfnew(-1.5, -0.2, 0) * cfang(rad(90), 0, 0),
	cfnew(1.5, 0, 0) * cfang(rad(90), 0, 0)
}
local t1, t2, t3 = cfnew(0, 1.5, 0), cfnew(0, 0, 1), cfang(0, rad(20), 0)

local d1 = BaseAnim[1] * t2
local d2 = BaseAnim[2] * t2
local f1 = t1 * d1
local f2 = t1 * d2

local function SetActive(Value)
	if Active == Value then
		return
	end
	Active = Value
	game.ReplicatedStorage.ActiveArmsEvent:InvokeServer(Active, LeftShoulder, RightShoulder, LeftWeld, RightWeld, LeftArm, RightArm)
end

game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Health, false)

local function NewCharacter(Character)
	Humanoid = Character:WaitForChild("Humanoid")
	Root = Character:WaitForChild("HumanoidRootPart")
	Head = Character:WaitForChild("Head")
	Torso = Character:WaitForChild("Torso")
	LeftArm = Character:WaitForChild("Left Arm")
	RightArm = Character:WaitForChild("Right Arm")
	LeftShoulder = Torso:WaitForChild("Left Shoulder")
	RightShoulder = Torso:WaitForChild("Right Shoulder")
	
	game:GetService("UserInputService").MouseIconEnabled = true
	game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.Default
	Camera.CameraType = Enum.CameraType.Custom
	
	Active = false
	FirstPerson = false
	Values = nil
	
	LeftArm.LocalTransparencyModifier = 0
	LeftArm.Changed:connect(function()
		LeftArm.LocalTransparencyModifier = 0
	end)
	RightArm.LocalTransparencyModifier = 0
	RightArm.Changed:connect(function()
		RightArm.LocalTransparencyModifier = 0
	end)
	
	for _, v in pairs(Character:GetChildren()) do
		if v.Name == "LeftArmPart" or v.Name == "RightArmPart" then
			v.LocalTransparencyModifier = 0
			v.Changed:connect(function()
				v.LocalTransparencyModifier = 0
			end)
		end
	end
	Character.ChildAdded:connect(function(v)
		if v.Name == "LeftArmPart" or v.Name == "RightArmPart" then
			v.LocalTransparencyModifier = 0
			v.Changed:connect(function()
				v.LocalTransparencyModifier = 0
			end)
		end
	end)
	
	LeftWeld, RightWeld = game.ReplicatedStorage.WeldArmsEvent:InvokeServer(Root)
end
Player.CharacterAdded:connect(NewCharacter)
NewCharacter(Character)

local Anim = Anims[1]
local Kick = cfdnew

local RenderStepped = game:GetService("RunService").RenderStepped

repeat wait() until tostring(Mouse.UnitRay.Direction.unit) ~= "NAN, NAN, NAN"
RenderStepped:connect(function()
	if Active and FirstPerson then
		local Ang = t1 * cfang(asin(Mouse.UnitRay.Direction.unit.y), 0, 0)
		local Sway = ArmBob(Humanoid)
		
		LeftWeld.C0 = Ang * Kick * Sway * d1
		LeftWeld.C1 = Anim[1]
		
		RightWeld.C0 = Ang * Kick * Sway * d2
		RightWeld.C1 = Anim[2]
	end
end)

if Config.BulletOverride then
	HookLib.AddHook("SharedWeaponVisuals", "WeaponBulletRay", function(Module, User, Barrel, Hit, End, Normal, Material, Offset, Humanoid, BulNum)
		spawn(function()
			BulletRay(Module, Barrel, Hit, End, Normal, Material, Offset, Humanoid, BulNum)
		end)
	end)
end

local j1 = cfnew(0, 0.3025, 0) * cfang(0, 0, rad(30)) * cfnew(0, -0.3025, 0)

local UID = 0
HookLib.AddHook("ClientWeaponVisuals", "FireAnimation", function(Weapon, Start, End, Normal, Hit, Offset, Humanoid, BulNum)
	local NewKick = FireAnimation(Weapon.ShotRecoil/70, Active, Config.CameraRecoil)
	delay(0.06, function()
		NewKick = cfdnew
	end)
	
	spawn(function()
		if NewKick ~= Kick then
			local Start = Kick
			
			local LocalID = random()
			UID = LocalID
			for i = 1, 8 do
				if LocalID ~= UID then
					break
				end
				local p = i/8
				Kick = Start:lerp(NewKick, p)
				RenderStepped:wait()
			end
		end
	end)
end)

local UniqueID = 0

local Freefall, Jumping = Enum.HumanoidStateType.Freefall, Enum.HumanoidStateType.Jumping
local function Update(New)
	if not FirstPerson and not Movement.Aiming then
		local Grip = RightArm:FindFirstChild("RightGrip")
		if Grip then
			Grip.C1 = t3
		end
	end
	if not Active or not FirstPerson then
		return
	end
	
	local TrueAnim, TrueGrip = Anims[1], t3
	if New == Freefall or New == Jumping or Movement.Sprinting then
		TrueAnim = Anims[3]
		TrueGrip = t3
	elseif Movement.Aiming then
		TrueAnim = Anims[2]
		TrueGrip = Values.GripCFrame
	end
	
	local Grip = RightArm:FindFirstChild("RightGrip")
	if TrueAnim ~= Anim then
		local Start = Anim
		local StartGrip = Grip and Grip.C1
		
		local LocalID = random()
		UniqueID = LocalID
		for i = 1, 8 do
			if LocalID ~= UniqueID then
				break
			end
			local p = i/8
			Anim = {
				Start[1]:lerp(TrueAnim[1], p),
				Start[2]:lerp(TrueAnim[2], p)
			}
			if Grip then
				Grip.C1 = StartGrip:lerp(TrueGrip, p)
			end
			RenderStepped:wait()
		end
	end
end

function _G.ZoomChanged(Zoom)
	if Zoom > 1 and FirstPerson then
		FirstPerson = false
		
		LeftWeld.C0 = f1
		LeftWeld.C1 = Anims[1][1]
		
		RightWeld.C0 = f2
		RightWeld.C1 = Anims[1][2]
		
		if Movement.Aiming then
			Movement.ChangeAim(Enum.UserInputState.End)
		end
		
		Update()
	elseif Zoom < 1 and not FirstPerson then
		FirstPerson = true
	end
end

local h1 = cfnew(0, -1, 0)

local MainAnim = BaseAnim[2] * Anims[2][2]:inverse() * cfnew(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)

local WeaponGrips = {}
local Selected = false

local Draw = Instance.new("Sound", Player.PlayerGui)
Draw.SoundId = "rbxassetid://169799883"
HookLib.AddHook("WeaponSelected", "S3.0", function(Weapon)
	if not Selected then
		Selected = true
		
		local Tool = Weapon.Module.Parent
		local AimPart = Tool:FindFirstChild("AimPart")
		if not WeaponGrips[Tool.Name] and AimPart then
			local HandleCFrame = (Head.CFrame * h1) * MainAnim
			local HandleOffset = AimPart.CFrame:toObjectSpace(Tool.Handle.CFrame)
			WeaponGrips[Tool.Name] = (Head.CFrame * HandleOffset):toObjectSpace(HandleCFrame)
		end
		
		if AimPart then
			Values = require(Weapon.Module)
			Values.GripCFrame = WeaponGrips[Tool.Name]
			
			SetActive(true)
			RightArm:WaitForChild("RightGrip").C1 = t3
			
			Movement.Sensitivity = Values.Sensitivity or 0.5
			Movement.FOVBoost = Values.FOVBoost and (Values.FOVBoost + 20) or 20
			
			Update()
			
			if Tool.Handle:FindFirstChild("Open") then
				Tool.Handle.Open:Play()
			else
				Draw:Play()
			end
			
			if Values.MoveSpeed then
				Movement.MoveModifier = Values.MoveSpeed
				Movement.UpdateMoveSpeed()
			end
		end
	end
end)

HookLib.AddHook("WeaponDeselected", "S3.0", function(Weapon)
	if Selected and Weapon.Module then
		Selected = false
		
		SetActive(false)
		
		local Tool = Weapon.Module.Parent
		if Tool.Handle:FindFirstChild("Close") then
			Tool.Handle.Close:Play()
		end
	
		Movement.Sensitivity = 1
		Movement.FOVBoost = 0
		Movement.ChangeAim(Enum.UserInputState.End)
		Movement.MoveModifier = 1
		Movement.UpdateMoveSpeed()
	end
end)

function NewChar(Character)
	Selected = false
	
	Humanoid = Character:WaitForChild("Humanoid")
	
	if Config.AntiBunnyhop then
		local Last = 0
		Humanoid.Changed:connect(function(Property)
			local t = tick()
			if Property == "Jump" then
				if t - Last < 1 then
					Humanoid.Jump = false
				else
					Last = t
				end
			end
		end)
	end
	
	Humanoid.StateChanged:connect(function(Old, New)
		Update(New)
	end)
	
	Movement.Sensitivity = 1
	Movement.FOVBoost = 0
	Movement.ChangeAim(Enum.UserInputState.End)
	Movement.MoveModifier = 1
	Movement.UpdateMoveSpeed()
end
Player.CharacterAdded:connect(NewChar)
NewChar(Character)

Movement.SprintChanged.Event:connect(Update)
Movement.AimChanged.Event:connect(Update)]]></ProtectedString>
				</Properties>
				<Item class="ModuleScript" referent="RBXA0B5E18FC9B34C2B9EDA1D4A2911CA45">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ArmBob</string>
						<ProtectedString name="Source"><![CDATA[local Movement = require(script.Parent.Movement)

local Freefall, Jumping = Enum.HumanoidStateType.Freefall, Enum.HumanoidStateType.Jumping

local cfnew, cfang, v3new = CFrame.new, CFrame.Angles, Vector3.new
local rad, abs, sin = math.rad, math.abs, math.sin

local Sway, State = 0, "Idling"
local function GetSway()
	if State == "Idling" then
		return cfnew(rad(sin(Sway))/2, rad(sin(Sway * 2.5))/2, 0)
	elseif State == "Walking" then
		return cfnew(rad(sin(Sway)) * 2, rad(abs(sin(Sway))) * 2, 0) * cfang(0, rad(sin(Sway))/3, 0)
	elseif State == "Running" then
		return cfnew(sin(Sway)/6, abs(sin(Sway))/5 - 0.1, 0) * cfang(0, -rad(sin(Sway)) * 7, 0)
	elseif State == "AimedIdleing" then
		return cfnew(0, 0, 0)
	elseif State == "AimedWalking" then
		return cfnew(rad(sin(Sway))/3, rad(abs(sin(Sway)))/3, 0)
	end
	return cfnew()
end

return function(Humanoid)
	local SwayAdd = 0.04
	
	local HumanoidState = Humanoid:GetState()
	if HumanoidState == Freefall or HumanoidState == Jumping then
		State = "Running"
		SwayAdd = 0.06
	elseif Movement.Sprinting then
		State = "Running"
		SwayAdd = 0.18
	elseif Humanoid.MoveDirection.magnitude > 0 then
		State = "Walking"
		SwayAdd = 0.12
	else
		State = "Idling"
	end
	if Movement.Aiming then
		State = "Aimed"..State
		SwayAdd = SwayAdd/2
		if State == "AimedIdleing" then
			SwayAdd = 0.01
		end
	end
	
	Sway = Sway + SwayAdd
	
	return GetSway()
end]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAB34EC9602F244F294CC768F3B9B5666">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Anims</string>
						<ProtectedString name="Source"><![CDATA[local Freefall, Jumping = Enum.HumanoidStateType.Freefall, Enum.HumanoidStateType.Jumping

local cfnew, cfang = CFrame.new, CFrame.Angles
local rad = math.rad

local HoldingAnim = {
	cfnew(0.3, 1.5, -0.3) * cfang(0, 0, rad(-65)),
	cfnew(0.4, 0.25, -0.3) * cfang(0, 0, rad(21))
}
local AimingAnim = {
	cfnew(-0.1, 1.2, 0.1) * cfang(0, 0, rad(-35)),
	cfnew(0.3, 0.707, -0.01) * cfang(0, 0, rad(50))
}
local SprintingAnim = {
	cfnew(0, 0.63, 0) * cfang(rad(45), rad(-30), rad(-25)),
	cfnew(0, 0.5, 0) * cfang(rad(30), 0, rad(55))
}

return {HoldingAnim, AimingAnim, SprintingAnim}]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX11AC8F78903445F39A680B9E2A8A5E64">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Movement</string>
						<ProtectedString name="Source"><![CDATA[local Animator = require(script.Parent.TweenModule)
local Config = require(script.Parent.Config)

local Player = game.Players.LocalPlayer
local Camera = game.workspace.CurrentCamera
local Mouse = Player:GetMouse()
repeat wait() until Player.Character
local Humanoid = Player.Character:WaitForChild("Humanoid")

local module = {}

module.FOVBoost = 0
module.Sensitivity = 1

module.MoveModifier = 1

module.Sprinting = false
module.Aiming = false

module.SprintChanged = Instance.new('BindableEvent')
module.AimChanged = Instance.new('BindableEvent')

local UIS = game:GetService("UserInputService")

local Freefall, Jumping = Enum.HumanoidStateType.Freefall, Enum.HumanoidStateType.Jumping
local Speed = 0

_G.MouseSensitivity = _G.MouseSensitivity or function() end

local function SprintKey(State)
	if not Config.SpeedModifiers then
		return
	end
	if State == Enum.UserInputState.Begin and not module.Sprinting then
		if module.Aiming or module.MoveModifier < 0.85 or Speed < 3 then
			return
		end
		module.Sprinting = true
		module.SprintChanged:Fire(true)
	elseif State == Enum.UserInputState.End and module.Sprinting then
		module.Sprinting = false
		module.SprintChanged:Fire(false)
	end
	module.UpdateMoveSpeed()
end

function module.UpdateMoveSpeed()
	if not Humanoid or not Config.SpeedModifiers then
		return
	end
	if module.Sprinting and module.MoveModifier < 0.85 then
		SprintKey(Enum.UserInputState.End)
	end
	
	local Speed = 16
	if module.Sprinting then
		Speed = 20
	end
	if module.Aiming then
		Speed = Speed * 0.7
	end
	Humanoid.WalkSpeed = Speed * module.MoveModifier
end

local function AimKey(State)
	if not Config.Zoom or (Camera.CoordinateFrame.p - Camera.Focus.p).magnitude > 0.8 then
		return
	end
	if module.FOVBoost == 0 then
		return
	end
	
	SprintKey(Enum.UserInputState.End)
	if State == Enum.UserInputState.Begin and not module.Aiming then
		local HumanoidState = Player.Character.Humanoid:GetState()
		if HumanoidState == Freefall or HumanoidState == Jumping then
			return
		end
		module.Aiming = true
		module.AimChanged:Fire(true)
		Animator.TweenNumber(Camera, "FieldOfView", 70 - module.FOVBoost, 0.2, true)
		
		_G.MouseSensitivity(module.Sensitivity)
		
		local Cursor = game.Players.LocalPlayer.PlayerGui.GunCursor.Center
		Cursor.BackgroundTransparency = 1
		for _, v in ipairs(Cursor:GetChildren()) do
			if not v.Name:find("Diag") then
				v.Visible = false
			end
		end
	elseif State == Enum.UserInputState.End and module.Aiming then
		module.Aiming = false
		module.AimChanged:Fire(false)
		Animator.TweenNumber(Camera, "FieldOfView", 70, 0.2, true)
		
		_G.MouseSensitivity(1)
		
		local Cursor = game.Players.LocalPlayer.PlayerGui.GunCursor.Center
		Cursor.BackgroundTransparency = 0.5
		for _, v in ipairs(Cursor:GetChildren()) do
			if not v.Name:find("Diag") then
				v.Visible = true
			end
		end
	end
	module.UpdateMoveSpeed()
end

function module.ChangeAim(State)
	AimKey(State)
end

UIS.InputBegan:connect(function(Input, Processed)
	if Processed then
		return
	end
	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		AimKey(Input.UserInputState)
	elseif Input.UserInputType == Enum.UserInputType.Keyboard then
		if Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.RightShift then
			SprintKey(Input.UserInputState)
		end
	end
end)

UIS.InputEnded:connect(function(Input, Processed)
	if Processed then
		return
	end
	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		AimKey(Input.UserInputState)
	elseif Input.UserInputType == Enum.UserInputType.Keyboard then
		if Input.KeyCode == Enum.KeyCode.W or Input.KeyCode == Enum.KeyCode.Up then
			SprintKey(Enum.UserInputState.End)
		elseif Input.KeyCode == Enum.KeyCode.LeftShift or Input.KeyCode == Enum.KeyCode.RightShift then
			SprintKey(Input.UserInputState)
		end
	end
end)

local function NewCharacter(Character)
	SprintKey(Enum.UserInputState.End)
	AimKey(Enum.UserInputState.End)
	
	Humanoid = Character:WaitForChild("Humanoid")
	Humanoid.Jumping:connect(function(Active)
		AimKey(Enum.UserInputState.End)
	end)
	Humanoid.Running:connect(function(Spd)
		Speed = Spd
	end)
end
Player.CharacterAdded:connect(NewCharacter)
NewCharacter(Player.Character)

return module]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8BF9F5F7F25A4596AAE7408FC9B1EB12">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FireAnimation</string>
						<ProtectedString name="Source"><![CDATA[local Movement = require(script.Parent.Movement)

local cfnew, cfang = CFrame.new, CFrame.Angles
local rad, random, min = math.rad, math.random, math.min

local Camera = workspace.CurrentCamera
local RenderStepped = game:GetService("RunService").RenderStepped
local function RotateCamera(RotX, RotY, Duration, Active)
	spawn(function()
		local TweenIndicator = nil
		local NewCode = math.random(-1e9, 1e9)
		if (not Camera:FindFirstChild("TweenCode")) then
			TweenIndicator = Instance.new("IntValue")
			TweenIndicator.Name = "TweenCode"
			TweenIndicator.Value = NewCode
			TweenIndicator.Parent = Camera
		else
			TweenIndicator = Camera.TweenCode
			TweenIndicator.Value = NewCode
		end
		
		local Step = math.min(1.5 / math.max(Duration, 0), 90)
		local X = 0
		while true do
			local NewX = X + Step
			X = NewX > 90 and 90 or NewX
			if TweenIndicator.Value ~= NewCode or not Active then
				break
			end
			
			local CamRot = Camera.CoordinateFrame - Camera.CoordinateFrame.p
			local CamDist = (Camera.CoordinateFrame.p - Camera.Focus.p).magnitude
			local NewCamCF = cfnew(Camera.Focus.p) * CamRot * cfang(RotX / (90 / Step), RotY / (90 / Step), 0)
			Camera.CoordinateFrame = cfnew(NewCamCF.p, NewCamCF.p + NewCamCF.lookVector) * cfnew(0, 0, CamDist)
			
			if X == 90 then break end
			RenderStepped:wait()
		end
		
		if TweenIndicator.Value == NewCode then
			TweenIndicator:Destroy()
		end
	end)
end

local function arandom(Min, Max, Accuracy)
	local Inverse = 1 / (Accuracy or 1)
	return (random(Min * Inverse, Max * Inverse) / Inverse)
end

return function(Amount, Active, Camera)
	if Camera then
		local rx, ry = arandom(0.015, 0.03, 0.001), arandom(-0.006, 0.006, 0.0001)
		RotateCamera(rx * (Movement.Aiming and 0.4 or 0.6), ry, 0.06, Active)
		delay(0.05, function()
			RotateCamera(-rx/4, -ry/4, 0.1, Active)
		end)
	end
	
	local RecoilAmount = Movement.Aiming and 2 or 2.5
	
	Amount = min(4, Amount)/2
	
	local KickSide = random(1, 5)/20 * (random(0, 1) == 0 and -1 or 1) * RecoilAmount
	local KickBack = arandom(0.13, 0.17, 0.01) * RecoilAmount * 0.15
	local KickUp = rad(arandom(1.3, 1.4, 0.01)) * RecoilAmount * Amount
	
	return cfnew(0, 0, KickBack) * cfang(KickUp, KickSide * 0.05, 0 )
end]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX70E3A8AF625C48579DCB24940786E958">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BulletRay</string>
						<ProtectedString name="Source"><![CDATA[local GunCore = _G.SRequire("S2.0 GunCore", "GunCore")

local cfnew, cfang, v3new, c3new, csnew, nsnew = CFrame.new, CFrame.Angles, Vector3.new, Color3.new, ColorSequence.new, NumberSequence.new
local random, floor, min, max, rad = math.random, math.floor, math.min, math.max, math.rad

local RenderStepped = game:GetService("RunService").RenderStepped

local function PlaySoundAtPos(Position, Sound)
	local Part = Instance.new("Part", workspace)
	Part.Anchored = true
	Part.CanCollide = false
	Part.Transparency = 1
	Part.CFrame = CFrame.new(Position)
	Part.FormFactor = Enum.FormFactor.Custom
	Part.Size = Vector3.new()
	
	local New = script[Sound]:Clone()
	New.Parent = Part
	New:Play()
	
	delay(New.TimeLength + 0.1, function() Part:Destroy() end)
end

local DefaultColor = Color3.new(1, 0.8, 0)
local t1, t2, t3, t4, t5, t6 = cfnew(0, 0, -0.05), 15/255, 5/255, ColorSequence.new(Color3.new(0.9, 0.9, 0.9)), NumberSequence.new(0.8), NumberSequence.new({NumberSequenceKeypoint.new(0, 0.4, 0.2), NumberSequenceKeypoint.new(0.28, 0.4, 0.063), NumberSequenceKeypoint.new(1, 0, 0)})
return function(Module, Barrel, Hit, End, Normal, Material, Offset, Humanoid, BulNum)
	local Adornee = GunCore:GetBoxAdornee()
	
	if not Barrel:FindFirstChild("FireParticle") then
		script.FireParticle:Clone().Parent = Barrel
	end
	if not Barrel:FindFirstChild("SmokeParticle") then
		script.SmokeParticle:Clone().Parent = Barrel
	end
	local IsOriginal = not Barrel:FindFirstChild("HitParticle")
	local SHitParticle = Barrel:FindFirstChild("HitParticle") or script.HitParticle
	
	spawn(function()
		wait()
		Barrel.FireParticle:Emit(40)
		wait(0.1)
		for i = 1, 15 do
			Barrel.SmokeParticle:Emit(max(16 - i, 1))
			wait(0.08)
		end
	end)
	
	local Weapon = require(Module)
	local Color, Thickness, Length = Weapon.EffectColor or DefaultColor, Weapon.EffectThickness or 1, Weapon.EffectLength or 1
	
	local Start = Barrel.Position
	local Distance = (Start - End).magnitude
	
	if Weapon.EffectType == "Lightning" then
		local Vec = (End - Start)
		local Distance = Vec.magnitude
		local Direction = Vec.unit
		
		local PX, PY, PZ = (Start + (0.25 * Distance) * Direction), (Start + (0.5 * Distance) * Direction), (Start + (0.75 * Distance) * Direction)
		
		local DX, DY, DZ = (Start - PX).magnitude, (PX - PY).magnitude, (PY - PZ).magnitude
		
		local Limit = 2
		local AX = (PX + v3new(random(max(-Limit, (-0.21 * DX)), min(Limit, (0.21 * DX))), random(max(-Limit, (-0.21 * DX)), min(Limit, (0.21 * DX))), random(max(-Limit, (-0.21 * DX)), min(Limit, (0.21 * DX)))))
		local AY = (PY + v3new(random(max(-Limit, (-0.21 * DY)), min(Limit, (0.21 * DY))), random(max(-Limit, (-0.21 * DY)), min(Limit, (0.21 * DY))), random(max(-Limit, (-0.21 * DY)), min(Limit, (0.21 * DY)))))
		local AZ = (PZ + v3new(random(max(-Limit, (-0.21 * DZ)), min(Limit, (0.21 * DZ))), random(max(-Limit, (-0.21 * DZ)), min(Limit, (0.21 * DZ))), random(max(-Limit, (-0.21 * DZ)), min(Limit, (0.21 * DZ)))))
		
		local Rays = {
			{Distance = (AX - Start).magnitude, Direction = cfnew(Start, AX)},
			{Distance = (AY - AX).magnitude, Direction = cfnew(AX, AY)},
			{Distance = (AZ - AY).magnitude, Direction = cfnew(AY, AZ)},
			{Distance = (End - AZ).magnitude, Direction = cfnew(AZ, End)},
		}
		for i, v in pairs(Rays) do
			local Bullet = Instance.new("LineHandleAdornment", Adornee)
			Bullet.Adornee = Adornee
			Bullet.Color3 = Color
			Bullet.Transparency = 0.2
			Bullet.Name = "GunBullet"
			Bullet.Thickness = 2 * Thickness
			Bullet.Length = v.Distance
			Bullet.CFrame = v.Direction
			delay(1, function()
				Bullet:Destroy()
			end)
		end
	else
		local Speed = random(60, 120)/7 * (Weapon.EffectSpeed or 1)
		if floor(Distance/Speed) > 0 then
			local Bullet = Instance.new("LineHandleAdornment", Adornee)
			Bullet.Adornee = Adornee
			Bullet.Color3 = Color
			Bullet.Transparency = 0.2
			Bullet.Name = "GunBullet"
			Bullet.Thickness = 2 * Thickness
			Bullet.Length = min(40 * Length, Distance)
			Bullet.CFrame = cfnew(Start, End)
			
			wait()
			for i = 1, floor(Distance/Speed) - 1 do
				Bullet.CFrame = Bullet.CFrame + Bullet.CFrame.lookVector * Speed
				Distance = Distance - Speed
				Bullet.Length = min(40 * Length, Distance)
				
				RenderStepped:wait()
			end
			Bullet:Destroy()
		end
	end
	if Hit then
		if Hit.Anchored then
			local Diff = Normal - Hit.CFrame.lookVector
			local Ang = cfang(0, 0, rad(random(0, 360))) * t1
			
			local Hole = Instance.new("ImageHandleAdornment", Adornee)
			Hole.Adornee = Adornee
			Hole.Image = "rbxassetid://247450445"
			Hole.CFrame = cfnew(Hit.CFrame * Offset, Hit.CFrame * Offset + Normal) * Ang
			Hit.Changed:connect(function(Property)
				if Property == "CFrame" then
					if Diff == v3new() then
						Hole.CFrame = cfnew(Hit.CFrame * Offset, Hit.CFrame * Offset + Hit.CFrame.lookVector) * Ang
					else
						Hole.CFrame = cfnew(Hit.CFrame * Offset, Hit.CFrame * Offset + Normal) * Ang
					end
				end
			end)
			delay(5, function()
				for i = 1, 10 do
					Hole.Transparency = i/10
					wait()
				end
				Hole:Destroy()
			end)
		end
		
		local Emitter = script.Emitter:Clone()
		Emitter.Parent = Adornee
		Emitter.CFrame = cfnew(End, Start)
		
		if Humanoid and Humanoid:IsA("Humanoid") then
			PlaySoundAtPos(End, "BulletHitFlesh")
			spawn(function()
				local HitParticle = script.BloodParticle:Clone()
				HitParticle.Parent = Emitter
				wait()
				HitParticle:Emit(20)
				wait(1)
				Emitter:Destroy()
			end)
			if IsOriginal then
				spawn(function()
					local HitParticle = SHitParticle:Clone()
					HitParticle.Parent = Emitter
					wait()
					HitParticle:Emit(20)
					wait(2)
					Emitter:Destroy()
				end)
			end
		elseif Material == Enum.Material.Metal or Material == Enum.Material.CorrodedMetal or Material == Enum.Material.DiamondPlate then
			PlaySoundAtPos(End, "BulletHitMetal")
			if IsOriginal then
				spawn(function()
					local HitParticle = SHitParticle:Clone()
					HitParticle.Parent = Emitter
					HitParticle.Color = csnew(c3new(Hit.BrickColor.r - t2, Hit.BrickColor.g - t2, Hit.BrickColor.b - t2))
					HitParticle.Transparency = nsnew(Hit.Transparency)
					wait()
					HitParticle:Emit(20)
					wait(2)
					Emitter:Destroy()
				end)
			end
		elseif Material == Enum.Material.Wood or Material == Enum.Material.WoodPlanks then
			PlaySoundAtPos(End, "BulletHitWood")
				if IsOriginal then
				spawn(function()
					local HitParticle = SHitParticle:Clone()
					HitParticle.Parent = Emitter
					HitParticle.LightEmission = 0.1
					HitParticle.Color = csnew(c3new(Hit.BrickColor.r - t3, Hit.BrickColor.g - t3, Hit.BrickColor.b - t3))
					HitParticle.Transparency = nsnew(Hit.Transparency)
					wait()
					HitParticle:Emit(20)
					wait(2)
					Emitter:Destroy()
				end)
			end
		elseif Material == Enum.Material.Glacier or Material == Enum.Material.Ice or Material == Enum.Material.Neon or Hit.Transparency > 0 then
			PlaySoundAtPos(End, "BulletHitGlass")
			if IsOriginal then
				spawn(function()
					local HitParticle = SHitParticle:Clone()
					HitParticle.Parent = Emitter
					HitParticle.Color = t4
					HitParticle.Transparency = t5
					HitParticle.Size = t6
					wait()
					HitParticle:Emit(20)
					wait(2)
					Emitter:Destroy()
				end)
			end
		else
			PlaySoundAtPos(End, "BulletHitConcrete")
			if IsOriginal then
				spawn(function()
					local HitParticle = SHitParticle:Clone()
					HitParticle.Parent = Emitter
					HitParticle.Color = csnew(c3new(Hit.BrickColor.r - t2, Hit.BrickColor.g - t2, Hit.BrickColor.b - t2))
					HitParticle.Transparency = nsnew(Hit.Transparency)
					wait()
					HitParticle:Emit(20)
					wait(2)
					Emitter:Destroy()
				end)
			end
		end
		if not IsOriginal then
			spawn(function()
				local HitParticle = SHitParticle:Clone()
				HitParticle.Parent = Emitter
				wait()
				HitParticle:Emit(20)
				wait(2)
				Emitter:Destroy()
			end)
		end
	end
end]]></ProtectedString>
					</Properties>
					<Item class="Sound" referent="RBX63207753743D41F482302D6BAA4DB5CC">
						<Properties>
							<bool name="Looped">false</bool>
							<float name="MaxDistance">0</float>
							<float name="MinDistance">0</float>
							<string name="Name">BulletHitConcrete</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>rbxassetid://142082166</url></Content>
							<float name="Volume">0.600000024</float>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX8452468A393E4825A60CD02110F630AB">
						<Properties>
							<bool name="Looped">false</bool>
							<float name="MaxDistance">0</float>
							<float name="MinDistance">0</float>
							<string name="Name">BulletHitGlass</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>rbxassetid://142082167</url></Content>
							<float name="Volume">0.600000024</float>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX2DE7878A399047D2A3CFB97674119957">
						<Properties>
							<bool name="Looped">false</bool>
							<float name="MaxDistance">0</float>
							<float name="MinDistance">0</float>
							<string name="Name">BulletHitMetal</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>rbxassetid://142082170</url></Content>
							<float name="Volume">0.200000003</float>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBX36BC0A40F7574AC39BC8E6258C577C53">
						<Properties>
							<bool name="Looped">false</bool>
							<float name="MaxDistance">0</float>
							<float name="MinDistance">0</float>
							<string name="Name">BulletHitWood</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>rbxassetid://142082171</url></Content>
							<float name="Volume">0.400000006</float>
						</Properties>
					</Item>
					<Item class="Sound" referent="RBXBDE9AD29631949F39EE3A32BC363504A">
						<Properties>
							<bool name="Looped">false</bool>
							<float name="MaxDistance">0</float>
							<float name="MinDistance">0</float>
							<string name="Name">BulletHitFlesh</string>
							<float name="Pitch">1</float>
							<bool name="PlayOnRemove">false</bool>
							<Content name="SoundId"><url>rbxassetid://144884872</url></Content>
							<float name="Volume">0.600000024</float>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX05360EF3284347D09BB9AE8A9752C8FB">
						<Properties>
							<bool name="Anchored">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">194</int>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">false</bool>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<token name="Material">256</token>
							<string name="Name">Emitter</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">1</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">3</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="ParticleEmitter" referent="RBX57108DF1FA7E4065B6FB8854DD27D1AB">
						<Properties>
							<Vector3 name="Acceleration">
								<X>0</X>
								<Y>-10</Y>
								<Z>0</Z>
							</Vector3>
							<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
							<float name="Drag">0</float>
							<token name="EmissionDirection">5</token>
							<bool name="Enabled">false</bool>
							<NumberRange name="Lifetime">0.1 0.3 </NumberRange>
							<float name="LightEmission">0.800000012</float>
							<bool name="LockedToPart">false</bool>
							<string name="Name">HitParticle</string>
							<float name="Rate">0</float>
							<NumberRange name="RotSpeed">-100 100 </NumberRange>
							<NumberRange name="Rotation">0 360 </NumberRange>
							<NumberSequence name="Size">0 0.2 0.2 0.279 0.2 0.0625 1 0 0 </NumberSequence>
							<NumberRange name="Speed">4 6 </NumberRange>
							<Content name="Texture"><url>rbxasset://textures/particles/sparkles_main.dds</url></Content>
							<NumberSequence name="Transparency">0 0.10625 0 0.637 0.337 0 0.876559 0.63125 0 1 1 0 </NumberSequence>
							<float name="VelocityInheritance">0</float>
							<float name="VelocitySpread">80</float>
							<float name="ZOffset">0</float>
						</Properties>
					</Item>
					<Item class="ParticleEmitter" referent="RBXC03D08ACCC6247159657B10502994F37">
						<Properties>
							<Vector3 name="Acceleration">
								<X>0</X>
								<Y>-50</Y>
								<Z>0</Z>
							</Vector3>
							<ColorSequence name="Color">0 0.584314 0 0 0 1 0.470588 0 0 0 </ColorSequence>
							<float name="Drag">0</float>
							<token name="EmissionDirection">5</token>
							<bool name="Enabled">false</bool>
							<NumberRange name="Lifetime">0.3 0.6 </NumberRange>
							<float name="LightEmission">0</float>
							<bool name="LockedToPart">false</bool>
							<string name="Name">BloodParticle</string>
							<float name="Rate">50</float>
							<NumberRange name="RotSpeed">0 0 </NumberRange>
							<NumberRange name="Rotation">0 0 </NumberRange>
							<NumberSequence name="Size">0 0.111111 0.0555557 0.755408 0.111111 0.111111 1 0 0 </NumberSequence>
							<NumberRange name="Speed">5 15 </NumberRange>
							<Content name="Texture"><url>http://www.roblox.com/asset/?id=271522063</url></Content>
							<NumberSequence name="Transparency">0 0.11875 0 0.199695 0 0 0.699695 0 0 0.877806 0.21875 0 0.962594 0.51875 0 1 1 0 </NumberSequence>
							<float name="VelocityInheritance">0</float>
							<float name="VelocitySpread">25</float>
							<float name="ZOffset">0</float>
						</Properties>
					</Item>
					<Item class="ParticleEmitter" referent="RBXFF4DED6570E74F01B4BE5AA949AE0FC1">
						<Properties>
							<Vector3 name="Acceleration">
								<X>0</X>
								<Y>0.400000006</Y>
								<Z>0</Z>
							</Vector3>
							<ColorSequence name="Color">0 0.615686 0.427451 0.12549 0 1 0.615686 0.235294 0.156863 0 </ColorSequence>
							<float name="Drag">0</float>
							<token name="EmissionDirection">5</token>
							<bool name="Enabled">false</bool>
							<NumberRange name="Lifetime">0.1 0.2 </NumberRange>
							<float name="LightEmission">0.5</float>
							<bool name="LockedToPart">false</bool>
							<string name="Name">FireParticle</string>
							<float name="Rate">20</float>
							<NumberRange name="RotSpeed">10 20 </NumberRange>
							<NumberRange name="Rotation">0 360 </NumberRange>
							<NumberSequence name="Size">0 0.2 0 1 0.2 0 </NumberSequence>
							<NumberRange name="Speed">20 25 </NumberRange>
							<Content name="Texture"><url>rbxasset://textures/particles/sparkles_main.dds</url></Content>
							<NumberSequence name="Transparency">0 0 0 0.305486 0.13125 0.0562 0.687032 0.375 0.1 0.910224 0.66875 0.1 1 0.9 0.1 </NumberSequence>
							<float name="VelocityInheritance">0.200000003</float>
							<float name="VelocitySpread">25</float>
							<float name="ZOffset">0</float>
						</Properties>
					</Item>
					<Item class="ParticleEmitter" referent="RBXA946EE2A6F0C4027B290F40F9E2F769F">
						<Properties>
							<Vector3 name="Acceleration">
								<X>0</X>
								<Y>3</Y>
								<Z>0</Z>
							</Vector3>
							<ColorSequence name="Color">0 0.168627 0.168627 0.168627 0 1 0.584314 0.584314 0.584314 0 </ColorSequence>
							<float name="Drag">0</float>
							<token name="EmissionDirection">5</token>
							<bool name="Enabled">false</bool>
							<NumberRange name="Lifetime">1 1 </NumberRange>
							<float name="LightEmission">0.200000003</float>
							<bool name="LockedToPart">false</bool>
							<string name="Name">SmokeParticle</string>
							<float name="Rate">20</float>
							<NumberRange name="RotSpeed">10 20 </NumberRange>
							<NumberRange name="Rotation">0 360 </NumberRange>
							<NumberSequence name="Size">0 0 0 0.133005 0.0624996 0 1 0.125 0 </NumberSequence>
							<NumberRange name="Speed">0.1 0.2 </NumberRange>
							<Content name="Texture"><url>rbxasset://textures/particles/smoke_main.dds</url></Content>
							<NumberSequence name="Transparency">0 0.1 0.1 0.280549 0.3875 0.1 0.46384 0.6375 0.1 0.589776 0.83125 0.1 0.770574 0.9625 0.0375 1 1 0 </NumberSequence>
							<float name="VelocityInheritance">0.300000012</float>
							<float name="VelocitySpread">5</float>
							<float name="ZOffset">0</float>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX6E13038014B442F8AF3D96D448A44CCA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Misc</string>
						<ProtectedString name="Source"><![CDATA[repeat wait() until _G.SRequire
local HookLib = _G.SRequire("HookLib", "HookLib")
local GunCore = _G.SRequire("S2.0 GunCore", "GunCore")
local Movement = require(script.Parent.Movement)

HookLib.RemoveHook("ClientWeaponVisuals", "WeaponCameraOffset")
HookLib.RemoveHook("SharedWeaponVisuals", "WeaponFireParticles")
HookLib.RemoveHook("SharedWeaponVisuals", "WeaponMuzzleFlash")
HookLib.RemoveHook("SharedWeaponVisuals", "BulletHitSound")
HookLib.RemoveHook("SharedWeaponVisuals", "WeaponBulletHit")
HookLib.AddHook("ClientWeaponVisuals", "WeaponHitMarker", function(Weapon, Barrel, Hit, End, Normal, Material, Offset, Humanoid, BulNum)
	if Humanoid and not Humanoid:FindFirstChild("HitSound") then
		delay(0.1, function()
			local GunCursor = Weapon.User.PlayerGui:FindFirstChild("GunCursor")
			
			if GunCursor and not Movement.Aiming then
				local CurHit = tick()
				Weapon.CurHit = CurHit
				
				GunCursor.Center.TopDiag.Visible = true
				GunCursor.Center.BottomDiag.Visible = true
				GunCursor.Center.LeftDiag.Visible = true
				GunCursor.Center.RightDiag.Visible = true
				
				delay(0.1, function()
					if Weapon.CurHit == CurHit then
						GunCursor.Center.TopDiag.Visible = false
						GunCursor.Center.BottomDiag.Visible = false
						GunCursor.Center.LeftDiag.Visible = false
						GunCursor.Center.RightDiag.Visible = false
					end
				end)
			end
			
			if Humanoid:IsA("Humanoid") then
				local HitSound = Instance.new("Sound", Weapon.User.PlayerGui)
				HitSound.Pitch = 2
				HitSound.SoundId = GunCore.HitSound
				HitSound.Name = "Playing"
				if Humanoid.Health <= 0 then
					Instance.new("IntValue", Humanoid).Name = "HitSound"
				else
					HitSound.Pitch = 1.8
					HitSound.Volume = 0.1
				end
				HitSound:Play()
				
				game.Debris:AddItem(HitSound, 0.1)
			end
		end)
	end
end)
HookLib.AddHook("PreventFire", "NoSprintShoot", function(Module, User, Start, End)
	if Movement.Sprinting then
		return true
	end
end, 1)

return {}]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCA4E42F6C0104F83B63556F9DA0EFC2E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TweenModule</string>
						<ProtectedString name="Source"><![CDATA[local Module, Tweening = { }, { }

local Color3new, BrickColornew, CFramenew, Vector3new = Color3.new, BrickColor.new, CFrame.new, Vector3.new

local NumberLerp = function ( Start, End, Delta ) return Start + Delta * ( End - Start ) end

local CFrameLerp, Vector3Lerp = CFramenew( ).lerp, Vector3new( ).Lerp

local Color3Lerp = function ( ... ) local curLerp = Vector3Lerp( ... ) return Color3new( curLerp.X, curLerp.Y, curLerp.Z ) end

local BrickColorLerp = function ( ... ) local curLerp = Vector3Lerp( ... ) return BrickColornew( curLerp.X, curLerp.Y, curLerp.Z ) end

function Module.DoTween( LerpFunc, Obj, Type, End, Speed, Overrideable, Callback )
	
	local Cur = ( not Overrideable ) or tick( )
	
	Tweening[ Obj ] = Tweening[ Obj ] or { }
	
	if Tweening[ Obj ][ Type ] == true then
		
		return
	
	else
		
		Tweening[ Obj ][ Type ] = Cur
		
	end
	
	Speed = Speed * 30
	
	local Start = Obj[ Type ]
	
	if LerpFunc == Color3Lerp or LerpFunc == BrickColorLerp then
		
		Start = Vector3new( Start.r, Start.g, Start.b )
		
		End = Vector3new( End.r, End.g, End.b )
		
	end
	
	for a = 1, Speed do
		
		if Tweening[ Obj ][ Type ] ~= Cur then
			
			return
			
		end
		
		Obj[ Type ] = LerpFunc( Start, End, a / Speed )
		
		wait( )
		
	end
	
	if Tweening[ Obj ][ Type ] == Cur then
		
		Tweening[ Obj ][ Type ] = nil
		
		if Callback then Callback( ) end
		
	end
	
end

function Module.TweenNumber( ... )
	
	coroutine.wrap( Module.DoTween )( NumberLerp, ... )
	
end

function Module.TweenCFrame( ... )
	
	coroutine.wrap( Module.DoTween )( CFrameLerp, ... )
	
end

function Module.TweenVector3( ... )
	
	coroutine.wrap( Module.DoTween )( Vector3Lerp, ... )
	
end

function Module.TweenColor3( ... )
	
	coroutine.wrap( Module.DoTween )( Color3Lerp, ... )
	
end

function Module.TweenBrickColor( ... )
	
	coroutine.wrap( Module.DoTween )( BrickColorLerp, ... )
	
end

return Module]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBXC45443C4DB534634B703560D66BA3279">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NewCameraScript</string>
					<ProtectedString name="Source"><![CDATA[spawn(function()
	for i = 1, 5 do
		if script.Parent:FindFirstChild("CameraScript") then
			script.Parent.CameraScript:Destroy()
			break
		end
		wait(0.1)
	end
end)

local RunService = game:GetService('RunService')
local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')


local RootCamera = script:WaitForChild('RootCamera')
local ClassicCamera = require(RootCamera:WaitForChild('ClassicCamera'))()
local FollowCamera = require(RootCamera:WaitForChild('FollowCamera'))()
local PopperCam = require(script:WaitForChild('PopperCam'))
local Invisicam = require(script:WaitForChild('Invisicam'))
local ClickToMove = require(script:WaitForChild('ClickToMove'))()
local TransparencyController = require(script:WaitForChild('TransparencyController'))()
local StarterPlayer = game:GetService('StarterPlayer')

local GameSettings = UserSettings().GameSettings


local EnabledCamera = nil
local EnabledOcclusion = nil

local currentCameraConn = nil
local renderSteppedConn = nil


local function IsTouch()
	return UserInputService.TouchEnabled
end

local function shouldUseCustomCamera()
	local player = PlayersService.LocalPlayer
	local currentCamera = workspace.CurrentCamera
	if player then
		if currentCamera == nil or (currentCamera and currentCamera.CameraType == Enum.CameraType.Custom) then
			return true, player, currentCamera
		end
	end
	return false, player, currentCamera
end

local function isClickToMoveOn()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		if IsTouch() then -- Touch
			if player.DevTouchMovementMode == Enum.DevTouchMovementMode.ClickToMove or
					(player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice and GameSettings.TouchMovementMode == Enum.TouchMovementMode.ClickToMove) then
				return true
			end
		else -- Computer
			if player.DevComputerMovementMode == Enum.DevComputerMovementMode.ClickToMove or
					(player.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice and GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove) then
				return true
			end
		end
	end
	return false
end

local function getCurrentCameraMode()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		if IsTouch() then -- Touch (iPad, etc...)
			if isClickToMoveOn() then
				return Enum.DevTouchMovementMode.ClickToMove.Name
			elseif player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				local touchMovementMode = GameSettings.TouchCameraMovementMode
				if touchMovementMode == Enum.TouchCameraMovementMode.Default then
					return Enum.TouchCameraMovementMode.Follow.Name
				end
				return touchMovementMode.Name
			else
				return player.DevTouchCameraMode.Name
			end
		else -- Computer
			if isClickToMoveOn() then
				return Enum.DevComputerMovementMode.ClickToMove.Name
			elseif player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
				local computerMovementMode = GameSettings.ComputerCameraMovementMode
				if computerMovementMode == Enum.ComputerCameraMovementMode.Default then
					return Enum.ComputerCameraMovementMode.Classic.Name
				end
				return computerMovementMode.Name
			else
				return player.DevComputerCameraMode.Name
			end
		end
	end
end

local function getCameraOcclusionMode()
	local customModeOn, player, currentCamera = shouldUseCustomCamera()
	if customModeOn then
		return player.DevCameraOcclusionMode
	end
end

local function Update()
	if EnabledCamera then
		EnabledCamera:Update()
	end
	if EnabledOcclusion then
		EnabledOcclusion:Update()
	end
	if shouldUseCustomCamera() then
		TransparencyController:Update()
	end
end

local function SetEnabledCamera(newCamera)
	if EnabledCamera ~= newCamera then
		if EnabledCamera then
			EnabledCamera:SetEnabled(false)
		end
		EnabledCamera = newCamera
		if EnabledCamera then
			EnabledCamera:SetEnabled(true)
		end
	end
end

local function OnCameraMovementModeChange(newCameraMode)
	if newCameraMode == Enum.DevComputerMovementMode.ClickToMove.Name then
		ClickToMove:Start()
		SetEnabledCamera(nil)
		TransparencyController:SetEnabled(true)
	else
		if newCameraMode == Enum.ComputerCameraMovementMode.Classic.Name then
			SetEnabledCamera(ClassicCamera)
			TransparencyController:SetEnabled(true)
		elseif newCameraMode == Enum.ComputerCameraMovementMode.Follow.Name then
			SetEnabledCamera(FollowCamera)
			TransparencyController:SetEnabled(true)
		else -- Our camera movement code was disabled by the developer
			SetEnabledCamera(nil)
			TransparencyController:SetEnabled(false)
		end
		ClickToMove:Stop()
	end

	local newOcclusionMode = getCameraOcclusionMode()
	if EnabledOcclusion == Invisicam and newOcclusionMode ~= Enum.DevCameraOcclusionMode.Invisicam then
		Invisicam:Cleanup()
	end
	if newOcclusionMode == Enum.DevCameraOcclusionMode.Zoom then
		EnabledOcclusion = PopperCam
	elseif newOcclusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		EnabledOcclusion = Invisicam
	else
		EnabledOcclusion = false
	end

	local success = pcall(function() local isAThing = RunService.BindToRenderStep end)
	if not success then
		if renderSteppedConn then
			renderSteppedConn:disconnect()
		end
		renderSteppedConn = RunService.RenderStepped:connect(Update)
	end
end

local function OnCameraTypeChanged(newCameraType)
	if newCameraType == Enum.CameraType.Scriptable then
		if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
end


local function OnCameraSubjectChanged(newSubject)
	TransparencyController:SetSubject(newSubject)
end

local function OnNewCamera()
	OnCameraMovementModeChange(getCurrentCameraMode())

	local currentCamera = workspace.CurrentCamera
	if currentCamera then
		if currentCameraConn then
			currentCameraConn:disconnect()
		end
		currentCameraConn = currentCamera.Changed:connect(function(prop)
			if prop == 'CameraType' then
				OnCameraMovementModeChange(getCurrentCameraMode())
				OnCameraTypeChanged(currentCamera.CameraType)
			elseif prop == 'CameraSubject' then
				OnCameraSubjectChanged(currentCamera.CameraSubject)
			end
		end)

		OnCameraSubjectChanged(currentCamera.CameraSubject)
		OnCameraTypeChanged(currentCamera.CameraType)
	end
end


local function OnPlayerAdded(player)
	workspace.Changed:connect(function(prop)
		if prop == 'CurrentCamera' then
			OnNewCamera()
		end
	end)

	player.Changed:connect(function(prop)
		OnCameraMovementModeChange(getCurrentCameraMode())
	end)

	GameSettings.Changed:connect(function(prop)
		OnCameraMovementModeChange(getCurrentCameraMode())
	end)

	local success = pcall(function() RunService:BindToRenderStep("cameraRenderUpdate",Enum.RenderPriority.Camera.Value,Update) end)
	if not success then
		if renderSteppedConn then
			renderSteppedConn:disconnect()
		end
		renderSteppedConn = RunService.RenderStepped:connect(Update)
	end

	OnNewCamera()
	OnCameraMovementModeChange(getCurrentCameraMode())
end

do
	while PlayersService.LocalPlayer == nil do wait() end
	OnPlayerAdded(PlayersService.LocalPlayer)
end
]]></ProtectedString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1041E4FBD4ED4893B8EAEED30240392B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClickToMove</string>
						<ProtectedString name="Source"><![CDATA[-- Written By Kip Turner, Copyright Roblox 2014


local UIS = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local PlayerService = game:GetService("Players")
local RunService = game:GetService("RunService")
local DebrisService = game:GetService('Debris')
local ReplicatedStorage = game:GetService('ReplicatedStorage')

local CameraScript = script.Parent
local ClassicCameraModule = require(CameraScript:WaitForChild('RootCamera'):WaitForChild('ClassicCamera'))

local Player = PlayerService.localPlayer
local MyMouse = Player:GetMouse()


local DirectPathEnabled = false
local SHOW_PATH = false

local RayCastIgnoreList = workspace.FindPartOnRayWithIgnoreList
local GetPartsTouchingExtents = workspace.FindPartsInRegion3

-- Bindable for when we want touch emergency controls
-- TODO: Click to move should probably have it's own gui touch controls
-- to manage this.
local BindableEvent_OnFailStateChanged = nil
if UIS.TouchEnabled then
	BindableEvent_OnFailStateChanged = Instance.new('BindableEvent')
	BindableEvent_OnFailStateChanged.Name = "OnClickToMoveFailStateChange"
	local CameraScript = script.Parent
	local PlayerScripts = CameraScript.Parent
	BindableEvent_OnFailStateChanged.Parent = PlayerScripts
end


--------------------------UTIL LIBRARY-------------------------------
local Utility = {}
do
	local Signal = {}

	function Signal.Create()
		local sig = {}

		local mSignaler = Instance.new('BindableEvent')

		local mArgData = nil
		local mArgDataCount = nil

		function sig:fire(...)
			mArgData = {...}
			mArgDataCount = select('#', ...)
			mSignaler:Fire()
		end

		function sig:connect(f)
			if not f then error("connect(nil)", 2) end
			return mSignaler.Event:connect(function()
				f(unpack(mArgData, 1, mArgDataCount))
			end)
		end

		function sig:wait()
			mSignaler.Event:wait()
			assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
			return unpack(mArgData, 1, mArgDataCount)
		end

		return sig
	end
	Utility.Signal = Signal

	function Utility.Create(instanceType)
		return function(data)
			local obj = Instance.new(instanceType)
			for k, v in pairs(data) do
				if type(k) == 'number' then
					v.Parent = obj
				else
					obj[k] = v
				end
			end
			return obj
		end
	end

	local function clamp(low, high, num)
		return math.max(math.min(high, num), low)
	end
	Utility.Clamp = clamp

	local function ViewSizeX()
		local camera = workspace.CurrentCamera
		local x = camera and camera.ViewportSize.X or 0
		local y = camera and camera.ViewportSize.Y or 0
		if x == 0 then
			return 1024
		else
			if x > y then
				return x
			else
				return y
			end
		end
	end
	Utility.ViewSizeX = ViewSizeX

	local function ViewSizeY()
		local camera = workspace.CurrentCamera
		local x = camera and camera.ViewportSize.X or 0
		local y = camera and camera.ViewportSize.Y or 0
		if y == 0 then
			return 768
		else
			if x > y then
				return y
			else
				return x
			end
		end
	end
	Utility.ViewSizeY = ViewSizeY

	local function AspectRatio()
		return ViewSizeX() / ViewSizeY()
	end
	Utility.AspectRatio = AspectRatio

	local function FindChacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChild("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindChacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindChacterAncestor = FindChacterAncestor


	local function GetUnitRay(x, y, viewWidth, viewHeight, camera)
		return camera:ScreenPointToRay(x, y)
	end
	Utility.GetUnitRay = GetUnitRay

	local RayCastIgnoreList = workspace.FindPartOnRayWithIgnoreList
	local function Raycast(ray, ignoreNonCollidable, ignoreList)
		local ignoreList = ignoreList or {}
		local hitPart, hitPos = RayCastIgnoreList(workspace, ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				table.insert(ignoreList, hitPart)
				return Raycast(ray, ignoreNonCollidable, ignoreList)
			end
			return hitPart, hitPos
		end
		return nil, nil
	end
	Utility.Raycast = Raycast


	Utility.Round = function(num, roundToNearest)
		roundToNearest = roundToNearest or 1
		return math.floor((num + roundToNearest/2) / roundToNearest) * roundToNearest
	end

	local function AveragePoints(positions)
		local avgPos = Vector2.new(0,0)
		if #positions > 0 then
			for i = 1, #positions do
				avgPos = avgPos + positions[i]
			end
			avgPos = avgPos / #positions
		end
		return avgPos
	end
	Utility.AveragePoints = AveragePoints

	local function FuzzyEquals(numa, numb)
		return numa + 0.1 > numb and numa - 0.1 < numb
	end
	Utility.FuzzyEquals = FuzzyEquals

	local LastInput = 0
	UIS.InputBegan:connect(function(inputObject, wasSunk)
		if not wasSunk then
			if inputObject.UserInputType == Enum.UserInputType.Touch or
					inputObject.UserInputType == Enum.UserInputType.MouseButton1 or
					inputObject.UserInputType == Enum.UserInputType.MouseButton2 then
				LastInput = tick()
			end
		end
	end)
	Utility.GetLastInput = function()
		return LastInput
	end
end

local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					humanoidCache[player] = child
					return child
				end
			end
		end
	end
end

local function CFrameInterpolator(c0, c1) -- (CFrame from, CFrame to) -> (float theta, (float fraction -> CFrame between))
	local fromAxisAngle = CFrame.fromAxisAngle
	local components = CFrame.new().components
	local inverse = CFrame.new().inverse
	local v3 = Vector3.new
	local acos = math.acos
	local sqrt = math.sqrt
	local invroot2 = 1 / math.sqrt(2)
	-- The expanded matrix
	local _, _, _, xx, yx, zx,
	               xy, yy, zy,
	               xz, yz, zz = components(inverse(c0)*c1)
	-- The cos-theta of the axisAngles from
	local cosTheta = (xx + yy + zz - 1)/2
	-- Rotation axis
	local rotationAxis = v3(yz-zy, zx-xz, xy-yx)
	-- The position to tween through
	local positionDelta = (c1.p - c0.p)
	-- Theta
	local theta;
	-- Catch degenerate cases
	if cosTheta >= 0.999 then
		-- Case same rotation, just return an interpolator over the positions
		return 0, function(t)
			return c0 + positionDelta*t
		end
	elseif cosTheta <= -0.999 then
		-- Case exactly opposite rotations, disambiguate
		theta = math.pi
		xx = (xx + 1) / 2
		yy = (yy + 1) / 2
		zz = (zz + 1) / 2
		if xx > yy and xx > zz then
			if xx < 0.001 then
				rotationAxis = v3(0, invroot2, invroot2)
			else
				local x = sqrt(xx)
				xy = (xy + yx) / 4
				xz = (xz + zx) / 4
				rotationAxis = v3(x, xy/x, xz/x)
			end
		elseif yy > zz then
			if yy < 0.001 then
				rotationAxis = v3(invroot2, 0, invroot2)
			else
				local y = sqrt(yy)
				xy = (xy + yx) / 4
				yz = (yz + zy) / 4
				rotationAxis = v3(xy/y, y, yz/y)
			end
		else
			if zz < 0.001 then
				rotationAxis = v3(invroot2, invroot2, 0)
			else
				local z = sqrt(zz)
				xz = (xz + zx) / 4
				yz = (yz + zy) / 4
				rotationAxis = v3(xz/z, yz/z, z)
			end
		end
	else
		-- Normal case, get theta from cosTheta
		theta = acos(cosTheta)
	end
	-- Return the interpolator
	return theta, function(t)
		return c0*fromAxisAngle(rotationAxis, theta*t) + positionDelta*t
	end
end
---------------------------------------------------------

local Signal = Utility.Signal
local Create = Utility.Create

--------------------------CHARACTER CONTROL-------------------------------
local function CreateController()
	local this = {}

	this.TorsoLookPoint = nil

	function this:SetTorsoLookPoint(point)
		local humanoid = findPlayerHumanoid(Player)
		if humanoid then
			humanoid.AutoRotate = false
		end
		this.TorsoLookPoint = point
		self:UpdateTorso()
		delay(2,
			function()
			-- this isnt technically correct for detecting if this is the last issue to the setTorso function
			if this.TorsoLookPoint == point then
				this.TorsoLookPoint = nil
				if humanoid then
					humanoid.AutoRotate = true
				end
			end
		end)
	end

	function this:UpdateTorso(point)
		if this.TorsoLookPoint then
			point = this.TorsoLookPoint
		else
			return
		end

		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			local lookVec = (point - torso.CFrame.p).unit
			local squashedLookVec = Vector3.new(lookVec.X, 0, lookVec.Z).unit
			torso.CFrame = CFrame.new(torso.CFrame.p, torso.CFrame.p + squashedLookVec)
		end
	end

	return this
end

local CharacterControl = CreateController()
-----------------------------------------------------------------------

--------------------------PC AUTO JUMPER-------------------------------

local function GetCharacter()
	return Player and Player.Character
end

local function GetTorso()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid and humanoid.Torso
end

local function IsPartAHumanoid(part)
	return part and part.Parent and (part.Parent:FindFirstChild('Humanoid') ~= nil)
end

local function doAutoJump()
	local character = GetCharacter()
	if (character == nil) then
		return;
	end

	local humanoid = findPlayerHumanoid(Player)
	if (humanoid == nil) then
		return;
	end

	local rayLength = 1.5;
	-- This is how high a ROBLOXian jumps from the mid point of his torso
	local jumpHeight = 7.0;

	local torso = GetTorso()
	if (torso == nil) then
		return;
	end

	local torsoCFrame = torso.CFrame;
	local torsoLookVector = torsoCFrame.lookVector;
	local torsoPos = torsoCFrame.p;

	local torsoRay = Ray.new(torsoPos + Vector3.new(0, -torso.Size.Y/2, 0), torsoLookVector * rayLength);
	local jumpRay = Ray.new(torsoPos + Vector3.new(0, jumpHeight - torso.Size.Y, 0), torsoLookVector * rayLength);

	local hitPart, _ = RayCastIgnoreList(workspace, torsoRay, {character}, false)
	local jumpHitPart, _ = RayCastIgnoreList(workspace, jumpRay, {character}, false)

	if (hitPart and jumpHitPart == nil and hitPart.CanCollide == true) then
		 -- NOTE: this follow line is not in the C++ impl, but an improvement  in Click to Move
		if not IsPartAHumanoid(hitPart) then
			humanoid.Jump = true;
		end
	end
end

local NO_JUMP_STATES =
{
	[Enum.HumanoidStateType.FallingDown] = false;
	[Enum.HumanoidStateType.Flying] = false;
	[Enum.HumanoidStateType.Freefall] = false;
	[Enum.HumanoidStateType.GettingUp] = false;
	[Enum.HumanoidStateType.Ragdoll] = false;
	[Enum.HumanoidStateType.Running] = false;
	[Enum.HumanoidStateType.Seated] = false;
	[Enum.HumanoidStateType.Swimming] = false;

	-- Special case to detect if we are on a ladder
	[Enum.HumanoidStateType.Climbing] = false;
}

local function enableAutoJump()
	local humanoid = findPlayerHumanoid(Player)
	local currentState = humanoid and humanoid:GetState()
	if currentState then
		return NO_JUMP_STATES[currentState] == nil
	end
	return false
end

local function getAutoJump()
	return true
end

local function vec3IsZero(vec3)
	return vec3.magnitude < 0.05
end

-- NOTE: This function is radically different from the engine's implementation
local function calcDesiredWalkVelocity()
	-- TEMP
	return Vector3.new(1,1,1)
end

local function preStepSimulatorSide(dt)
	if getAutoJump() and enableAutoJump() then
		local desiredWalkVelocity = calcDesiredWalkVelocity();
		if (not vec3IsZero(desiredWalkVelocity)) then
			doAutoJump();
		end
	end
end

local function AutoJumper()
	local this = {}
	local running = false
	local runRoutine = nil

	function this:Run()
		running = true
		local thisRoutine = nil
		thisRoutine = coroutine.create(function()
			while running and thisRoutine == runRoutine do
				this:Step()
				wait()
			end
		end)
		runRoutine = thisRoutine
		coroutine.resume(thisRoutine)
	end

	function this:Stop()
		running = false
	end

	function this:Step()
		preStepSimulatorSide()
	end

	return this
end

-----------------------------------------------------------------------------

-----------------------------------PATHER--------------------------------------

local function CreateDestinationIndicator(pos)
	local destinationGlobe = Create'Part'
	{
		Name = 'PathGlobe';
		TopSurface = 'Smooth';
		BottomSurface = 'Smooth';
		Shape = 'Ball';
		CanCollide = false;
		Size = Vector3.new(2,2,2);
		BrickColor = BrickColor.new('Institutional white');
		Transparency = 0;
		Anchored = true;
		CFrame = CFrame.new(pos);
	}
	return destinationGlobe
end

local function Pather(character, point)
	local this = {}

	this.Cancelled = false
	this.Started = false

	this.Finished = Signal.Create()
	this.PathFailed = Signal.Create()
	this.PathStarted = Signal.Create()

	this.PathComputed = false

	function this:YieldUntilPointReached(character, point, timeout)
		timeout = timeout or 10000000

		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		local start = tick()
		local lastMoveTo = start
		while torso and tick() - start < timeout and this.Cancelled == false do
			local diffVector = (point - torso.CFrame.p)
			local xzMagnitude = (diffVector * Vector3.new(1,0,1)).magnitude
			if xzMagnitude < 6 then
				-- Jump if the path is telling is to go upwards
				if diffVector.Y >= 2.2 then
					humanoid.Jump = true
				end
			end
			-- The hard-coded number 2 here is from the engine's MoveTo implementation
			if xzMagnitude < 2 then
				return true
			end
			-- Keep on issuing the move command because it will automatically quit every so often.
			if tick() - lastMoveTo > 1.5 then
				humanoid:MoveTo(point)
				lastMoveTo = tick()
			end
			CharacterControl:UpdateTorso(point)
			wait()
		end
		return false
	end

	function this:Cancel()
		this.Cancelled = true
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if humanoid and torso then
			humanoid:MoveTo(torso.CFrame.p)
		end
	end

	function this:CheckOcclusion(point1, point2, character, torsoRadius)
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torsoRadius == nil then
			torsoRadius = torso and Vector3.new(torso.Size.X/2,0,torso.Size.Z/2) or Vector3.new(1,0,1)
		end

		local diffVector = point2 - point1
		local directionVector = diffVector.unit

		local rightVector = Vector3.new(0,1,0):Cross(directionVector) * torsoRadius

		local rightPart, _ = Utility.Raycast(Ray.new(point1 + rightVector, diffVector + rightVector), true, {character})
		local hitPart, _ = Utility.Raycast(Ray.new(point1, diffVector), true, {character})
		local leftPart, _ = Utility.Raycast(Ray.new(point1 - rightVector, diffVector - rightVector), true, {character})

		if rightPart or hitPart or leftPart then
			return false
		end

		-- Make sure we have somewhere to stand on
		local midPt = (point2 + point1) / 2
		local studsBetweenSamples = 2
		for i = 1, math.floor(diffVector.magnitude/studsBetweenSamples) do
			local downPart, _ = Utility.Raycast(Ray.new(point1 + directionVector * i * studsBetweenSamples, Vector3.new(0,-7,0)), true, {character})
			if not downPart then
				return false
			end
		end

		return true
	end

	function this:SmoothPoints(pathToSmooth)
		local result = {}

		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		for i = 1, #pathToSmooth do
			table.insert(result, pathToSmooth[i])
		end

		-- Backwards for safe-deletion
		for i = #result - 1, 1, -1 do
			if i + 1 <= #result then

				local nextPoint = result[i+1]
				local thisPoint = result[i]

				local lastPoint = result[i-1]
				if lastPoint == nil then
					lastPoint = torso and Vector3.new(torso.CFrame.p.X, thisPoint.Y, torso.CFrame.p.Z)
				end

				if lastPoint and Utility.FuzzyEquals(thisPoint.Y, lastPoint.Y) and Utility.FuzzyEquals(thisPoint.Y, nextPoint.Y) then
					if this:CheckOcclusion(lastPoint, nextPoint, character) then
						table.remove(result, i)
						-- Move i back one to recursively-smooth
						i = i + 1
					end
				end
			end
		end

		return result
	end

	function this:CheckNeighboringCells(character)
		local pathablePoints = {}
		local humanoid = findPlayerHumanoid(Player)
		local torso = character and humanoid and humanoid.Torso
		if torso then
			local torsoCFrame = torso.CFrame
			local torsoPos = torsoCFrame.p
			-- Minus and plus 2 is so we can get it into the cell-corner space and then translate it back into cell-center space
			local roundedPos = Vector3.new(Utility.Round(torsoPos.X-2,4)+2, Utility.Round(torsoPos.Y-2,4)+2, Utility.Round(torsoPos.Z-2,4)+2)
			local neighboringCells = {}
			for x = -4, 4, 8 do
				for z = -4, 4, 8 do
					table.insert(neighboringCells, roundedPos + Vector3.new(x,0,z))
				end
			end
			for _, testPoint in pairs(neighboringCells) do
				local pathable = this:CheckOcclusion(roundedPos, testPoint, character, Vector3.new(0,0,0))
				if pathable then
					table.insert(pathablePoints, testPoint)
				end
			end
		end
		return pathablePoints
	end

	function this:ComputeDirectPath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			local startPt = torso.CFrame.p
			local finishPt = point
			if (finishPt - startPt).magnitude < 150 then
				-- move back the destination by 2 studs or otherwise the pather will collide with the object we are trying to reach
				finishPt = finishPt - (finishPt - startPt).unit * 2
				if this:CheckOcclusion(startPt, finishPt, character, Vector3.new(0,0,0)) then
					local pathResult = {}
					pathResult.Status = Enum.PathStatus.Success
					function pathResult:GetPointCoordinates()
						return {finishPt}
					end
					return pathResult
				end
			end
		end
	end

	local function AllAxisInThreshhold(targetPt, otherPt, threshold)
		return math.abs(targetPt.X - otherPt.X) <= threshold and
			math.abs(targetPt.Y - otherPt.Y) <= threshold and
			math.abs(targetPt.Z - otherPt.Z) <= threshold
	end

	function this:ComputePath()
		local smoothed = false
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		if torso then
			if this.PathComputed then return end
			this.PathComputed = true
			-- Will yield the script since it is an Async script (start, finish, maxDistance)
			-- Try to use the smooth function, but it may not exist yet :(
			local success = pcall(function()
				-- 3 is height from torso cframe to ground
				this.pathResult = PathfindingService:ComputeSmoothPathAsync(torso.CFrame.p - Vector3.new(0,3,0), point, 400)
				smoothed = true
			end)
			if not success then
				-- 3 is height from torso cframe to ground
				this.pathResult = PathfindingService:ComputeRawPathAsync(torso.CFrame.p - Vector3.new(0,3,0), point, 400)
				smoothed = false
			end
			this.pointList = this.pathResult and this.pathResult:GetPointCoordinates()
			local pathFound = false
			if this.pathResult.Status == Enum.PathStatus.FailFinishNotEmpty then
				-- Lets try again with a slightly set back start point; it is ok to do this again so the FailFinishNotEmpty uses little computation
				local diffVector = point - workspace.CurrentCamera.CoordinateFrame.p
				if diffVector.magnitude > 2 then
					local setBackPoint = point - (diffVector).unit * 2.1
					local success = pcall(function()
						this.pathResult = PathfindingService:ComputeSmoothPathAsync(torso.CFrame.p, setBackPoint, 400)
						smoothed = true
					end)
					if not success then
						this.pathResult = PathfindingService:ComputeRawPathAsync(torso.CFrame.p, setBackPoint, 400)
						smoothed = false
					end
					this.pointList = this.pathResult and this.pathResult:GetPointCoordinates()
					pathFound = true
				end
			end
			if this.pathResult.Status == Enum.PathStatus.ClosestNoPath and #this.pointList >= 1 and pathFound == false then
				local otherPt = this.pointList[#this.pointList]
				if AllAxisInThreshhold(point, otherPt, 4) and (torso.CFrame.p - point).magnitude > (otherPt - point).magnitude then
					local pathResult = {}
					pathResult.Status = Enum.PathStatus.Success
					function pathResult:GetPointCoordinates()
						return {this.pointList}
					end
					this.pathResult = pathResult
					pathFound = true
				end
			end
			if (this.pathResult.Status == Enum.PathStatus.FailStartNotEmpty or this.pathResult.Status == Enum.PathStatus.ClosestNoPath) and pathFound == false then
				local pathablePoints = this:CheckNeighboringCells(character)
				for _, otherStart in pairs(pathablePoints) do
					local pathResult;
					local success = pcall(function()
						pathResult = PathfindingService:ComputeSmoothPathAsync(otherStart, point, 400)
						smoothed = true
					end)
					if not success then
						pathResult = PathfindingService:ComputeRawPathAsync(otherStart, point, 400)
						smoothed = false
					end
					if pathResult and pathResult.Status == Enum.PathStatus.Success then
						this.pathResult = pathResult
						if this.pathResult then
							this.pointList = this.pathResult:GetPointCoordinates()
							table.insert(this.pointList, 1, otherStart)
						end
						break
					end
				end
			end
			if DirectPathEnabled then
				if this.pathResult.Status ~= Enum.PathStatus.Success then
					local directPathResult = this:ComputeDirectPath()
					if directPathResult and directPathResult.Status == Enum.PathStatus.Success then
						this.pathResult = directPathResult
						this.pointList = directPathResult:GetPointCoordinates()
					end
				end
			end
		end
		return smoothed
	end

	function this:IsValidPath()
		this:ComputePath()
		local pathStatus = this.pathResult.Status
		return pathStatus == Enum.PathStatus.Success
	end

	function this:GetPathStatus()
		this:ComputePath()
		return this.pathResult.Status
	end

	function this:Start()
		spawn(function()
			local humanoid = findPlayerHumanoid(Player)
			--humanoid.AutoRotate = false
			local torso = humanoid and humanoid.Torso
			if torso then
				if this.Started then return end
				this.Started = true
				-- Will yield the script since it is an Async function script (start, finish, maxDistance)
				local smoothed = this:ComputePath()
				if this:IsValidPath() then
					this.PathStarted:fire()
					-- smooth out zig-zaggy paths
					local smoothPath = smoothed and this.pointList or this:SmoothPoints(this.pointList)
					for i, point in pairs(smoothPath) do
						if humanoid then
							if this.Cancelled then
								return
							end

							local wayPoint = nil
							if SHOW_PATH then
								wayPoint = CreateDestinationIndicator(point)
								wayPoint.BrickColor = BrickColor.new("New Yeller")
								wayPoint.Parent = workspace
								print(wayPoint.CFrame.p)
							end

							humanoid:MoveTo(point)

							local distance = ((torso.CFrame.p - point) * Vector3.new(1,0,1)).magnitude
							local approxTime = 10
							if math.abs(humanoid.WalkSpeed) > 0 then
								approxTime = distance / math.abs(humanoid.WalkSpeed)
							end

							local yielding = true

							if i == 1 then
								--local rotatedCFrame = CameraModule:LookAtPreserveHeight(point)
								if CameraModule then
									local rotatedCFrame = CameraModule:LookAtPreserveHeight(smoothPath[#smoothPath])
									local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
								end
								--CharacterControl:SetTorsoLookPoint(point)
							end
							---[[
							if (humanoid.Torso.CFrame.p - point).magnitude > 9 then
								spawn(function()
									while yielding and this.Cancelled == false do
										if CameraModule then
											local look = CameraModule:GetCameraLook()
											local squashedLook = (look * Vector3.new(1,0,1)).unit
											local direction = ((point - workspace.CurrentCamera.CoordinateFrame.p) * Vector3.new(1,0,1)).unit

											local theta = math.deg(math.acos(squashedLook:Dot(direction)))

											if tick() - Utility.GetLastInput() > 2 and theta > (workspace.CurrentCamera.FieldOfView / 2) then
												local rotatedCFrame = CameraModule:LookAtPreserveHeight(point)
												local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
												--return
											end
										end
										wait(0.1)
									end
								end)
							end
							--]]
							local didReach = this:YieldUntilPointReached(character, point, approxTime * 3 + 1)

							yielding = false

							if SHOW_PATH then
								wayPoint:Destroy()
							end

							if not didReach then
								this.PathFailed:fire()
								return
							end
						end
					end

					this.Finished:fire()
					return
				end
			end
			this.PathFailed:fire()
		end)
	end

	return this
end

-------------------------------------------------------------------------

local function FlashRed(object)
	local origColor = object.BrickColor
	local redColor = BrickColor.new("Really red")
	local start = tick()
	local duration = 4
	spawn(function()
		while object and tick() - start < duration do
			object.BrickColor = origColor
			wait(0.13)
			if object then
				object.BrickColor = redColor
			end
			wait(0.13)
		end
	end)
end

--local joystickWidth = 250
--local joystickHeight = 250
local function IsInBottomLeft(pt)
	local joystickHeight = math.min(Utility.ViewSizeY() * 0.33, 250)
	local joystickWidth = joystickHeight
	return pt.X <= joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function IsInBottomRight(pt)
	local joystickHeight = math.min(Utility.ViewSizeY() * 0.33, 250)
	local joystickWidth = joystickHeight
	return pt.X >= Utility.ViewSizeX() - joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function CheckAlive(character)
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end

local function GetEquippedTool(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA('Tool') then
				return child
			end
		end
	end
end

local function ExploreWithRayCast(currentPoint, originDirection)
	local TestDistance = 40
	local TestVectors = {}
	do
		local forwardVector = originDirection;
		for i = 0, 15 do
			table.insert(TestVectors, CFrame.Angles(0, math.pi / 8 * i, 0) * forwardVector)
		end
	end

	local testResults = {}
	-- Heuristic should be something along the lines of distance and closeness to the traveling direction
	local function ExploreHeuristic()
		for _, testData in pairs(testResults) do
			local walkDirection = -1 * originDirection
			local directionCoeff = (walkDirection:Dot(testData['Vector']) + 1) / 2
			local distanceCoeff = testData['Distance'] / TestDistance
			testData["Value"] = directionCoeff * distanceCoeff
		end
	end

	for i, vec in pairs(TestVectors) do
		local hitPart, hitPos = Utility.Raycast(Ray.new(currentPoint, vec * TestDistance), true, {Player.Character})
		if hitPos then
			table.insert(testResults, {Vector = vec; Distance = (hitPos - currentPoint).magnitude})
		else
			table.insert(testResults, {Vector = vec; Distance = TestDistance})
		end
	end

	ExploreHeuristic()

	table.sort(testResults, function(a,b) return a["Value"] > b["Value"] end)

	return testResults
end

local TapId = 1
local ExistingPather = nil
local ExistingIndicator = nil
local PathCompleteListener = nil
local PathFailedListener = nil

local function CleanupPath()
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		DebrisService:AddItem(ExistingIndicator, 0)
		ExistingIndicator = nil
	end
end


local AutoJumperInstance = nil
local ShootCount = 0
local FailCount = 0
local function OnTap(tapPositions)
	-- Good to remember if this is the latest tap event
	TapId = TapId + 1
	local thisTapId = TapId


	local camera = workspace.CurrentCamera
	local character = Player.Character


	if not CheckAlive(character) then return end
	-- This is a path tap position
	if #tapPositions == 1 then
		if camera then
			local unitRay = Utility.GetUnitRay(tapPositions[1].x, tapPositions[1].y, MyMouse.ViewSizeX, MyMouse.ViewSizeY, camera)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction*400)
			local hitPart, hitPt = Utility.Raycast(ray, true, {character})

			local hitChar, hitHumanoid = Utility.FindChacterAncestor(hitPart)
			local torso = character and character:FindFirstChild("Humanoid") and character:FindFirstChild("Humanoid").Torso
			local startPos = torso.CFrame.p
			if hitChar and hitHumanoid and hitHumanoid.Torso and (hitHumanoid.Torso.CFrame.p - torso.CFrame.p).magnitude < 7 then
				CleanupPath()

				local myHumanoid = findPlayerHumanoid(Player)
				if myHumanoid then
					myHumanoid:MoveTo(hitPt)
				end

				ShootCount = ShootCount + 1
				local thisShoot = ShootCount
				-- Do shooot
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
					LastFired = tick()
				end
			elseif hitPt and character then
				local thisPather = Pather(character, hitPt)
				if thisPather:IsValidPath() then
					FailCount = 0
					-- TODO: Remove when bug in engine is fixed
					Player:Move(Vector3.new(1, 0, 0))
					Player:Move(Vector3.new(0, 0, 0))
					thisPather:Start()
					if BindableEvent_OnFailStateChanged then
						BindableEvent_OnFailStateChanged:Fire(false)
					end
					CleanupPath()

					local destinationGlobe = CreateDestinationIndicator(hitPt)
					destinationGlobe.Parent = camera

					ExistingPather = thisPather
					ExistingIndicator = destinationGlobe

					if AutoJumperInstance then
						AutoJumperInstance:Run()
					end

					PathCompleteListener = thisPather.Finished:connect(function()
						if AutoJumperInstance then
							AutoJumperInstance:Stop()
						end
						if destinationGlobe then
							if ExistingIndicator == destinationGlobe then
								ExistingIndicator = nil
							end
							DebrisService:AddItem(destinationGlobe, 0)
							destinationGlobe = nil
						end
						if hitChar then
							local humanoid = findPlayerHumanoid(Player)
							ShootCount = ShootCount + 1
							local thisShoot = ShootCount
							-- Do shoot
							local currentWeapon = GetEquippedTool(character)
							if currentWeapon then
								currentWeapon:Activate()
								LastFired = tick()
							end
							if humanoid then
								humanoid:MoveTo(hitPt)
							end
						end
						local finishPos = torso and torso.CFrame.p --hitPt
						if finishPos and startPos and tick() - Utility.GetLastInput() > 2 then
							local exploreResults = ExploreWithRayCast(finishPos, ((startPos - finishPos) * Vector3.new(1,0,1)).unit)
							-- Check for Nans etc..
							if exploreResults[1] and exploreResults[1]["Vector"] and exploreResults[1]["Vector"].magnitude >= 0.5 and exploreResults[1]["Distance"] > 3 then
								if CameraModule then
									local rotatedCFrame = CameraModule:LookAtPreserveHeight(finishPos + exploreResults[1]["Vector"] * exploreResults[1]["Distance"])
									local finishedSignal, duration = CameraModule:TweenCameraLook(rotatedCFrame)
								end
							end
						end
					end)
					PathFailedListener = thisPather.PathFailed:connect(function()
						if AutoJumperInstance then
							AutoJumperInstance:Stop()
						end
						if destinationGlobe then
							FlashRed(destinationGlobe)
							DebrisService:AddItem(destinationGlobe, 3)
						end
					end)
				else
					if hitPt then
						-- Feedback here for when we don't have a good path
						local failedGlobe = CreateDestinationIndicator(hitPt)
						FlashRed(failedGlobe)
						DebrisService:AddItem(failedGlobe, 1)
						failedGlobe.Parent = camera
						if ExistingIndicator == nil then
							FailCount = FailCount + 1
							if FailCount >= 3 then
								if BindableEvent_OnFailStateChanged then
									BindableEvent_OnFailStateChanged:Fire(true)
								end
								CleanupPath()
							end
						end
					end
				end
			else
				-- no hit pt
			end
		end
	elseif #tapPositions >= 2 then
		if camera then
			ShootCount = ShootCount + 1
			local thisShoot = ShootCount
			-- Do shoot
			local avgPoint = Utility.AveragePoints(tapPositions)
			local unitRay = Utility.GetUnitRay(avgPoint.x, avgPoint.y, MyMouse.ViewSizeX, MyMouse.ViewSizeY, camera)
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
				LastFired = tick()
			end
		end
	end
end


local function CreateClickToMoveModule()
	local this = {}

	local LastStateChange = 0
	local LastState = Enum.HumanoidStateType.Running
	local FingerTouches = {}
	local NumUnsunkTouches = 0
	-- PC simulation
	local mouse1Down = tick()
	local mouse1DownPos = Vector2.new()
	local mouse2Down = tick()
	local mouse2DownPos = Vector2.new()
	local mouse2Up = tick()

	local movementKeys = {
		[Enum.KeyCode.W] = true;
		[Enum.KeyCode.A] = true;
		[Enum.KeyCode.S] = true;
		[Enum.KeyCode.D] = true;
		[Enum.KeyCode.Up] = true;
		[Enum.KeyCode.Down] = true;
	}

	local TapConn = nil
	local InputBeganConn = nil
	local InputChangedConn = nil
	local InputEndedConn = nil
	local HumanoidDiedConn = nil
	local CharacterChildAddedConn = nil
	local OnCharacterAddedConn = nil
	local CharacterChildRemovedConn = nil
	local RenderSteppedConn = nil


	local function disconnectEvent(event)
		if event then
			event:disconnect()
		end
	end

	local function DisconnectEvents()
		disconnectEvent(TapConn)
		disconnectEvent(InputBeganConn)
		disconnectEvent(InputChangedConn)
		disconnectEvent(InputEndedConn)
		disconnectEvent(HumanoidDiedConn)
		disconnectEvent(CharacterChildAddedConn)
		disconnectEvent(OnCharacterAddedConn)
		disconnectEvent(RenderSteppedConn)
		disconnectEvent(CharacterChildRemovedConn)
		pcall(function() RunService:UnbindFromRenderStep("ClickToMoveRenderUpdate") end)
	end



	local function IsFinite(num)
		return num == num and num ~= 1/0 and num ~= -1/0
	end
	
	local function findAngleBetweenXZVectors(vec2, vec1)
		return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
	end
	
	-- Setup the camera
	CameraModule = ClassicCameraModule()

	do
		-- Extend The Camera Module Class
		function CameraModule:LookAtPreserveHeight(newLookAtPt)
			local camera = 	workspace.CurrentCamera

			local focus = camera.Focus.p

			local cameraCFrame = camera.CoordinateFrame
			local mag = Vector3.new(cameraCFrame.lookVector.x, 0, cameraCFrame.lookVector.z).magnitude
			local newLook = (Vector3.new(newLookAtPt.x, focus.y, newLookAtPt.z) - focus).unit * mag
			local flippedLook = newLook + Vector3.new(0, cameraCFrame.lookVector.y, 0)

			local distance = (focus - camera.CoordinateFrame.p).magnitude

			local newCamPos = focus - flippedLook.unit * distance
			return CFrame.new(newCamPos, newCamPos + flippedLook)
		end

		function CameraModule:TweenCameraLook(desiredCFrame, speed)
			local e = 2.718281828459
			local function SCurve(t)
				return 1/(1 + e^(-t*1.5))
			end
			local function easeOutSine(t, b, c, d)
				if t >= d then return b + c end
				return c * math.sin(t/d * (math.pi/2)) + b;
			end

			local theta, interper = CFrameInterpolator(CFrame.new(Vector3.new(), self:GetCameraLook()), desiredCFrame - desiredCFrame.p)
			theta = Utility.Clamp(0, math.pi, theta)
			local duration = 0.65 * SCurve(theta - math.pi/4) + 0.15
			if speed then
				duration = theta / speed
			end
			local start = tick()
			local finish = start + duration

			self.UpdateTweenFunction = function()
				local currTime = tick() - start
				local alpha = Utility.Clamp(0, 1, easeOutSine(currTime, 0, 1, duration))
				local newCFrame = interper(alpha)
				local y = findAngleBetweenXZVectors(newCFrame.lookVector, self:GetCameraLook())
				if IsFinite(y) and math.abs(y) > 0.0001 then
					self.RotateInput = self.RotateInput + Vector2.new(y, 0)
				end
				return (currTime >= finish or alpha >= 1)
			end
		end
	end
	--- Done Extending


	local function OnTouchBegan(input, processed)
		if FingerTouches[input] == nil and not processed then
			NumUnsunkTouches = NumUnsunkTouches + 1
		end
		FingerTouches[input] = processed
	end

	local function OnTouchChanged(input, processed)
		if FingerTouches[input] == nil then
			FingerTouches[input] = processed
			if not processed then
				NumUnsunkTouches = NumUnsunkTouches + 1
			end
		end
	end

	local function OnTouchEnded(input, processed)
			--print("Touch tap fake:" , processed)
			--if not processed then
			--	OnTap({input.Position})
			--end
		if FingerTouches[input] ~= nil and FingerTouches[input] == false then
			NumUnsunkTouches = NumUnsunkTouches - 1
		end
		FingerTouches[input] = nil
	end


	local function OnCharacterAdded(character)
		DisconnectEvents()

		InputBeganConn = UIS.InputBegan:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchBegan(input, processed)


				-- Give back controls when they tap both sticks
				local wasInBottomLeft = IsInBottomLeft(input.Position)
				local wasInBottomRight = IsInBottomRight(input.Position)
				if wasInBottomRight or wasInBottomLeft then
					for otherInput, _ in pairs(FingerTouches) do
						if otherInput ~= input then
							local otherInputInLeft = IsInBottomLeft(otherInput.Position)
							local otherInputInRight = IsInBottomRight(otherInput.Position)
							if otherInput.UserInputState ~= Enum.UserInputState.End and ((wasInBottomLeft and otherInputInRight) or (wasInBottomRight and otherInputInLeft)) then
								if BindableEvent_OnFailStateChanged then
									BindableEvent_OnFailStateChanged:Fire(true)
								end
								return
							end
						end
					end
				end
			end

			 -- Cancel path when you use the keyboard controls.
			if processed == false and input.UserInputType == Enum.UserInputType.Keyboard and movementKeys[input.KeyCode] then
				CleanupPath()
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				mouse1Down = tick()
				mouse1DownPos = input.Position
			end
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				mouse2Down = tick()
				mouse2DownPos = input.Position
			end
		end)

		InputChangedConn = UIS.InputChanged:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchChanged(input, processed)
			end
		end)

		InputEndedConn = UIS.InputEnded:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				OnTouchEnded(input, processed)
			end

			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				mouse2Up = tick()
				local currPos = input.Position
				if mouse2Up - mouse2Down < 0.25 and (currPos - mouse2DownPos).magnitude < 5 then
					local positions = {currPos}
					OnTap(positions)
				end
			end
		end)
		TapConn = UIS.TouchTap:connect(function(touchPositions, processed)
			if not processed then
				OnTap(touchPositions)
			end
		end)

		if not UIS.TouchEnabled then -- PC
			if AutoJumperInstance then
				AutoJumperInstance:Stop()
				AutoJumperInstance = nil
			end
			AutoJumperInstance = AutoJumper()
		end

		local function Update()
			if CameraModule then
				if CameraModule.UserPanningTheCamera then
					CameraModule.UpdateTweenFunction = nil
				else
					if CameraModule.UpdateTweenFunction then
						local done = CameraModule.UpdateTweenFunction()
						if done then
							CameraModule.UpdateTweenFunction = nil
						end
					end
				end
				CameraModule:Update()
			end
		end
		
		local success = pcall(function() RunService:BindToRenderStep("ClickToMoveRenderUpdate",Enum.RenderPriority.Camera.Value - 1,Update) end)
		if not success then
			if RenderSteppedConn then
				RenderSteppedConn:disconnect()
			end
			RenderSteppedConn = RunService.RenderStepped:connect(Update)
		end

		local function OnCharacterChildAdded(child)
			if UIS.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = true
				end
			end
			if child:IsA('Humanoid') then
				disconnectEvent(HumanoidDiedConn)
				HumanoidDiedConn = child.Died:connect(function()
					DebrisService:AddItem(ExistingIndicator, 1)
					if AutoJumperInstance then
						AutoJumperInstance:Stop()
						AutoJumperInstance = nil
					end
				end)
			end
		end

		CharacterChildAddedConn = character.ChildAdded:connect(function(child)
			OnCharacterChildAdded(child)
		end)
		CharacterChildRemovedConn = character.ChildRemoved:connect(function(child)
			if UIS.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = false
				end
			end
		end)
		for _, child in pairs(character:GetChildren()) do
			OnCharacterChildAdded(child)
		end
	end

	local Running = false

	function this:Stop()
		if Running then
			DisconnectEvents()
			CleanupPath()
			if AutoJumperInstance then
				AutoJumperInstance:Stop()
				AutoJumperInstance = nil
			end
			if CameraModule then
				CameraModule.UpdateTweenFunction = nil
				CameraModule:SetEnabled(false)
			end
			-- Restore tool activation on shutdown
			if UIS.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA('Tool') then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			Running = false
		end
	end

	function this:Start()
		if not Running then
			if Player.Character then -- retro-listen
				OnCharacterAdded(Player.Character)
			end
			OnCharacterAddedConn = Player.CharacterAdded:connect(OnCharacterAdded)
			if CameraModule then
				CameraModule:SetEnabled(true)
			end
			Running = true
		end
	end

	return this
end

return CreateClickToMoveModule
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX56DF04A848624E879710A62E2E9A7F28">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Invisicam</string>
						<ProtectedString name="Source"><![CDATA[-- Invisicam Version 2.5 (Occlusion Series)
-- For the latest standalone version see id=183837794
-- OnlyTwentyCharacters

local Invisicam = {}

---------------
-- Constants --
---------------

local FADE_TARGET = 0.75
local FADE_RATE = 0.1

local MODE = {
	CUSTOM = 1, -- Whatever you want!
	LIMBS = 2, -- Track limbs
	MOVEMENT = 3, -- Track movement
	CORNERS = 4, -- Char model corners
	CIRCLE1 = 5, -- Circle of casts around character
	CIRCLE2 = 6, -- Circle of casts around character, camera relative
	LIMBMOVE = 7, -- LIMBS mode + MOVEMENT mode
}
Invisicam.MODE = MODE

local STARTING_MODE = MODE.LIMBS

local LIMB_TRACKING_SET = {
	['Head'] = true,
	['Left Arm'] = true,
	['Right Arm'] = true,
	['Left Leg'] = true,
	['Right Leg'] = true,
}
local CORNER_FACTORS = {
	Vector3.new(1, 1, -1),
	Vector3.new(1, -1, -1),
	Vector3.new(-1, -1, -1),
	Vector3.new(-1, 1, -1)
}
local CIRCLE_CASTS = 10
local MOVE_CASTS = 3

---------------
-- Variables --
---------------

local RunService = game:GetService('RunService')
local PlayersService = game:GetService('Players')
local Player = PlayersService.LocalPlayer

local Camera = nil
local Character = nil
local Torso = nil

local Mode = nil
local Behaviors = {} -- Map of modes to behavior fns
local SavedHits = {} -- Objects currently being faded in/out
local TrackedLimbs = {} -- Used in limb-tracking casting modes

---------------
--| Utility |--
---------------

local function AssertTypes(param, ...)
	local allowedTypes = {}
	local typeString = ''
	for _, typeName in pairs({...}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end

local function CameraCast(worldPoint, ignoreList)
	local cameraPoint = Camera.CoordinateFrame.p
	local vector = worldPoint - cameraPoint
	local ray = Ray.new(cameraPoint, vector.Unit * math.min(vector.Magnitude, 999))
	return workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
end

-----------------------
--| Local Functions |--
-----------------------

local function LimbBehavior(castPoints)
	for _, limb in pairs(TrackedLimbs) do
		if limb.Parent then
			table.insert(castPoints, limb.Position)
		end
	end
end

local function MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = Torso.Position, Torso.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * Torso.CFrame.lookVector * horizontalSpeed
		table.insert(castPoints, position + offsetVector)
	end
end

local function CornerBehavior(castPoints)
	local cframe = Torso.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = Character:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
	table.insert(castPoints, centerPoint)
	for _, factor in pairs(CORNER_FACTORS) do
		table.insert(castPoints, centerPoint + (rotation * (halfSize * factor)))
	end
end

local function CircleBehavior(castPoints)
	local cframe = nil
	if Mode == MODE.CIRCLE1 then
		cframe = Torso.CFrame
	else
		local camCFrame = Camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + Torso.Position
	end
	table.insert(castPoints, cframe.p)
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = (2 * math.pi / CIRCLE_CASTS) * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		table.insert(castPoints, cframe * offset)
	end
end

local function LimbMoveBehavior(castPoints)
	LimbBehavior(castPoints)
	MoveBehavior(castPoints)
end

local function OnCharacterAdded(character)
	Character = character
	Torso = Character:WaitForChild('Torso')
	
	TrackedLimbs = {}
	for _, child in pairs(Character:GetChildren()) do
		if child:IsA('BasePart') and LIMB_TRACKING_SET[child.Name] then
			table.insert(TrackedLimbs, child)
		end
	end
end

local function OnWorkspaceChanged(property)
	if property == 'CurrentCamera' then
		local newCamera = workspace.CurrentCamera
		if newCamera then
			Camera = newCamera
		end
	end
end

-----------------------
-- Exposed Functions --
-----------------------

-- Update. Called every frame after the camera movement step
function Invisicam:Update()
	-- Make a list of world points to raycast to
	local castPoints = {}
	Behaviors[Mode](castPoints)
	
	-- Cast to get a list of objects between the camera and the cast points
	local currentHits = {}
	local ignoreList = {Character}
	local function add(hit)
		currentHits[hit] = true
		if not SavedHits[hit] then
			SavedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	for _, worldPoint in pairs(castPoints) do
		local hitPart
		repeat
			hitPart = CameraCast(worldPoint, ignoreList)
			if hitPart then
				add(hitPart)
				for _, child in pairs(hitPart:GetChildren()) do
					if child:IsA('Decal') or child:IsA('Texture') then
						add(child)
					end
				end
				table.insert(ignoreList, hitPart) -- Next ray will go through this part
			end
		until not hitPart
	end
	
	-- Fade out objects that are in the way, restore those that aren't anymore
	for hit, originalFade in pairs(SavedHits) do
		local currentFade = hit.LocalTransparencyModifier
		if currentHits[hit] then -- Fade
			if currentFade < FADE_TARGET then
				hit.LocalTransparencyModifier = math.min(currentFade + FADE_RATE, FADE_TARGET)
			end
		else -- Restore
			if currentFade > originalFade then
				hit.LocalTransparencyModifier = math.max(originalFade, currentFade - FADE_RATE)
			else
				SavedHits[hit] = nil
			end
		end
	end
end

function Invisicam:SetMode(newMode)
	AssertTypes(newMode, 'number')
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			Mode = newMode
			return
		end
	end
	error("Invalid mode number")
end

function Invisicam:SetCustomBehavior(func)
	AssertTypes(func, 'function')
	Behaviors[MODE.CUSTOM] = func
end

-- Want to turn off Invisicam? Be sure to call this after.
function Invisicam:Cleanup()
	for hit, originalFade in pairs(SavedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end

---------------------
--| Running Logic |--
---------------------

-- Connect to the current and all future cameras
workspace.Changed:connect(OnWorkspaceChanged)
OnWorkspaceChanged('CurrentCamera')

Player.CharacterAdded:connect(OnCharacterAdded)
if Player.Character then
	OnCharacterAdded(Player.Character)
end

Invisicam:SetMode(STARTING_MODE)

Behaviors[MODE.CUSTOM] = function() end -- (Does nothing until SetCustomBehavior)
Behaviors[MODE.LIMBS] = LimbBehavior
Behaviors[MODE.MOVEMENT] = MoveBehavior
Behaviors[MODE.CORNERS] = CornerBehavior
Behaviors[MODE.CIRCLE1] = CircleBehavior
Behaviors[MODE.CIRCLE2] = CircleBehavior
Behaviors[MODE.LIMBMOVE] = LimbMoveBehavior

return Invisicam
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F35A6D56D9642BC8C6FF7B6CEDB13AE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PopperCam</string>
						<ProtectedString name="Source"><![CDATA[-- PopperCam Version 16
-- OnlyTwentyCharacters

local PopperCam = {} -- Guarantees your players won't see outside the bounds of your map!

-----------------
--| Constants |--
-----------------

local POP_RESTORE_RATE = 0.3

local CAST_SCREEN_SCALES = { -- (Relative)
	Vector2.new(1, 1) / 2, -- Center
	Vector2.new(0, 0), -- Top left
	Vector2.new(1, 0), -- Top right
	Vector2.new(1, 1), -- Bottom right
	Vector2.new(0, 1), -- Bottom left
}

local VALID_SUBJECTS = {
	'Humanoid',
	'VehicleSeat',
	'SkateboardPlatform',
}
 
local NEAR_CLIP_PLANE_OFFSET = 0.5 --NOTE: Not configurable here

-----------------
--| Variables |--
-----------------

local PlayersService = game:GetService('Players')

local Camera = nil
local CameraChangeConn = nil

local PlayerCharacters = {} -- For ignoring in raycasts
local VehicleParts = {} -- Also just for ignoring

local LastPopAmount = 0
local LastZoomLevel = 0
local PopperEnabled = false

-----------------------
--| Local Functions |--
-----------------------

local function CastRay(fromPoint, toPoint, ignoreList)
	local vector = toPoint - fromPoint
	local ray = Ray.new(fromPoint, vector.Unit * math.min(vector.Magnitude, 999))
	return workspace:FindPartOnRayWithIgnoreList(ray, ignoreList or {}, false, true)
end

-- Casts and recasts until it hits either: nothing, or something not transparent or collidable
local function PiercingCast(fromPoint, toPoint, ignoreList) --NOTE: Modifies ignoreList!
	repeat
		local hitPart, hitPoint = CastRay(fromPoint, toPoint, ignoreList)
		if hitPart and (hitPart.Transparency > 0.95 or hitPart.CanCollide == false) then
			table.insert(ignoreList, hitPart)
		else
			return hitPart, hitPoint
		end
	until false
end

local function ScreenToWorld(screenPoint, screenSize, pushDepth)
	local cameraFOV, cameraCFrame = Camera.FieldOfView, Camera.CoordinateFrame
	local imagePlaneDepth = screenSize.y / (2 * math.tan(math.rad(cameraFOV) / 2))
	local direction = Vector3.new(screenPoint.x - (screenSize.x / 2), (screenSize.y / 2) - screenPoint.y, -imagePlaneDepth)
	local worldDirection = (cameraCFrame:vectorToWorldSpace(direction)).Unit
	local theta = math.acos(math.min(1, worldDirection:Dot(cameraCFrame.lookVector)))
	local fixedPushDepth = pushDepth / math.sin((math.pi / 2) - theta)
	return cameraCFrame.p + worldDirection * fixedPushDepth
end

local function OnCameraChanged(property)
	if property == 'CameraSubject' then
		VehicleParts = {}
		
		local newSubject = Camera.CameraSubject
		if newSubject then
			-- Determine if we should be popping at all
			PopperEnabled = false
			for _, subjectType in pairs(VALID_SUBJECTS) do
				if newSubject:IsA(subjectType) then
					PopperEnabled = true
					break
				end
			end
			
			-- Get all parts of the vehicle the player is controlling
			if newSubject:IsA('VehicleSeat') then
				VehicleParts = newSubject:GetConnectedParts(true)
			end
		end
	end
end

local function OnCharacterAdded(player, character)
	PlayerCharacters[player] = character
end

local function OnPlayersChildAdded(child)
	if child:IsA('Player') then
		child.CharacterAdded:connect(function(character)
			OnCharacterAdded(child, character)
		end)
		if child.Character then
			OnCharacterAdded(child, child.Character)
		end
	end
end

local function OnPlayersChildRemoved(child)
	if child:IsA('Player') then
		PlayerCharacters[child] = nil
	end
end

local function OnWorkspaceChanged(property)
	if property == 'CurrentCamera' then
		local newCamera = workspace.CurrentCamera
		if newCamera then
			Camera = newCamera
			
			if CameraChangeConn then
				CameraChangeConn:disconnect()
			end
			CameraChangeConn = Camera.Changed:connect(OnCameraChanged)
			OnCameraChanged('CameraSubject')
		end
	end
end

-------------------------
--| Exposed Functions |--
-------------------------

function PopperCam:Update()
	if PopperEnabled then
		-- First, prep some intermediate vars
		local focusPoint = Camera.Focus.p
		local cameraCFrame = Camera.CoordinateFrame
		local cameraFrontPoint = cameraCFrame.p + (cameraCFrame.lookVector * NEAR_CLIP_PLANE_OFFSET)
		local screenSize = Camera.ViewportSize
		local ignoreList = {}
		for _, character in pairs(PlayerCharacters) do
			table.insert(ignoreList, character)
		end
		for _, basePart in pairs(VehicleParts) do
			table.insert(ignoreList, basePart)
		end
		
		-- Cast rays at the near clip plane, from corresponding points near the focus point,
		-- and find the direct line that is the most cut off
		local largest = 0
		for _, screenScale in pairs(CAST_SCREEN_SCALES) do
			local clipWorldPoint = ScreenToWorld(screenSize * screenScale, screenSize, NEAR_CLIP_PLANE_OFFSET)
			local rayStartPoint = focusPoint + (clipWorldPoint - cameraFrontPoint)
			local _, hitPoint = PiercingCast(rayStartPoint, clipWorldPoint, ignoreList)
			local cutoffAmount = (hitPoint - clipWorldPoint).Magnitude
			if cutoffAmount > largest then
				largest = cutoffAmount
			end
		end
		
		-- Then check if the player zoomed since the last frame,
		-- and if so, reset our pop history so we stop tweening
		local zoomLevel = (cameraCFrame.p - focusPoint).Magnitude
		if math.abs(zoomLevel - LastZoomLevel) > 0.001 then
			LastPopAmount = 0
		end
		
		-- Finally, zoom the camera in (pop) by that most-cut-off amount, or the last pop amount if that's more
		local popAmount = math.max(largest, LastPopAmount)
		if popAmount > 0 then
			Camera.CoordinateFrame = cameraCFrame + (cameraCFrame.lookVector * popAmount)
			LastPopAmount = math.max(0, popAmount - POP_RESTORE_RATE) -- Shrink it for the next frame
		end
		
		LastZoomLevel = zoomLevel
	end
end

--------------------
--| Script Logic |--
--------------------

-- Connect to the current and all future cameras
workspace.Changed:connect(OnWorkspaceChanged)
OnWorkspaceChanged('CurrentCamera')

-- Connect to all Players so we can ignore their Characters
PlayersService.ChildRemoved:connect(OnPlayersChildRemoved)
PlayersService.ChildAdded:connect(OnPlayersChildAdded)
for _, player in pairs(PlayersService:GetPlayers()) do
	OnPlayersChildAdded(player)
end

return PopperCam
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4F844EEFA8234E7E937866A5E5FBAE7A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RootCamera</string>
						<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService('UserInputService')
local PlayersService = game:GetService('Players')

local CameraScript = script.Parent
local ShiftLockController = require(CameraScript:WaitForChild('ShiftLockController'))

local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local IsTouch = UserInputService.TouchEnabled

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	return num
end

local function findAngleBetweenXZVectors(vec2, vec1)
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local THUMBSTICK_DEADZONE = 0.2

local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Humanoid') then
					humanoidCache[player] = child
					return child
				end
			end
		end
	end
end

local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)

local TOUCH_SENSITIVTY = Vector2.new(math.pi*2.25, math.pi*2)
local MOUSE_SENSITIVITY = Vector2.new(math.pi*4, math.pi*1.9)

local Old = Vector2.new(math.pi*4, math.pi*1.9)
function _G.MouseSensitivity(Sensitivity)
	MOUSE_SENSITIVITY = Old * Sensitivity
end

local SEAT_OFFSET = Vector3.new(0,5,0)
local HEAD_OFFSET = Vector3.new(0, 1.5, 0)

-- Reset the camera look vector when the camera is enabled for the first time
local SetCameraOnSpawn = true


local UseRenderCFrame = false
pcall(function()
	local rc = Instance.new('Part'):GetRenderCFrame()
	UseRenderCFrame = (rc ~= nil)
end)

local function GetRenderCFrame(part)
	return UseRenderCFrame and part:GetRenderCFrame() or part.CFrame
end

local function CreateCamera()
	local this = {}

	this.ShiftLock = false
	this.Enabled = false
	local pinchZoomSpeed = 20
	local isFirstPerson = false
	local isRightMouseDown = false
	this.RotateInput = Vector2.new()
	
	function this:GetShiftLock()
		return ShiftLockController:IsShiftLocked()
	end

	function this:GetHumanoid()
		local player = PlayersService.LocalPlayer
		return findPlayerHumanoid(player)
	end

	function this:GetHumanoidRootPart()
		local humanoid = this:GetHumanoid()
		return humanoid and humanoid.Torso
	end

	function this:GetRenderCFrame(part)
		GetRenderCFrame(part)
	end

	function this:GetSubjectPosition()
		local result = nil
		local camera = workspace.CurrentCamera
		local cameraSubject = camera and camera.CameraSubject
		if cameraSubject then
			if cameraSubject:IsA('VehicleSeat') then
				local subjectCFrame = GetRenderCFrame(cameraSubject)
				result = subjectCFrame.p + subjectCFrame:vectorToWorldSpace(SEAT_OFFSET)
			elseif cameraSubject:IsA('SkateboardPlatform') then
				local subjectCFrame = GetRenderCFrame(cameraSubject)
				result = subjectCFrame.p + SEAT_OFFSET
			elseif cameraSubject:IsA('BasePart') then
				local subjectCFrame = GetRenderCFrame(cameraSubject)
				result = subjectCFrame.p
			elseif cameraSubject:IsA('Model') then
				result = cameraSubject:GetModelCFrame().p
			elseif cameraSubject:IsA('Humanoid') then
				local humanoidRootPart = cameraSubject.Torso
				if humanoidRootPart and humanoidRootPart:IsA('BasePart') then
					local subjectCFrame = GetRenderCFrame(humanoidRootPart)
					result = subjectCFrame.p +
						subjectCFrame:vectorToWorldSpace(HEAD_OFFSET + cameraSubject.CameraOffset)
				end
			end
		end
		return result
	end

	function this:ResetCameraLook()
	end

	function this:GetCameraLook()
		return workspace.CurrentCamera and workspace.CurrentCamera.CoordinateFrame.lookVector or Vector3.new(0,0,1)
	end

	function this:GetCameraZoom()
		if this.currentZoom == nil then
			local player = PlayersService.LocalPlayer
			this.currentZoom = player and clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, 10) or 10
		end
		return this.currentZoom
	end

	function this:GetCameraActualZoom()
		local camera = workspace.CurrentCamera
		if camera then
			return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		end
	end

	function this:ViewSizeX()
		local result = 1024
		local player = PlayersService.LocalPlayer
		local mouse = player and player:GetMouse()
		if mouse then
			result = mouse.ViewSizeX
		end
		return result
	end

	function this:ViewSizeY()
		local result = 768
		local player = PlayersService.LocalPlayer
		local mouse = player and player:GetMouse()
		if mouse then
			result = mouse.ViewSizeY
		end
		return result
	end

	function this:ScreenTranslationToAngle(translationVector)
		local screenX = this:ViewSizeX()
		local screenY = this:ViewSizeY()
		local xTheta = (translationVector.x / screenX)
		local yTheta = (translationVector.y / screenY)
		return Vector2.new(xTheta, yTheta)
	end

	function this:MouseTranslationToAngle(translationVector)
		local xTheta = (translationVector.x / 1920)
		local yTheta = (translationVector.y / 1200)
		return Vector2.new(xTheta, yTheta)
	end

	function this:RotateCamera(startLook, xyRotateVector)
		-- Could cache these values so we don't have to recalc them all the time
		local startCFrame = CFrame.new(Vector3.new(), startLook)
		local startVertical = math.asin(startLook.y)
		local yTheta = clamp(-MAX_Y + startVertical, -MIN_Y + startVertical, xyRotateVector.y)
		local resultLookVector = (CFrame.Angles(0, -xyRotateVector.x, 0) * startCFrame * CFrame.Angles(-yTheta,0,0)).lookVector
		return resultLookVector, Vector2.new(xyRotateVector.x, yTheta)
	end

	function this:IsInFirstPerson()
		return isFirstPerson
	end

	-- there are several cases to consider based on the state of input and camera rotation mode
	function this:UpdateMouseBehavior()
		-- first time transition to first person mode or shiftlock
		if isFirstPerson or self:GetShiftLock() then
			if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				pcall(function() GameSettings.RotationType = Enum.RotationType.CameraRelative end)
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
			end
		else
			pcall(function() GameSettings.RotationType = Enum.RotationType.MovementRelative end)
			if isRightMouseDown then
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
			else
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end	
		end
	end

	function this:ZoomCamera(desiredZoom)
		local player = PlayersService.LocalPlayer
		if player then
			if player.CameraMode == Enum.CameraMode.LockFirstPerson then
				this.currentZoom = 0
			else
				this.currentZoom = clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredZoom)
			end
			if _G.ZoomChanged then
				_G.ZoomChanged(this.currentZoom)
			end
		end

		isFirstPerson = self:GetCameraZoom() < 2

		ShiftLockController:SetIsInFirstPerson(isFirstPerson)
		-- set mouse behavior
		self:UpdateMouseBehavior()
		return self:GetCameraZoom()
	end

	local function rk4Integrator(position, velocity, t)
		local direction = velocity < 0 and -1 or 1
		local function acceleration(p, v)
			local accel = direction * math.max(1, (p / 3.3) + 0.5)
			return accel
		end

		local p1 = position
		local v1 = velocity
		local a1 = acceleration(p1, v1)
		local p2 = p1 + v1 * (t / 2)
		local v2 = v1 + a1 * (t / 2)
		local a2 = acceleration(p2, v2)
		local p3 = p1 + v2 * (t / 2)
		local v3 = v1 + a2 * (t / 2)
		local a3 = acceleration(p3, v3)
		local p4 = p1 + v3 * t
		local v4 = v1 + a3 * t
		local a4 = acceleration(p4, v4)

		local positionResult = position + (v1 + 2 * v2 + 2 * v3 + v4) * (t / 6)
		local velocityResult = velocity + (a1 + 2 * a2 + 2 * a3 + a4) * (t / 6)
		return positionResult, velocityResult
	end

	function this:ZoomCameraBy(zoomScale)
		local zoom = this:GetCameraActualZoom()
		if zoom then
			-- Can break into more steps to get more accurate integration
			zoom = rk4Integrator(zoom, zoomScale, 1)
			self:ZoomCamera(zoom)
		end
		return self:GetCameraZoom()
	end

	function this:ZoomCameraFixedBy(zoomIncrement)
		return self:ZoomCamera(self:GetCameraZoom() + zoomIncrement)
	end

	function this:Update()
	end

	---- Input Events ----
	local startPos = nil
	local lastPos = nil
	local panBeginLook = nil

	local fingerTouches = {}
	local NumUnsunkTouches = 0

	local StartingDiff = nil
	local pinchBeginZoom = nil

	this.ZoomEnabled = true
	this.PanEnabled = true
	this.KeyPanEnabled = true

	local function OnTouchBegan(input, processed)
		fingerTouches[input] = processed
		if not processed then
			NumUnsunkTouches = NumUnsunkTouches + 1
		end
	end

	local function OnTouchChanged(input, processed)
		if fingerTouches[input] == nil then
			fingerTouches[input] = processed
			if not processed then
				NumUnsunkTouches = NumUnsunkTouches + 1
			end
		end

		if NumUnsunkTouches == 1 then
			if fingerTouches[input] == false then
				panBeginLook = panBeginLook or this:GetCameraLook()
				startPos = startPos or input.Position
				lastPos = lastPos or startPos
				this.UserPanningTheCamera = true

				local delta = input.Position - lastPos
				if this.PanEnabled then
					local desiredXYVector = this:ScreenTranslationToAngle(delta) * TOUCH_SENSITIVTY
					this.RotateInput = this.RotateInput + desiredXYVector
				end

				lastPos = input.Position
			end
		else
			panBeginLook = nil
			startPos = nil
			lastPos = nil
			this.UserPanningTheCamera = false
		end
		if NumUnsunkTouches == 2 then
			local unsunkTouches = {}
			for touch, wasSunk in pairs(fingerTouches) do
				if not wasSunk then
					table.insert(unsunkTouches, touch)
				end
			end
			if #unsunkTouches == 2 then
				local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
				if StartingDiff and pinchBeginZoom then
					local scale = difference / math.max(0.01, StartingDiff)
					local clampedScale = clamp(0.1, 10, scale)
					if this.ZoomEnabled then
						this:ZoomCamera(pinchBeginZoom / clampedScale)
					end
				else
					StartingDiff = difference
					pinchBeginZoom = this:GetCameraActualZoom()
				end
			end
		else
			StartingDiff = nil
			pinchBeginZoom = nil
		end
	end

	local function OnTouchEnded(input, processed)
		if fingerTouches[input] == false then
			if NumUnsunkTouches == 1 then
				panBeginLook = nil
				startPos = nil
				lastPos = nil
				this.UserPanningTheCamera = false
			elseif NumUnsunkTouches == 2 then
				StartingDiff = nil
				pinchBeginZoom = nil
			end
		end

		if fingerTouches[input] ~= nil and fingerTouches[input] == false then
			NumUnsunkTouches = NumUnsunkTouches - 1
		end
		fingerTouches[input] = nil
	end

	local function OnMouse2Down(input, processed)
		if processed then return end
		isRightMouseDown = true
		this:UpdateMouseBehavior()
		panBeginLook = this:GetCameraLook()
		startPos = input.Position
		lastPos = startPos
		this.UserPanningTheCamera = true
	end

	local function OnMouse2Up(input, processed)
		isRightMouseDown = false
		this:UpdateMouseBehavior()
		panBeginLook = nil
		startPos = nil
		lastPos = nil
		this.UserPanningTheCamera = false
	end

	local function OnMouseMoved(input, processed)
		if startPos and lastPos and panBeginLook then
			local currPos = lastPos + input.Delta
			local totalTrans = currPos - startPos
			if this.PanEnabled then
				local desiredXYVector = this:MouseTranslationToAngle(input.Delta) * MOUSE_SENSITIVITY
				this.RotateInput = this.RotateInput + desiredXYVector
			end
			lastPos = currPos
		elseif this:IsInFirstPerson() or this:GetShiftLock() then
			if this.PanEnabled then
				local desiredXYVector = this:MouseTranslationToAngle(input.Delta) * MOUSE_SENSITIVITY
				this.RotateInput = this.RotateInput + desiredXYVector
			end
		end
	end

	local function OnMouseWheel(input, processed)
		if not processed then
			if this.ZoomEnabled then
				this:ZoomCameraBy(clamp(-1, 1, -input.Position.Z) * 1.4)
			end
		end
	end

	local function round(num)
		return math.floor(num + 0.5)
	end

	local eight2Pi = math.pi / 4

	local function rotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
		if camLook ~= Vector3.new(0,0,0) then
			camLook = camLook.unit
			local currAngle = math.atan2(camLook.z, camLook.x)
			local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
			return newAngle - currAngle
		end
		return 0
	end

	local function OnKeyDown(input, processed)
		if processed then return end
		if this.ZoomEnabled then
			if input.KeyCode == Enum.KeyCode.I then
				this:ZoomCameraBy(-5)
			elseif input.KeyCode == Enum.KeyCode.O then
				this:ZoomCameraBy(5)
			end
		end
		if panBeginLook == nil and this.KeyPanEnabled then
			if input.KeyCode == Enum.KeyCode.Left then
				this.TurningLeft = true
			elseif input.KeyCode == Enum.KeyCode.Right then
				this.TurningRight = true
			elseif input.KeyCode == Enum.KeyCode.Comma then
				local angle = rotateVectorByAngleAndRound(this:GetCameraLook() * Vector3.new(1,0,1), -eight2Pi * (3/4), eight2Pi)
				if angle ~= 0 then
					this.RotateInput = this.RotateInput + Vector2.new(angle, 0)
					this.LastUserPanCamera = tick()
					this.LastCameraTransform = nil
				end
			elseif input.KeyCode == Enum.KeyCode.Period then
				local angle = rotateVectorByAngleAndRound(this:GetCameraLook() * Vector3.new(1,0,1), eight2Pi * (3/4), eight2Pi)
				if angle ~= 0 then
					this.RotateInput = this.RotateInput + Vector2.new(angle, 0)
					this.LastUserPanCamera = tick()
					this.LastCameraTransform = nil
				end
			elseif input.KeyCode == Enum.KeyCode.PageUp then
			--elseif input.KeyCode == Enum.KeyCode.Home then
				this.RotateInput = this.RotateInput + Vector2.new(0,math.rad(15))
				this.LastCameraTransform = nil
			elseif input.KeyCode == Enum.KeyCode.PageDown then
			--elseif input.KeyCode == Enum.KeyCode.End then
				this.RotateInput = this.RotateInput + Vector2.new(0,math.rad(-15))
				this.LastCameraTransform = nil
			end
		end
	end

	local function OnKeyUp(input, processed)
		if input.KeyCode == Enum.KeyCode.Left then
			this.TurningLeft = false
		elseif input.KeyCode == Enum.KeyCode.Right then
			this.TurningRight = false
		end
	end

	local lastThumbstickRotate = nil
	local numOfSeconds = 0.7
	local currentSpeed = 0
	local maxSpeed = 0.1
	local thumbstickSensitivity = 1.0
	local lastThumbstickPos = Vector2.new(0,0)
	local ySensitivity = 0.65
	local lastVelocity = nil

	-- K is a tunable parameter that changes the shape of the S-curve
	-- the larger K is the more straight/linear the curve gets
	local k = 0.35
	local lowerK = 0.8
	local function SCurveTranform(t)
		t = clamp(-1,1,t)
		if t >= 0 then
			return (k*t) / (k - t + 1)
		end
		return -((lowerK*-t) / (lowerK + t + 1))
	end

	-- DEADZONE
	local DEADZONE = 0.1
	local function toSCurveSpace(t)
		return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
	end

	local function fromSCurveSpace(t)
		return t/2 + 0.5
	end

	local function gamepadLinearToCurve(thumbstickPosition)
		local function onAxis(axisValue)
			local sign = 1
			if axisValue < 0 then
				sign = -1
			end
			local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
			point = point * sign
			return clamp(-1,1,point)
		end
		return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
	end

	function this:UpdateGamepad()
		local gamepadPan = this.GamepadPanningCamera
		if gamepadPan then
			gamepadPan = gamepadLinearToCurve(gamepadPan)
			local currentTime = tick()
			if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
				this.userPanningTheCamera = true
			elseif gamepadPan == Vector2.new(0,0) then
				lastThumbstickRotate = nil
				if lastThumbstickPos == Vector2.new(0,0) then
					currentSpeed = 0
				end
			end

			local finalConstant = 0

			if lastThumbstickRotate then
				local elapsedTime = (currentTime - lastThumbstickRotate) * 10
				currentSpeed = currentSpeed + (maxSpeed * ((elapsedTime*elapsedTime)/numOfSeconds))

				if currentSpeed > maxSpeed then currentSpeed = maxSpeed end

				if lastVelocity then
					local velocity = (gamepadPan - lastThumbstickPos)/(currentTime - lastThumbstickRotate)
					local velocityDeltaMag = (velocity - lastVelocity).magnitude

					if velocityDeltaMag > 12 then
						currentSpeed = currentSpeed * (20/velocityDeltaMag)
						if currentSpeed > maxSpeed then currentSpeed = maxSpeed end
					end
				end

				finalConstant = thumbstickSensitivity * currentSpeed
				lastVelocity = (gamepadPan - lastThumbstickPos)/(currentTime - lastThumbstickRotate)
			end

			lastThumbstickPos = gamepadPan
			lastThumbstickRotate = currentTime

			return Vector2.new( gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * ySensitivity)
		end

		return Vector2.new(0,0)
	end

	local InputBeganConn, InputChangedConn, InputEndedConn, ShiftLockToggleConn = nil, nil, nil, nil

	function this:DisconnectInputEvents()
		if InputBeganConn then
			InputBeganConn:disconnect()
			InputBeganConn = nil
		end
		if InputChangedConn then
			InputChangedConn:disconnect()
			InputChangedConn = nil
		end
		if InputEndedConn then
			InputEndedConn:disconnect()
			InputEndedConn = nil
		end
		if ShiftLockToggleConn then
			ShiftLockToggleConn:disconnect()
			ShiftLockToggleConn = nil
		end
		this.TurningLeft = false
		this.TurningRight = false
		this.LastCameraTransform = nil
		self.LastSubjectCFrame = nil
		this.UserPanningTheCamera = false
		this.RotateInput = Vector2.new()
		this.GamepadPanningCamera = Vector2.new(0,0)

		-- Reset input states
		startPos = nil
		lastPos = nil
		panBeginLook = nil
		isRightMouseDown = false

		fingerTouches = {}
		NumUnsunkTouches = 0

		StartingDiff = nil
		pinchBeginZoom = nil

		-- Unlock mouse for example if right mouse button was being held down
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end

	function this:ConnectInputEvents()
		InputBeganConn = UserInputService.InputBegan:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch and IsTouch then
				OnTouchBegan(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseButton2 and not IsTouch then
				OnMouse2Down(input, processed)
			end
			-- Keyboard
			if input.UserInputType == Enum.UserInputType.Keyboard then
				OnKeyDown(input, processed)
			end
		end)

		InputChangedConn = UserInputService.InputChanged:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch and IsTouch then
				OnTouchChanged(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseMovement and not IsTouch then
				OnMouseMoved(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseWheel and not IsTouch then
				OnMouseWheel(input, processed)
			end
		end)

		InputEndedConn = UserInputService.InputEnded:connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch and IsTouch then
				OnTouchEnded(input, processed)
			elseif input.UserInputType == Enum.UserInputType.MouseButton2 and not IsTouch then
				OnMouse2Up(input, processed)
			end
			-- Keyboard
			if input.UserInputType == Enum.UserInputType.Keyboard then
				OnKeyUp(input, processed)
			end
		end)
		
		ShiftLockToggleConn = ShiftLockController.OnShiftLockToggled.Event:connect(function()
			this:UpdateMouseBehavior()
		end)

		this.RotateInput = Vector2.new()

		local getGamepadPan = function(name, state, input)
			if input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.Thumbstick2 then

				if state == Enum.UserInputState.Cancel then
					this.GamepadPanningCamera = Vector2.new(0,0)
					return
				end

				local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
				if inputVector.magnitude > THUMBSTICK_DEADZONE then
					this.GamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
				else
					this.GamepadPanningCamera = Vector2.new(0,0)
				end
			end
		end

		local doGamepadZoom = function(name, state, input)
			if input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.ButtonR3 and state == Enum.UserInputState.Begin then
				if this.currentZoom > 0.5 then
					this:ZoomCamera(0)
				else
					this:ZoomCamera(10)
				end
			end
		end

		game.ContextActionService:BindAction("RootCamGamepadPan", getGamepadPan, false, Enum.KeyCode.Thumbstick2)
		game.ContextActionService:BindAction("RootCamGamepadZoom", doGamepadZoom, false, Enum.KeyCode.ButtonR3)

		-- set mouse behavior
		self:UpdateMouseBehavior()
	end

	function this:SetEnabled(newState)
		if newState ~= self.Enabled then
			self.Enabled = newState
			if self.Enabled then
				self:ConnectInputEvents()
			else
				self:DisconnectInputEvents()
			end
		end
	end

	local function OnPlayerAdded(player)
		player.Changed:connect(function(prop)
			if this.Enabled then
				if prop == "CameraMode" or prop == "CameraMaxZoomDistance" or prop == "CameraMinZoomDistance" then
					 this:ZoomCameraFixedBy(0)
				end
			end
		end)

		local function OnCharacterAdded(newCharacter)
			this:ZoomCamera(12.5)
			local humanoid = findPlayerHumanoid(player)
			local start = tick()
			while tick() - start < 0.3 and (humanoid == nil or humanoid.Torso == nil) do
				wait()
				humanoid = findPlayerHumanoid(player)
			end
			local function setLookBehindChatacter()
				if humanoid and humanoid.Torso and player.Character == newCharacter then
					local newDesiredLook = (humanoid.Torso.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
					local horizontalShift = findAngleBetweenXZVectors(newDesiredLook, this:GetCameraLook())
					local vertShift = math.asin(this:GetCameraLook().y) - math.asin(newDesiredLook.y)
					if not IsFinite(horizontalShift) then
						horizontalShift = 0
					end
					if not IsFinite(vertShift) then
						vertShift = 0
					end
					this.RotateInput = Vector2.new(horizontalShift, vertShift)

					-- reset old camera info so follow cam doesn't rotate us
					this.LastCameraTransform = nil
				end
			end
			wait()
			setLookBehindChatacter()
		end

		player.CharacterAdded:connect(function(character)
			if this.Enabled or SetCameraOnSpawn then
				OnCharacterAdded(character)
				SetCameraOnSpawn = false
			end
		end)
		if player.Character then
			spawn(function() OnCharacterAdded(player.Character) end)
		end
	end
	if PlayersService.LocalPlayer then
		OnPlayerAdded(PlayersService.LocalPlayer)
	end
	PlayersService.ChildAdded:connect(function(child)
		if child and PlayersService.LocalPlayer == child then
			OnPlayerAdded(PlayersService.LocalPlayer)
		end
	end)

	return this
end

return CreateCamera
]]></ProtectedString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1CC12E7091FA4AEE81C9D4DDFCC8E575">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AttachCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local XZ_VECTOR = Vector3.new(1,0,1)


local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

-- May return NaN or inf or -inf
-- This is a way of finding the angle between the two vectors:
local function findAngleBetweenXZVectors(vec2, vec1)
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function CreateAttachCamera()
	local module = RootCameraCreator()
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end	
		
		local subjectPosition = self:GetSubjectPosition()		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			if self.LastCameraTransform then
				local humanoid = self:GetHumanoid()
				if lastUpdate and humanoid and humanoid.Torso then
					local forwardVector = humanoid.Torso.CFrame.lookVector

					local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
					if IsFinite(y) and math.abs(y) > 0.0001 then
						self.RotateInput = self.RotateInput + Vector2.new(y, 0)
					end
				end
			end
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end
	
	return module
end

return CreateAttachCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7D9DDB45AFEB474ABD4DB21C88146591">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClassicCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local UP_VECTOR = Vector3.new(0, 1, 0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	print("Trying to clamp when low:", low , "is larger than high:" , high , "returning input value.")
	return num
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

-- May return NaN or inf or -inf
-- This is a way of finding the angle between the two vectors:
local function findAngleBetweenXZVectors(vec2, vec1)
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function CreateClassicCamera()
	local module = RootCameraCreator()
	
	local tweenAcceleration = math.rad(220)
	local tweenSpeed = math.rad(0)
	local tweenMaxSpeed = math.rad(250)
	local timeBeforeAutoRotate = 2
	
	local lastThumbstickRotate = nil
	local numOfSeconds = 0.7
	local currentSpeed = 0
	local maxSpeed = 0.1
	local thumbstickSensitivity = 1
	local lastThumbstickPos = Vector2.new(0,0)
	local ySensitivity = 0.8
	local lastVelocity = nil
	
	local lastUpdate = tick()
	module.LastUserPanCamera = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		local humanoid = self:GetHumanoid()
		local cameraSubject = camera and camera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end	
		
		if lastUpdate then
			-- Cap out the delta to 0.5 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.5, now - lastUpdate)
			local angle = 0
			if not (isInVehicle or isOnASkateboard) then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			
			local gamepadRotation = self:UpdateGamepad()
			if gamepadRotation ~= Vector2.new(0,0) then
				userPanningTheCamera = true
				self.RotateInput = self.RotateInput + gamepadRotation
			end
					
			if angle ~= 0 then
				userPanningTheCamera = true
				self.RotateInput = self.RotateInput + Vector2.new(math.rad(angle * delta), 0)
			end
		end

		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			tweenSpeed = 0
			module.LastUserPanCamera = tick()
		end
		
		local userRecentlyPannedCamera = now - module.LastUserPanCamera < timeBeforeAutoRotate
		local subjectPosition = self:GetSubjectPosition()
		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom < 0.5 then
				zoom = 0.5
			end
			
			if self:GetShiftLock() and not self:IsInFirstPerson() then
				-- We need to use the right vector of the camera after rotation, not before
				local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
				local offset = ((newLookVector * XZ_VECTOR):Cross(UP_VECTOR).unit * 1.75)

				if IsFiniteVector3(offset) then
					subjectPosition = subjectPosition + offset
				end
			else
				if self.LastCameraTransform and not userPanningTheCamera then
					local isInFirstPerson = self:IsInFirstPerson()
					if (isInVehicle or isOnASkateboard) and lastUpdate and humanoid and humanoid.Torso then
						if isInFirstPerson then
							if self.LastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
								local y = -findAngleBetweenXZVectors(self.LastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
								if IsFinite(y) then
									self.RotateInput = self.RotateInput + Vector2.new(y, 0)
								end
								tweenSpeed = 0
							end
						elseif not userRecentlyPannedCamera then
							local forwardVector = humanoid.Torso.CFrame.lookVector
							if isOnASkateboard then
								forwardVector = cameraSubject.CFrame.lookVector
							end
							local timeDelta = (now - lastUpdate)
							
							tweenSpeed = clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)
	
							local percent = clamp(0, 1, tweenSpeed * timeDelta)
							if self:IsInFirstPerson() then
								percent = 1
							end
							
							local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
							if IsFinite(y) and math.abs(y) > 0.0001 then
								self.RotateInput = self.RotateInput + Vector2.new(y * percent, 0)
							end
						end
					end
				end
			end
			
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
			if isInVehicle or isOnASkateboard and cameraSubject:IsA('BasePart') then
				self.LastSubjectCFrame = cameraSubject.CFrame
			else
				self.LastSubjectCFrame = nil
			end
		end
		
		lastUpdate = now
	end
	
	return module
end

return CreateClassicCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX502E0EE0BAC847E8A2A76BF1EDFFE5D9">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">FixedCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)


local function CreateFixedCamera()
	local module = RootCameraCreator()
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end
		
		local subjectPosition = self:GetSubjectPosition()		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end
	
	return module
end

return CreateFixedCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX06C23E17BE7B4A86A060DD698A720FD7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">FollowCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local UP_VECTOR = Vector3.new(0, 1, 0)
local XZ_VECTOR = Vector3.new(1,0,1)

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	print("Trying to clamp when low:", low , "is larger than high:" , high , "returning input value.")
	return num
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

-- May return NaN or inf or -inf
local function findAngleBetweenXZVectors(vec2, vec1)
	-- This is a way of finding the angle between the two vectors:
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function CreateFollowCamera()
	local module = RootCameraCreator()	
	
	local tweenAcceleration = math.rad(220)
	local tweenSpeed = math.rad(0)
	local tweenMaxSpeed = math.rad(250)
	local timeBeforeAutoRotate = 2
	
	local lastUpdate = tick()
	module.LastUserPanCamera = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		local humanoid = self:GetHumanoid()
		local cameraSubject = camera and camera.CameraSubject
		local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')

		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end
		
		if lastUpdate then
			-- Cap out the delta to 0.5 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.5, now - lastUpdate)
			local angle = 0
			if not (isInVehicle or isOnASkateboard) then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end

			local gamepadRotation = self:UpdateGamepad()
			if gamepadRotation ~= Vector2.new(0,0) then
				userPanningTheCamera = true				
				self.RotateInput = self.RotateInput + gamepadRotation
			end
			
			if angle ~= 0 then
				userPanningTheCamera = true
				self.RotateInput = self.RotateInput + Vector2.new(math.rad(angle * delta), 0)
			end
		end
		
		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			tweenSpeed = 0
			module.LastUserPanCamera = tick()
		end
		
		local userRecentlyPannedCamera = now - module.LastUserPanCamera < timeBeforeAutoRotate
		
		local subjectPosition = self:GetSubjectPosition()		
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom < 0.5 then
				zoom = 0.5
			end
			
			if self:GetShiftLock() and not self:IsInFirstPerson() then
				local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
				local offset = ((newLookVector * XZ_VECTOR):Cross(UP_VECTOR).unit * 1.75)
				if IsFiniteVector3(offset) then
					subjectPosition = subjectPosition + offset
				end
			else
				if self.LastCameraTransform and not userPanningTheCamera then
					local isInFirstPerson = self:IsInFirstPerson()
					if (isClimbing or isInVehicle or isOnASkateboard) and lastUpdate and humanoid and humanoid.Torso then
						if isInFirstPerson then
							if self.LastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
								local y = -findAngleBetweenXZVectors(self.LastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
								if IsFinite(y) then
									self.RotateInput = self.RotateInput + Vector2.new(y, 0)
								end
								tweenSpeed = 0
							end
						elseif not userRecentlyPannedCamera then
							local forwardVector = humanoid.Torso.CFrame.lookVector
							if isOnASkateboard then
								forwardVector = cameraSubject.CFrame.lookVector
							end
							local timeDelta = (now - lastUpdate)

							tweenSpeed = clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)

							local percent = clamp(0, 1, tweenSpeed * timeDelta)
							if not isClimbing and self:IsInFirstPerson() then
								percent = 1
							end
							local y = findAngleBetweenXZVectors(forwardVector, self:GetCameraLook())
							-- Check for NaN
							if IsFinite(y) and math.abs(y) > 0.0001 then
								self.RotateInput = self.RotateInput + Vector2.new(y * percent, 0)
							end
						end
					elseif not (isInFirstPerson or userRecentlyPannedCamera) then
						local lastVec = -(self.LastCameraTransform.p - subjectPosition)
						local y = findAngleBetweenXZVectors(lastVec, self:GetCameraLook())
						-- Check for NaNs
						if IsFinite(y) and math.abs(y) > 0.0001 then
							self.RotateInput = self.RotateInput + Vector2.new(y, 0)
						end
					end
				end
			end
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
			if isInVehicle or isOnASkateboard and cameraSubject:IsA('BasePart') then
				self.LastSubjectCFrame = cameraSubject.CFrame
			else
				self.LastSubjectCFrame = nil
			end
		end
		
		lastUpdate = now
	end
	
	return module
end

return CreateFollowCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAAA1D6EF98FE4A98A3E4F1C52857282A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScriptableCamera</string>
							<ProtectedString name="Source"><![CDATA[local RootCameraCreator = require(script.Parent)

local function CreateScriptableCamera()
	local module = RootCameraCreator()
	
	local lastUpdate = tick()
	function module:Update()
	end
	
	return module
end

return CreateScriptableCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6D13F2182275492F9832739620B9B412">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TrackCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)

local function CreateTrackCamera()
	local module = RootCameraCreator()

	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
		end	
		
		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player and camera then
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
		end
		lastUpdate = now
	end
	
	return module
end

return CreateTrackCamera
]]></ProtectedString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2DD06F7B97794C9DA411565A25ECEB17">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WatchCamera</string>
							<ProtectedString name="Source"><![CDATA[local PlayersService = game:GetService('Players')
local RootCameraCreator = require(script.Parent)


local function CreateWatchCamera()
	local module = RootCameraCreator()
	module.PanEnabled = false
	
	local lastUpdate = tick()
	function module:Update()
		local now = tick()
		
		local camera = 	workspace.CurrentCamera
		local player = PlayersService.LocalPlayer
		
		if lastUpdate == nil or now - lastUpdate > 1 then
			module:ResetCameraLook()
			self.LastCameraTransform = nil
			self.LastZoom = nil
		end	
		
		local subjectPosition = self:GetSubjectPosition()
		if subjectPosition and player and camera then		
			if self.LastCameraTransform then
				local humanoid = self:GetHumanoid()
				if humanoid and humanoid.Torso then
					-- TODO: let the paging buttons move the camera but not the mouse/touch
					-- currently neither do
					local diffVector = subjectPosition - self.LastCameraTransform.p
					self.cameraLook = diffVector.unit
					
					if self.LastZoom and self.LastZoom == self:GetCameraZoom() then
						-- Don't clobber the zoom if they zoomed the camera
						local zoom = diffVector.magnitude
						self:ZoomCamera(zoom)
					end
				end
			end
			
			local zoom = self:GetCameraZoom()
			if zoom <= 0 then
				zoom = 0.1
			end
			
			local newLookVector = self:RotateCamera(self:GetCameraLook(), self.RotateInput)
			self.RotateInput = Vector2.new()
			
			camera.Focus = CFrame.new(subjectPosition)
			camera.CoordinateFrame = CFrame.new(camera.Focus.p - (zoom * newLookVector), camera.Focus.p)
			self.LastCameraTransform = camera.CoordinateFrame
			self.LastZoom = zoom
		end
		lastUpdate = now
	end
	
	return module
end

return CreateWatchCamera
]]></ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX76C164E8F78646DFB562ED533968C434">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ShiftLockController</string>
						<ProtectedString name="Source"><![CDATA[--[[
	// FileName: ShiftLockController
	// Written by: jmargh
	// Version 1.2
	// Description: Manages the state of shift lock mode

	// Required by:
		RootCamera

	// Note: ContextActionService sinks keys, so until we allow binding to ContextActionService without sinking
	// keys, this module will use UserInputService.
--]]
local ContextActionService = game:GetService('ContextActionService')
local Players = game:GetService('Players')
local StarterPlayer = game:GetService('StarterPlayer')
local UserInputService = game:GetService('UserInputService')
-- Settings and GameSettings are read only
local Settings = UserSettings()	-- ignore warning
local GameSettings = Settings.GameSettings

local ShiftLockController = {}

--[[ Script Variables ]]--
while not Players.LocalPlayer do
	wait()
end
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local PlayerGui = LocalPlayer:WaitForChild('PlayerGui')
local ScreenGui = nil
local ShiftLockIcon = nil
local InputCn = nil
local IsShiftLockMode = false
local IsShiftLocked = false
local IsActionBound = false
local IsInFirstPerson = false

-- Toggle Event
ShiftLockController.OnShiftLockToggled = Instance.new('BindableEvent')

-- wrapping long conditional in function
local function isShiftLockMode()
	return LocalPlayer.DevEnableMouseLock and GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch and
			LocalPlayer.DevComputerMovementMode ~= Enum.DevComputerMovementMode.ClickToMove and
			GameSettings.ComputerMovementMode ~= Enum.ComputerMovementMode.ClickToMove and
			LocalPlayer.DevComputerMovementMode ~= Enum.DevComputerMovementMode.Scriptable
end

if not UserInputService.TouchEnabled then	-- TODO: Remove when safe on mobile
	IsShiftLockMode = isShiftLockMode()
end

--[[ Constants ]]--
local SHIFT_LOCK_OFF = 'rbxasset://textures/ui/mouseLock_off.png'
local SHIFT_LOCK_ON = 'rbxasset://textures/ui/mouseLock_on.png'
local SHIFT_LOCK_CURSOR = 'rbxasset://textures/MouseLockedCursor.png'

--[[ Local Functions ]]--
local function onShiftLockToggled()
	IsShiftLocked = not IsShiftLocked
	if IsShiftLocked then
		ShiftLockIcon.Image = SHIFT_LOCK_ON
		Mouse.Icon = SHIFT_LOCK_CURSOR
	else
		ShiftLockIcon.Image = SHIFT_LOCK_OFF
		Mouse.Icon = ""
	end
	ShiftLockController.OnShiftLockToggled:Fire()
end

local function initialize()
	if ScreenGui then
		ScreenGui:Destroy()
		ScreenGui = nil
	end
	ScreenGui = Instance.new('ScreenGui')
	ScreenGui.Name = "ControlGui"
	
	local frame = Instance.new('Frame')
	frame.Name = "BottomLeftControl"
	frame.Size = UDim2.new(0, 130, 0, 46)
	frame.Position = UDim2.new(0, 0, 1, -46)
	frame.BackgroundTransparency = 1
	frame.Parent = ScreenGui
	
	ShiftLockIcon = Instance.new('ImageButton')
	ShiftLockIcon.Name = "MouseLockLabel"
	ShiftLockIcon.Size = UDim2.new(0, 31, 0, 31)
	ShiftLockIcon.Position = UDim2.new(0, 12, 0, 2)
	ShiftLockIcon.BackgroundTransparency = 1
	ShiftLockIcon.Image = IsShiftLocked and SHIFT_LOCK_ON or SHIFT_LOCK_OFF
	ShiftLockIcon.Visible = IsShiftLockMode
	ShiftLockIcon.Parent = frame
	
	ShiftLockIcon.MouseButton1Click:connect(onShiftLockToggled)
	
	ScreenGui.Parent = PlayerGui
end

--[[ Public API ]]--
function ShiftLockController:IsShiftLocked()
	return IsShiftLockMode and IsShiftLocked
end

function ShiftLockController:SetIsInFirstPerson(isInFirstPerson)
	IsInFirstPerson = isInFirstPerson
end

--[[ Input/Settings Changed Events ]]--
local mouseLockSwitchFunc = function(actionName, inputState, inputObject)
	if IsShiftLockMode then
		onShiftLockToggled()
	end
end

local function disableShiftLock()
	if ShiftLockIcon then ShiftLockIcon.Visible = false end
	IsShiftLockMode = false
	Mouse.Icon = ""
	if InputCn then
		InputCn:disconnect()
		InputCn = nil
	end
	IsActionBound = false
	ShiftLockController.OnShiftLockToggled:Fire()
end

-- TODO: Remove when we figure out ContextActionService without sinking keys
local function onShiftInputBegan(inputObject, isProcessed)
	if isProcessed then return end
	if inputObject.UserInputType == Enum.UserInputType.Keyboard and
		(inputObject.KeyCode == Enum.KeyCode.LeftShift or inputObject.KeyCode == Enum.KeyCode.RightShift) then
		--
		mouseLockSwitchFunc()
	end
end

local function enableShiftLock()
	IsShiftLockMode = isShiftLockMode()
	if IsShiftLockMode then
		if ShiftLockIcon then
			ShiftLockIcon.Visible = true
		end
		if IsShiftLocked then
			Mouse.Icon = SHIFT_LOCK_CURSOR
			ShiftLockController.OnShiftLockToggled:Fire()
		end
		if not IsActionBound then
			InputCn = UserInputService.InputBegan:connect(onShiftInputBegan)
			IsActionBound = true
		end
	end
end

GameSettings.Changed:connect(function(property)
	if property == 'ControlMode' then
		if GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch then
			enableShiftLock()
		else
			disableShiftLock()
		end
	elseif property == 'ComputerMovementMode' then
		if GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove then
			disableShiftLock()
		else
			enableShiftLock()
		end
	end
end)

LocalPlayer.Changed:connect(function(property)
	if property == 'DevEnableMouseLock' then
		if LocalPlayer.DevEnableMouseLock then
			enableShiftLock()
		else
			disableShiftLock()
		end
	elseif property == 'DevComputerMovementMode' then
		if LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.ClickToMove or
			LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable then
			--
			disableShiftLock()
		else
			enableShiftLock()
		end
	end
end)

LocalPlayer.CharacterAdded:connect(function(character)
	-- we need to recreate guis on character load
	if not UserInputService.TouchEnabled then
		initialize()
	end
end)

--[[ Initialization ]]--
 -- TODO: Remove when safe! ContextActionService crashes touch clients with tupele is 2 or more
if not UserInputService.TouchEnabled then
	initialize()
	if isShiftLockMode() then
		InputCn = UserInputService.InputBegan:connect(onShiftInputBegan)
		IsActionBound = true
	end
end

return ShiftLockController
]]></ProtectedString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCB0D6BD1E22D4B55BA3A3D7021118DC1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TransparencyController</string>
						<ProtectedString name="Source"><![CDATA[-- SolarCrane

local MAX_TWEEN_RATE = 2.8 -- per second

local function clamp(low, high, num)
	if low <= high then
		return math.min(high, math.max(low, num))
	end
	return num
end

local function Round(num, places)
	places = places or 0
	local decimalPivot = 10^places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end

local function CreateTransparencyController()
	local module = {}


	local LastUpdate = tick()
	local TransparencyDirty = false
	local Enabled = false
	local LastTransparency = nil

	local DescendantAddedConn, DescendantRemovingConn = nil, nil
	local ToolDescendantAddedConns = {}
	local ToolDescendantRemovingConns = {}
	local CachedParts = {}

	local function HasToolAncestor(object)
		if object.Parent == nil then return false end
		return object.Parent:IsA('Tool') or HasToolAncestor(object.Parent)
	end

	local function IsValidPartToModify(part)
		if part:IsA('BasePart') or part:IsA('Decal') then
			return not HasToolAncestor(part)
		end
		return false
	end

	local function CachePartsRecursive(object)
		if object then
			if IsValidPartToModify(object) then
				CachedParts[object] = true
				TransparencyDirty = true
			end
			for _, child in pairs(object:GetChildren()) do
				CachePartsRecursive(child)
			end
		end
	end

	local function TeardownTransparency()
		for child, _ in pairs(CachedParts) do
			child.LocalTransparencyModifier = 0
		end
		CachedParts = {}
		TransparencyDirty = true
		LastTransparency = nil

		if DescendantAddedConn then
			DescendantAddedConn:disconnect()
			DescendantAddedConn = nil
		end
		if DescendantRemovingConn then
			DescendantRemovingConn:disconnect()
			DescendantRemovingConn = nil
		end
		for object, conn in pairs(ToolDescendantAddedConns) do
			conn:disconnect()
			ToolDescendantAddedConns[object] = nil
		end
		for object, conn in pairs(ToolDescendantRemovingConns) do
			conn:disconnect()
			ToolDescendantRemovingConns[object] = nil
		end
	end

	local function SetupTransparency(character)
		TeardownTransparency()

		if DescendantAddedConn then DescendantAddedConn:disconnect() end
		DescendantAddedConn = character.DescendantAdded:connect(function(object)
			-- This is a part we want to invisify
			if IsValidPartToModify(object) then
				CachedParts[object] = true
				TransparencyDirty = true
			-- There is now a tool under the character
			elseif object:IsA('Tool') then
				if ToolDescendantAddedConns[object] then ToolDescendantAddedConns[object]:disconnect() end
				ToolDescendantAddedConns[object] = object.DescendantAdded:connect(function(toolChild)
					CachedParts[toolChild] = nil
					if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
						-- Reset the transparency
						toolChild.LocalTransparencyModifier = 0
					end
				end)
				if ToolDescendantRemovingConns[object] then ToolDescendantRemovingConns[object]:disconnect() end
				ToolDescendantRemovingConns[object] = object.DescendantRemoving:connect(function(formerToolChild)
					wait() -- wait for new parent
					if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
						if IsValidPartToModify(formerToolChild) then
							CachedParts[formerToolChild] = true
							TransparencyDirty = true
						end
					end
				end)
			end
		end)
		if DescendantRemovingConn then DescendantRemovingConn:disconnect() end
		DescendantRemovingConn = character.DescendantRemoving:connect(function(object)
			if CachedParts[object] then
				CachedParts[object] = nil
				-- Reset the transparency
				object.LocalTransparencyModifier = 0
			end
		end)
		CachePartsRecursive(character)
	end


	function module:SetEnabled(newState)
		if Enabled ~= newState then
			Enabled = newState
			self:Update()
		end
	end

	function module:SetSubject(subject)
		local character = subject and subject:IsA('Humanoid') and subject.Parent
		if character then
			SetupTransparency(character)
		else
			TeardownTransparency()
		end
	end

	function module:Update()
		local instant = false
		local now = tick()
		local currentCamera = workspace.CurrentCamera

		if currentCamera then
			local transparency = 0
			if not Enabled then
				instant = true
			else
				local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
				transparency = (7 - distance) / 5
				if transparency < 0.5 then
					transparency = 0
				end

				if LastTransparency then
					local deltaTransparency = transparency - LastTransparency
					-- Don't tween transparency if it is instant or your character was fully invisible last frame
					if not instant and transparency < 1 and LastTransparency < 0.95 then
						local maxDelta = MAX_TWEEN_RATE * (now - LastUpdate)
						deltaTransparency = clamp(-maxDelta, maxDelta, deltaTransparency)
					end
					transparency = LastTransparency + deltaTransparency
				else
					TransparencyDirty = true
				end

				transparency = clamp(0, 1, Round(transparency, 2))
			end

			if TransparencyDirty or LastTransparency ~= transparency then
				for child, _ in pairs(CachedParts) do
					child.LocalTransparencyModifier = transparency
				end
				TransparencyDirty = false
				LastTransparency = transparency
			end
		end
		LastUpdate = now
	end

	return module
end

return CreateTransparencyController
]]></ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXEA23287DA9B54000A1D4FC290A32F6E2">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Config</string>
				<ProtectedString name="Source"><![CDATA[return {
	AntiBunnyhop = true,
	BulletOverride = true,
	CameraRecoil = true,
	Zoom = true,
	SpeedModifiers = true,
}]]></ProtectedString>
			</Properties>
		</Item>
	</Item>
</roblox>